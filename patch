diff --git a/device/zte/blade/Android.mk b/device/zte/blade/Android.mk
index 158dd0c..0ffa149 100644
--- a/device/zte/blade/Android.mk
+++ b/device/zte/blade/Android.mk
@@ -13,6 +13,9 @@
 # limitations under the License.
 
 ifeq ($(TARGET_BOOTLOADER_BOARD_NAME),blade)
-#    include $(call all-named-subdir-makefiles, recovery libaudio libril libcamera libgralloc libcopybit libsensors BladeParts liblights)
-    include $(call all-named-subdir-makefiles, recovery libril libgralloc libsensors liblights)
+  include $(call all-named-subdir-makefiles, libaudio libril libcamera libgralloc libcopybit libsensors liblights)
+endif
+LOCAL_STATIC_LIBRARIES += A2dpAudioInterface
+ifeq ($(BOARD_HAVE_BLUETOOTH),true)
+  LOCAL_SHARED_LIBRARIES += audio.a2dp.default libbinder
 endif
diff --git a/device/zte/blade/BladeParts/Android.mk b/device/zte/blade/BladeParts/Android.mk
deleted file mode 100644
index 6ee2fe0..0000000
--- a/device/zte/blade/BladeParts/Android.mk
+++ /dev/null
@@ -1,13 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-java-files-under, src)
-
-LOCAL_PACKAGE_NAME := BladeParts
-LOCAL_CERTIFICATE := platform
-
-include $(BUILD_PACKAGE)
-
-include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/device/zte/blade/BladeParts/AndroidManifest.xml b/device/zte/blade/BladeParts/AndroidManifest.xml
deleted file mode 100644
index f666a00..0000000
--- a/device/zte/blade/BladeParts/AndroidManifest.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-	package="com.cyanogenmod.BladeParts" android:sharedUserId="android.uid.system">
-	<uses-permission android:name="android.permission.SET_ALWAYS_FINISH" />
-	<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
-	<application android:icon="@drawable/icon" android:label="@string/app_name">
-		<activity android:name=".BladeParts" android:label="@string/app_name">
-			<intent-filter>
-				<action android:name="android.intent.action.MAIN" />
-				<action android:name="com.cyanogenmod.action.LAUNCH_DEVICE_SETTINGS" />
-				<category android:name="android.intent.category.DEFAULT" />
-			</intent-filter>
-		</activity>
-		<activity android:name="com.cyanogenmod.BladeParts.ProxCalibration"
-			android:label="@string/prox_calibration_title_head"
-			android:launchMode="singleInstance" android:theme="@android:style/Theme.NoDisplay">
-			<intent-filter>
-				<action android:name="android.intent.action.MAIN" />
-			</intent-filter>
-		</activity>
-		<activity android:name="com.cyanogenmod.BladeParts.ProxCalRestore"
-			android:label="@string/prox_restore_title_head"
-			android:launchMode="singleInstance" android:theme="@android:style/Theme.NoDisplay">
-			<intent-filter>
-				<action android:name="android.intent.action.MAIN" />
-			</intent-filter>
-		</activity>
-		<activity android:name="com.cyanogenmod.BladeParts.ProxDisplay"
-			android:label="@string/prox_display_title_head" android:launchMode="standard">
-			<intent-filter>
-				<action android:name="android.intent.action.MAIN" />
-			</intent-filter>
-		</activity>
-		<receiver android:name=".BladePartsStartup">
-			<intent-filter android:priority="100">
-				<action android:name="android.intent.action.BOOT_COMPLETED" />
-			</intent-filter>
-		</receiver>
-	</application>
-</manifest>
diff --git a/device/zte/blade/BladeParts/res/drawable-hdpi/icon.png b/device/zte/blade/BladeParts/res/drawable-hdpi/icon.png
deleted file mode 100755
index 60fbdf5..0000000
Binary files a/device/zte/blade/BladeParts/res/drawable-hdpi/icon.png and /dev/null differ
diff --git a/device/zte/blade/BladeParts/res/layout-land/prox_display.xml b/device/zte/blade/BladeParts/res/layout-land/prox_display.xml
deleted file mode 100644
index d89a5b4..0000000
--- a/device/zte/blade/BladeParts/res/layout-land/prox_display.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout
-  xmlns:android="http://schemas.android.com/apk/res/android"
-  android:orientation="vertical"
-  android:layout_width="match_parent"
-  android:layout_height="match_parent">
-    <TextView android:id="@+id/textBox" android:layout_width="match_parent" android:layout_height="225dip"></TextView>
-    <Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/back_button" android:text="@string/back_button"></Button>
-</LinearLayout>
diff --git a/device/zte/blade/BladeParts/res/layout/prox_display.xml b/device/zte/blade/BladeParts/res/layout/prox_display.xml
deleted file mode 100644
index 2d421b0..0000000
--- a/device/zte/blade/BladeParts/res/layout/prox_display.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout
-  xmlns:android="http://schemas.android.com/apk/res/android"
-  android:orientation="vertical"
-  android:layout_width="match_parent"
-  android:layout_height="match_parent">
-    <TextView android:id="@+id/textBox" android:layout_width="match_parent" android:layout_height="440dip"></TextView>
-    <Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/back_button" android:text="@string/back_button"></Button>
-</LinearLayout>
diff --git a/device/zte/blade/BladeParts/res/values-hu/strings.xml b/device/zte/blade/BladeParts/res/values-hu/strings.xml
deleted file mode 100644
index 8410e2d..0000000
--- a/device/zte/blade/BladeParts/res/values-hu/strings.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-        <string name="app_name">ZTE Blade beállítások</string>
-        <string name="prox_calibration_title_head">Proximity szenzor kalibráció</string>
-        <string name="prox_calibration_summary_head">Kalibráció alatt ne tegyen semmit a képernyő tetejének közelébe!</string>
-        <string name="prox_display_title_head">Proximity szenzor adatok</string>
-        <string name="prox_display_summary_head">Aktuális proximity szenzor kalibrációs adatok</string>
-        <string name="toast_error">Hiba:</string>
-        <string name="back_button">Vissza</string>
-        <string name="prox_restore_title_head">Alapértelmezett adatok visszaállítása</string>
-        <string name="prox_restore_summary_head">Kalibrációs adatok törlése (újraindítást igényel).</string>
-        <string name="delete_success">Alapértelmezett adatok sikeresen visszaállítva. Indítsa újra a telefont.</string>
-        <string name="delete_error">Nem sikerült visszaállítani az alapértelmezett adatokat.</string>
-        <string name="delete_no_file">Eddig is az alapértelmezett adatok voltak érvényben.</string>
-
-        <string name="usb_charging_title_head">USB töltés</string>
-        <string name="usb_charging_summary_head">USB töltés engedélyezése/tiltása</string>
-</resources>
diff --git a/device/zte/blade/BladeParts/res/values-it/strings.xml b/device/zte/blade/BladeParts/res/values-it/strings.xml
deleted file mode 100644
index 3e149a4..0000000
--- a/device/zte/blade/BladeParts/res/values-it/strings.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-        <string name="app_name">Impostazioni ZTE Blade</string>
-        <string name="prox_calibration_title_head">Calibrazione sensore di prossimità</string>
-        <string name="prox_calibration_summary_head">Calibra il sensore di prossimità</string>
-        <string name="prox_display_title_head">Dati sensore di prossimità</string>
-        <string name="prox_display_summary_head">Visualizza i dati attuali del sensore di prossimità</string>
-        <string  name="toast_error">Errore:</string>
-        <string  name="back_button">Indietro</string>
-</resources>
diff --git a/device/zte/blade/BladeParts/res/values-pt-rPT/strings.xml b/device/zte/blade/BladeParts/res/values-pt-rPT/strings.xml
deleted file mode 100644
index bbef422..0000000
--- a/device/zte/blade/BladeParts/res/values-pt-rPT/strings.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-        <string name="app_name">Definições ZTE Blade</string>
-        <string name="prox_calibration_title_head">Calibrar sensor de proximidade</string>
-        <string name="prox_calibration_summary_head">Calibração do sensor de proximidade</string>
-        <string name="prox_display_title_head">Dados do sensor de proximidade</string>
-        <string name="prox_display_summary_head">Mostra os dados actuais de calibração do sensor de proximidade</string>
-        <string name="toast_error">Erro:</string>
-        <string name="back_button">Voltar</string>
-        <string name="usb_charging_title_head">Carregamento via USB</string>
-        <string name="usb_charging_summary_head">Activar/Desactivar carregamento</string>
-</resources>
diff --git a/device/zte/blade/BladeParts/res/values-zh-rCN/strings.xml b/device/zte/blade/BladeParts/res/values-zh-rCN/strings.xml
deleted file mode 100644
index 1667899..0000000
--- a/device/zte/blade/BladeParts/res/values-zh-rCN/strings.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-        <string name="app_name">Blade 设置</string>
-        <string name="prox_calibration_title_head">校准距离传感器</string>
-        <string name="prox_calibration_summary_head">当运行距离传感器校准时，不要在靠近屏幕顶部放置任何东西</string>
-        <string name="prox_display_title_head">显示距离传感器数据</string>
-        <string name="prox_display_summary_head">显示当前的距离传感器校准数据</string>
-        <string name="toast_error">错误:</string>
-        <string name="back_button">返回</string>
-        <string name="prox_restore_title_head">重置距离为默认值</string>
-        <string name="prox_restore_summary_head">移除校准数据(需要重启).</string>
-
-        <string name="delete_success">成功的恢复为默认值.请重启机器.</string>
-        <string name="delete_error">重置为默认值时失败.</string>
-        <string name="delete_no_file">已经使用默认值.</string>
-
-        <string name="usb_charging_title_head">USB 充电</string>
-        <string name="usb_charging_summary_head">开启/关闭USB充电</string>
-</resources>
diff --git a/device/zte/blade/BladeParts/res/values-zh-rTW/strings.xml b/device/zte/blade/BladeParts/res/values-zh-rTW/strings.xml
deleted file mode 100644
index 07a8e8a..0000000
--- a/device/zte/blade/BladeParts/res/values-zh-rTW/strings.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-        <string name="app_name">ZTE Blade 設定</string>
-        <string name="prox_calibration_title_head">距離感應器校準</string>
-        <string name="prox_calibration_summary_head">校準距離感應器</string>
-        <string name="prox_display_title_head">距離感應器數據</string>
-        <string name="prox_display_summary_head">顯示距離感應器目前的校準數據</string>
-        <string  name="toast_error">錯誤：</string>
-        <string  name="back_button">返回</string>
-        <string name="usb_charging_title_head">USB 充電</string>
-        <string name="usb_charging_summary_head">啟用／停用充電</string>
-</resources>
diff --git a/device/zte/blade/BladeParts/res/values/strings.xml b/device/zte/blade/BladeParts/res/values/strings.xml
deleted file mode 100644
index cf4e8e0..0000000
--- a/device/zte/blade/BladeParts/res/values/strings.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-        <string name="app_name">ZTE Blade Settings</string>
-        <string name="prox_calibration_title_head">Calibrate proximity sensor</string>
-        <string name="prox_calibration_summary_head">Do not put anything near the top of the screen while running</string>
-        <string name="prox_display_title_head">Display proximity sensor data</string>
-        <string name="prox_display_summary_head">Show current proximity sensor calibration data</string>
-        <string name="toast_error">Error:</string>
-        <string name="back_button">Back</string>
-        <string name="prox_restore_title_head">Restore proximity defaults</string>
-        <string name="prox_restore_summary_head">Removes the calibration data (Requires reboot).</string>
-        <string name="delete_success">Successfully restored default. Please reboot.</string>
-        <string name="delete_error">Failed to restore defaults.</string>
-        <string name="delete_no_file">Already using defaults.</string>
-
-        <string name="usb_charging_title_head">USB Charging</string>
-        <string name="usb_charging_summary_head">Enable/Disable charging</string>
-</resources>
diff --git a/device/zte/blade/BladeParts/res/xml/bladeparts.xml b/device/zte/blade/BladeParts/res/xml/bladeparts.xml
deleted file mode 100644
index 40679b0..0000000
--- a/device/zte/blade/BladeParts/res/xml/bladeparts.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
-
-	<!-- Display proximity calibration data -->
-	<PreferenceScreen android:key="prox_display"
-		android:title="@string/prox_display_title_head" android:summary="@string/prox_display_summary_head">
-
-		<intent android:action="android.intent.action.MAIN"
-			android:targetPackage="com.cyanogenmod.BladeParts"
-			android:targetClass="com.cyanogenmod.BladeParts.ProxDisplay" />
-	</PreferenceScreen>
-
-	<!-- Proximity sensor calibration -->
-	<PreferenceScreen android:key="prox_calibration"
-		android:title="@string/prox_calibration_title_head" android:summary="@string/prox_calibration_summary_head">
-
-		<intent android:action="android.intent.action.MAIN"
-			android:targetPackage="com.cyanogenmod.BladeParts"
-			android:targetClass="com.cyanogenmod.BladeParts.ProxCalibration" />
-	</PreferenceScreen>
-
-	<!-- Proximity sensor restore defaults -->
-	<PreferenceScreen android:key="prox_restore"
-		android:title="@string/prox_restore_title_head" android:summary="@string/prox_restore_summary_head">
-
-		<intent android:action="android.intent.action.MAIN"
-			android:targetPackage="com.cyanogenmod.BladeParts"
-			android:targetClass="com.cyanogenmod.BladeParts.ProxCalRestore" />
-	</PreferenceScreen>
-
-	<!-- USB Charging -->
-	<CheckBoxPreference
-		android:key="usb_charging"
-		android:title="@string/usb_charging_title_head"
-		android:summary="@string/usb_charging_summary_head"
-		android:defaultValue="true" />
-
-</PreferenceScreen>
diff --git a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/BladeParts.java b/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/BladeParts.java
deleted file mode 100644
index 0047b78..0000000
--- a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/BladeParts.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package com.cyanogenmod.BladeParts;
-
-import com.cyanogenmod.BladeParts.R;
-
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.preference.PreferenceActivity;
-import android.preference.PreferenceManager;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-
-public class BladeParts extends PreferenceActivity {
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		addPreferencesFromResource(R.xml.bladeparts);
-	}
-
-   private void writeValue(String parameter, int value) {
-      try {
-          FileOutputStream fos = new FileOutputStream(new File(parameter));
-          fos.write(String.valueOf(value).getBytes());
-          fos.flush();
-          fos.getFD().sync();
-          fos.close();
-      } catch (FileNotFoundException e) {
-         e.printStackTrace();
-      } catch (IOException e) {
-         e.printStackTrace();
-      }
-   }
-
-   @Override
-   public void onPause() {
-      super.onPause();
-      SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getBaseContext());
-      // USB charging
-      if(prefs.getBoolean("usb_charging", true))
-         writeValue("/sys/module/msm_battery/parameters/usb_chg_enable", 1);
-      else
-         writeValue("/sys/module/msm_battery/parameters/usb_chg_enable", 0);
-   }
-}
diff --git a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/BladePartsStartup.java b/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/BladePartsStartup.java
deleted file mode 100644
index 4e9eb58..0000000
--- a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/BladePartsStartup.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.cyanogenmod.BladeParts;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-
-public class BladePartsStartup extends BroadcastReceiver
-{
-   private void writeValue(String parameter, int value) {
-      try {
-          FileOutputStream fos = new FileOutputStream(new File(parameter));
-          fos.write(String.valueOf(value).getBytes());
-          fos.flush();
-          fos.getFD().sync();
-          fos.close();
-      } catch (FileNotFoundException e) {
-         e.printStackTrace();
-      } catch (IOException e) {
-         e.printStackTrace();
-      }
-   }
-
-   @Override
-   public void onReceive(final Context context, final Intent bootintent) {
-      SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
-      // USB charging
-      if(prefs.getBoolean("usb_charging", true))
-         writeValue("/sys/module/msm_battery/parameters/usb_chg_enable", 1);
-      else
-         writeValue("/sys/module/msm_battery/parameters/usb_chg_enable", 0);
-   }
-}
diff --git a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxCalRestore.java b/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxCalRestore.java
deleted file mode 100644
index 981a536..0000000
--- a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxCalRestore.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.cyanogenmod.BladeParts;
-
-import java.io.File;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.Toast;
-
-public class ProxCalRestore extends Activity {
-	final private static String TAG = "ProxCal";
-	final private static String fileName = "/data/misc/prox_data.txt";
-
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		Toast toast;
-		File f = new File(fileName);
-
-		if(f.exists())
-		    if(f.delete())
-			toast = Toast.makeText(ProxCalRestore.this, getString(R.string.delete_success), Toast.LENGTH_LONG);
-		    else toast = Toast.makeText(ProxCalRestore.this, getString(R.string.delete_error), Toast.LENGTH_LONG);
-		else toast = Toast.makeText(ProxCalRestore.this, getString(R.string.delete_no_file), Toast.LENGTH_LONG);
-
-		toast.show();
-		finish();
-
-	}
-
-}
diff --git a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxCalibration.java b/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxCalibration.java
deleted file mode 100644
index f4b3ebb..0000000
--- a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxCalibration.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.cyanogenmod.BladeParts;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.Toast;
-
-public class ProxCalibration extends Activity {
-	final private static String TAG = "ProxCal";
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		Toast toast;
-		try {
-			Process p = Runtime.getRuntime().exec("/system/bin/prox_cal -c");
-			BufferedReader commandResult = new BufferedReader(
-					new InputStreamReader(new BufferedInputStream(
-							p.getInputStream())));
-			p.waitFor();
-			String returned = commandResult.readLine();
-			Log.d(TAG, returned);
-			toast = Toast.makeText(ProxCalibration.this, returned,
-					Toast.LENGTH_LONG);
-
-		} catch (Exception ex) {
-			toast = Toast.makeText(ProxCalibration.this,
-					getString(R.string.toast_error) + " " + ex.getMessage(),
-					Toast.LENGTH_LONG);
-		}
-
-		toast.show();
-		finish();
-
-	}
-
-}
diff --git a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxDisplay.java b/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxDisplay.java
deleted file mode 100644
index e6fab5c..0000000
--- a/device/zte/blade/BladeParts/src/com/cyanogenmod/BladeParts/ProxDisplay.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package com.cyanogenmod.BladeParts;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.TextView;
-
-public class ProxDisplay extends Activity implements OnClickListener {
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		setContentView(R.layout.prox_display);
-
-		View backButton = findViewById(R.id.back_button);
-		backButton.setOnClickListener(this);
-
-		TextView textBox = new TextView(this);
-		textBox = (TextView) findViewById(R.id.textBox);
-
-		try {
-			Process p = Runtime.getRuntime().exec("/system/bin/prox_cal -d");
-			BufferedReader commandResult = new BufferedReader(
-					new InputStreamReader(new BufferedInputStream(
-							p.getInputStream())));
-			p.waitFor();
-			String returned;
-			while ((returned = commandResult.readLine()) != null) {
-				textBox.append(returned + "\n");
-			}
-
-		} catch (Exception ex) {
-			textBox.setText("Error: " + ex.getMessage());
-		}
-	}
-
-	public void onClick(View v) {
-		switch (v.getId()) {
-		case R.id.back_button:
-			finish();
-		}
-	}
-}
diff --git a/device/zte/blade/BoardConfig.mk b/device/zte/blade/BoardConfig.mk
index 8e11eee..5d78404 100644
--- a/device/zte/blade/BoardConfig.mk
+++ b/device/zte/blade/BoardConfig.mk
@@ -4,7 +4,7 @@
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
-# http://www.apache.org/licenses/LICENSE-2.0
+#      http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
@@ -25,9 +25,11 @@ LOCAL_PATH:= $(call my-dir)
 USE_CAMERA_STUB := false
 
 BOARD_HAS_FLIPPED_SCREEN := true
+COMMON_GLOBAL_CFLAGS += -DMISSING_EGL_EXTERNAL_IMAGE -DMISSING_EGL_PIXEL_FORMAT_YV12 -DMISSING_GRALLOC_BUFFERS
+TARGET_SPECIFIC_HEADER_PATH := device/zte/blade/include
 
 TARGET_NO_BOOTLOADER := true
-COMMON_GLOBAL_CFLAGS += -DMISSING_EGL_EXTERNAL_IMAGE -DMISSING_EGL_PIXEL_FORMAT_YV12 -DMISSING_GRALLOC_BUFFERS
+
 TARGET_PREBUILT_RECOVERY_KERNEL := device/zte/blade/recovery_kernel
 
 BOARD_KERNEL_CMDLINE := androidboot.hardware=blade console=null
@@ -49,8 +51,8 @@ BOARD_FM_DEVICE := si4708
 
 # Wifi related defines
 BOARD_WPA_SUPPLICANT_DRIVER := AWEXT
-WIFI_DRIVER_MODULE_PATH := /system/wifi/ar6000.ko
-WIFI_DRIVER_MODULE_NAME := ar6000
+WIFI_DRIVER_MODULE_PATH     := /system/wifi/ar6000.ko
+WIFI_DRIVER_MODULE_NAME     := ar6000
 
 #WITH_JIT := true
 WITH_JIT := false
@@ -71,9 +73,9 @@ BOARD_GPS_LIBRARIES := libloc_api
 
 BOARD_USES_QCOM_HARDWARE := true
 BOARD_USES_QCOM_LIBS := true
-#BOARD_USES_QCOM_GPS := true
-#BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE := blade
-#BOARD_VENDOR_QCOM_GPS_LOC_API_AMSS_VERSION := 1240
+BOARD_USES_QCOM_GPS := true
+BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE := blade
+BOARD_VENDOR_QCOM_GPS_LOC_API_AMSS_VERSION := 1240
 BOARD_GPS_LIBRARIES := libloc
 BOARD_USES_GPSSHIM := true
 BOARD_GPS_NEEDS_XTRA := true
@@ -83,15 +85,14 @@ BOARD_KERNEL_BASE := 0x02600000
 #BOARD_PAGE_SIZE := 0x00000800
 
 TARGET_PROVIDES_LIBRIL := true
-#TARGET_PROVIDES_LIBAUDIO := true
-TARGET_PROVIDES_LIBAUDIO := false
+TARGET_PROVIDES_LIBAUDIO := true
 
 BOARD_CUSTOM_USB_CONTROLLER := ../../device/zte/blade/UsbController.cpp
 
 BOARD_UMS_LUNFILE := "/sys/devices/platform/msm_hsusb/gadget/lun0/file"
 
 # # cat /proc/mtd
-# dev: size erasesize name
+# dev:    size   erasesize  name
 # mtd0: 00480000 00020000 "recovery"
 # mtd1: 00480000 00020000 "boot"
 # mtd2: 00180000 00020000 "splash"
@@ -102,13 +103,11 @@ BOARD_UMS_LUNFILE := "/sys/devices/platform/msm_hsusb/gadget/lun0/file"
 # mtd7: 00180000 00020000 "persist"
 
 
-BOARD_BOOTIMAGE_PARTITION_SIZE := 0x00480000
+BOARD_BOOTIMAGE_PARTITION_SIZE     := 0x00480000
 BOARD_RECOVERYIMAGE_PARTITION_SIZE := 0x00480000
-BOARD_SYSTEMIMAGE_PARTITION_SIZE := 0x0cf80000
+BOARD_SYSTEMIMAGE_PARTITION_SIZE   := 0x0cf80000
 BOARD_USERDATAIMAGE_PARTITION_SIZE := 0x0d020000
 BOARD_FLASH_BLOCK_SIZE := 131072
 
 BOARD_CUSTOM_RECOVERY_KEYMAPPING:= ../../device/zte/blade/recovery/recovery_ui.c
 TARGET_RECOVERY_INITRC := device/zte/blade/recovery/recovery.rc
-
-
diff --git a/device/zte/blade/device_blade.mk b/device/zte/blade/device_blade.mk
index 27fc578..c8ecfbf 100644
--- a/device/zte/blade/device_blade.mk
+++ b/device/zte/blade/device_blade.mk
@@ -44,7 +44,10 @@ PRODUCT_PACKAGES += \
     Development \
     Term \
     gralloc.blade \
+    audio.a2dp.default \
     copybit.blade \
+    audio.primary.blade \
+    audio_policy.blade \
     gps.blade \
     lights.blade \
     sensors.blade \
@@ -88,10 +91,6 @@ PRODUCT_COPY_FILES += \
     device/zte/blade/prebuilt/hostapd:system/bin/hostapd \
     device/zte/blade/prebuilt/hostapd.conf:system/etc/wifi/hostapd.conf
     
-# GPS
-PRODUCT_COPY_FILES += \
-    device/zte/blade/gps.blade.so:system/lib/hw/gps.blade.so
-
 # Install the features available on this device.
 PRODUCT_COPY_FILES += \
     frameworks/base/data/etc/handheld_core_hardware.xml:system/etc/permissions/handheld_core_hardware.xml \
diff --git a/device/zte/blade/gps.blade.so b/device/zte/blade/gps.blade.so
deleted file mode 100644
index 35b6ca7..0000000
Binary files a/device/zte/blade/gps.blade.so and /dev/null differ
diff --git a/device/zte/blade/libaudio/Android.mk b/device/zte/blade/libaudio/Android.mk
index 2e5b918..b96b676 100644
--- a/device/zte/blade/libaudio/Android.mk
+++ b/device/zte/blade/libaudio/Android.mk
@@ -1,19 +1,23 @@
-ifeq ($(TARGET_BOOTLOADER_BOARD_NAME),blade)
 
-LOCAL_PATH:= $(call my-dir)
+ifneq ($(BUILD_TINY_ANDROID),true)
+
+LOCAL_PATH := $(call my-dir)
+
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES:=               \
-    AudioPolicyManager.cpp
+LOCAL_MODULE := audio_policy.blade
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_STATIC_LIBRARIES := libmedia_helper
+LOCAL_WHOLE_STATIC_LIBRARIES := libaudiopolicy_legacy
+LOCAL_MODULE_TAGS := optional
 
 LOCAL_SHARED_LIBRARIES := \
     libcutils \
     libutils \
     libmedia
 
-LOCAL_STATIC_LIBRARIES := libaudiopolicybase
+LOCAL_SRC_FILES:= AudioPolicyManager.cpp
 
-LOCAL_MODULE:= libaudiopolicy
 
 ifeq ($(BOARD_HAVE_BLUETOOTH),true)
   LOCAL_CFLAGS += -DWITH_A2DP
@@ -24,32 +28,28 @@ include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
 
-LOCAL_MODULE := libaudio
+LOCAL_MODULE := audio.primary.blade
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_STATIC_LIBRARIES += libmedia_helper
+LOCAL_WHOLE_STATIC_LIBRARIES := libaudiohw_legacy
+LOCAL_MODULE_TAGS := optional
 
 LOCAL_SHARED_LIBRARIES := \
     libcutils \
     libutils \
     libmedia \
-    libhardware_legacy
+    libhardware_legacy \
+    libdl
 
-ifeq ($TARGET_OS)-$(TARGET_SIMULATOR),linux-true)
-LOCAL_LDLIBS += -ldl
-endif
-
-ifneq ($(TARGET_SIMULATOR),true)
-LOCAL_SHARED_LIBRARIES += libdl
-endif
-
-LOCAL_SRC_FILES += AudioHardware.cpp
+LOCAL_SRC_FILES := AudioHardware.cpp
 
 LOCAL_CFLAGS += -fno-short-enums
 
-LOCAL_STATIC_LIBRARIES += libaudiointerface
 ifeq ($(BOARD_HAVE_BLUETOOTH),true)
-  LOCAL_SHARED_LIBRARIES += liba2dp libbinder
+  LOCAL_SHARED_LIBRARIES += audio.a2dp.default
 endif
 
 include $(BUILD_SHARED_LIBRARY)
 
-endif
+endif # not BUILD_TINY_ANDROID
 
diff --git a/device/zte/blade/libaudio/AudioHardware.cpp b/device/zte/blade/libaudio/AudioHardware.cpp
index b0ac305..56c4ddc 100644
--- a/device/zte/blade/libaudio/AudioHardware.cpp
+++ b/device/zte/blade/libaudio/AudioHardware.cpp
@@ -1,6 +1,5 @@
 /*
 ** Copyright 2008, The Android Open-Source Project
-** Copyright (c) 2010, Code Aurora Forum. All rights reserved.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -17,7 +16,7 @@
 
 #include <math.h>
 
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #define LOG_TAG "AudioHardwareMSM72XX"
 #include <utils/Log.h>
 #include <utils/String8.h>
@@ -37,156 +36,102 @@
 
 #define LOG_SND_RPC 0  // Set to 1 to log sound RPC's
 
-#define COMBO_DEVICE_SUPPORTED 0 // Headset speaker combo device not supported on this target
-#define DUALMIC_KEY "dualmic_enabled"
-#define TTY_MODE_KEY "tty_mode"
-
-#ifdef HAVE_FM_RADIO
-#define Si4708_IOC_MAGIC  'k'
-#define Si4708_IOC_SET_VOL                    _IOW(Si4708_IOC_MAGIC, 8,int)
-#endif
-
-//namespace android {
 namespace android_audio_legacy {
 static int audpre_index, tx_iir_index;
 static void * acoustic;
 const uint32_t AudioHardware::inputSamplingRates[] = {
         8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000
 };
-
-static int get_audpp_filter(void);
-static int msm72xx_enable_postproc(bool state);
-
-// Post processing paramters
-static struct rx_iir_filter iir_cfg[3];
-static struct adrc_filter adrc_cfg[3];
-static struct mbadrc_filter mbadrc_cfg[3];
-eqalizer eqalizer[3];
-static uint16_t adrc_flag[3];
-static uint16_t mbadrc_flag[3];
-static uint16_t eq_flag[3];
-static uint16_t rx_iir_flag[3];
-static uint16_t agc_flag[3];
-static uint16_t ns_flag[3];
-static uint16_t txiir_flag[3];
-static bool audpp_filter_inited = false;
-static bool adrc_filter_exists[3];
-static bool mbadrc_filter_exists[3];
-static int post_proc_feature_mask = 0;
-static bool playback_in_progress = false;
-
-//Pre processing parameters
-static struct tx_iir tx_iir_cfg[9];
-static struct ns ns_cfg[9];
-static struct tx_agc tx_agc_cfg[9];
-static int enable_preproc_mask;
-
-static int snd_device = -1;
-
-#define PCM_OUT_DEVICE "/dev/msm_pcm_out"
-#define PCM_IN_DEVICE "/dev/msm_pcm_in"
-#define PCM_CTL_DEVICE "/dev/msm_pcm_ctl"
-#define PREPROC_CTL_DEVICE "/dev/msm_preproc_ctl"
-#define VOICE_MEMO_DEVICE "/dev/msm_voicememo"
-
-static uint32_t SND_DEVICE_CURRENT=-1;
-static uint32_t SND_DEVICE_HANDSET=-1;
-static uint32_t SND_DEVICE_SPEAKER=-1;
-static uint32_t SND_DEVICE_BT=-1;
-static uint32_t SND_DEVICE_BT_EC_OFF=-1;
-static uint32_t SND_DEVICE_HEADSET=-1;
-static uint32_t SND_DEVICE_HEADSET_AND_SPEAKER=-1;
-static uint32_t SND_DEVICE_IN_S_SADC_OUT_HANDSET=-1;
-static uint32_t SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE=-1;
-static uint32_t SND_DEVICE_TTY_HEADSET=-1;
-static uint32_t SND_DEVICE_TTY_HCO=-1;
-static uint32_t SND_DEVICE_TTY_VCO=-1;
-static uint32_t SND_DEVICE_CARKIT=-1;
-static uint32_t SND_DEVICE_FM_SPEAKER=-1;
-static uint32_t SND_DEVICE_FM_HEADSET=-1;
-static uint32_t SND_DEVICE_NO_MIC_HEADSET=-1;
 // ----------------------------------------------------------------------------
 
 AudioHardware::AudioHardware() :
     mInit(false), mMicMute(true), mBluetoothNrec(true), mBluetoothId(0),
-    mOutput(0), mSndEndpoints(NULL), mCurSndDevice(-1), mDualMicEnabled(false), mBuiltinMicSelected(false),
-    mFmRadioEnabled(false),mFmPrev(false),mFmVolume(0),fmfd(-1)
+    mOutput(0), mSndEndpoints(NULL), mCurSndDevice(-1),
+    SND_DEVICE_CURRENT(-1),
+    SND_DEVICE_HANDSET(-1),
+    SND_DEVICE_SPEAKER(-1),
+    SND_DEVICE_HEADSET(-1),
+    SND_DEVICE_BT(-1),
+    SND_DEVICE_CARKIT(-1),
+    SND_DEVICE_TTY_FULL(-1),
+    SND_DEVICE_TTY_VCO(-1),
+    SND_DEVICE_TTY_HCO(-1),
+    SND_DEVICE_NO_MIC_HEADSET(-1),
+    SND_DEVICE_FM_HEADSET(-1),
+    SND_DEVICE_HEADSET_AND_SPEAKER(-1),
+    SND_DEVICE_FM_SPEAKER(-1),
+    SND_DEVICE_BT_EC_OFF(-1)
 {
-   if (get_audpp_filter() == 0) {
-           audpp_filter_inited = true;
-   }
-
-    m7xsnddriverfd = open("/dev/msm_snd", O_RDWR);
-    if (m7xsnddriverfd >= 0) {
-        int rc = ioctl(m7xsnddriverfd, SND_GET_NUM_ENDPOINTS, &mNumSndEndpoints);
-        if (rc >= 0) {
-            mSndEndpoints = new msm_snd_endpoint[mNumSndEndpoints];
-            mInit = true;
-            LOGV("constructed (%d SND endpoints)", rc);
-            struct msm_snd_endpoint *ept = mSndEndpoints;
-            for (int cnt = 0; cnt < mNumSndEndpoints; cnt++, ept++) {
-                ept->id = cnt;
-                ioctl(m7xsnddriverfd, SND_GET_ENDPOINT, ept);
-                LOGV("cnt = %d ept->name = %s ept->id = %d\n", cnt, ept->name, ept->id);
-#define CHECK_FOR(desc) if (!strcmp(ept->name, #desc)) SND_DEVICE_##desc = ept->id;
-                CHECK_FOR(CURRENT);
-                CHECK_FOR(HANDSET);
-                CHECK_FOR(SPEAKER);
-                CHECK_FOR(BT);
-                CHECK_FOR(BT_EC_OFF);
-                CHECK_FOR(HEADSET);
-                CHECK_FOR(HEADSET_AND_SPEAKER);
-                CHECK_FOR(IN_S_SADC_OUT_HANDSET);
-                CHECK_FOR(IN_S_SADC_OUT_SPEAKER_PHONE);
-                CHECK_FOR(TTY_HEADSET);
-                CHECK_FOR(TTY_HCO);
-                CHECK_FOR(TTY_VCO);
-#undef CHECK_FOR
-            }
-        }
-        else LOGE("Could not retrieve number of MSM SND endpoints.");
-
-        int AUTO_VOLUME_ENABLED = 1; // setting enabled as default
-
-        static const char *const path = "/system/etc/AutoVolumeControl.txt";
-        int txtfd;
-        struct stat st;
-        char *read_buf;
-
-        txtfd = open(path, O_RDONLY);
-        if (txtfd < 0) {
-            LOGE("failed to open AUTO_VOLUME_CONTROL %s: %s (%d)",
-                  path, strerror(errno), errno);
-        }
-        else {
-            if (fstat(txtfd, &st) < 0) {
-                LOGE("failed to stat %s: %s (%d)",
-                      path, strerror(errno), errno);
-                close(txtfd);
-            }
-
-            read_buf = (char *) mmap(0, st.st_size,
-                        PROT_READ | PROT_WRITE,
-                        MAP_PRIVATE,
-                        txtfd, 0);
-
-            if (read_buf == MAP_FAILED) {
-                LOGE("failed to mmap parameters file: %s (%d)",
-                      strerror(errno), errno);
-                close(txtfd);
-            }
-
-            if(read_buf[0] =='0')
-               AUTO_VOLUME_ENABLED = 0;
-
-            munmap(read_buf, st.st_size);
-            close(txtfd);
-        }
 
-        ioctl(m7xsnddriverfd, SND_AVC_CTL, &AUTO_VOLUME_ENABLED);
-        ioctl(m7xsnddriverfd, SND_AGC_CTL, &AUTO_VOLUME_ENABLED);
+    int (*snd_get_num)();
+    int (*snd_get_endpoint)(int, msm_snd_endpoint *);
+    int (*set_acoustic_parameters)();
+
+    struct msm_snd_endpoint *ept;
+
+    acoustic = ::dlopen("/system/lib/libhtc_acoustic.so", RTLD_NOW);
+    if (acoustic == NULL ) {
+        LOGE("Could not open libhtc_acoustic.so");
+        /* this is not really an error on non-htc devices... */
+        mNumSndEndpoints = 0;
+        mInit = true;
+        return;
+    }
+
+    set_acoustic_parameters = (int (*)(void))::dlsym(acoustic, "set_acoustic_parameters");
+    if ((*set_acoustic_parameters) == 0 ) {
+        LOGE("Could not open set_acoustic_parameters()");
+        return;
+    }
+
+    int rc = set_acoustic_parameters();
+    if (rc < 0) {
+        LOGE("Could not set acoustic parameters to share memory: %d", rc);
+//        return;
+    }
+
+    snd_get_num = (int (*)(void))::dlsym(acoustic, "snd_get_num_endpoints");
+    if ((*snd_get_num) == 0 ) {
+        LOGE("Could not open snd_get_num()");
+//        return;
+    }
+
+    mNumSndEndpoints = snd_get_num();
+    LOGD("mNumSndEndpoints = %d", mNumSndEndpoints);
+    mSndEndpoints = new msm_snd_endpoint[mNumSndEndpoints];
+    mInit = true;
+    LOGV("constructed %d SND endpoints)", mNumSndEndpoints);
+    ept = mSndEndpoints;
+    snd_get_endpoint = (int (*)(int, msm_snd_endpoint *))::dlsym(acoustic, "snd_get_endpoint");
+    if ((*snd_get_endpoint) == 0 ) {
+        LOGE("Could not open snd_get_endpoint()");
+        return;
+    }
+
+    for (int cnt = 0; cnt < mNumSndEndpoints; cnt++, ept++) {
+        ept->id = cnt;
+        snd_get_endpoint(cnt, ept);
+#define CHECK_FOR(desc) \
+        if (!strcmp(ept->name, #desc)) { \
+            SND_DEVICE_##desc = ept->id; \
+            LOGD("BT MATCH " #desc); \
+        } else
+        CHECK_FOR(CURRENT)
+        CHECK_FOR(HANDSET)
+        CHECK_FOR(SPEAKER)
+        CHECK_FOR(BT)
+        CHECK_FOR(BT_EC_OFF)
+        CHECK_FOR(HEADSET)
+        CHECK_FOR(CARKIT)
+        CHECK_FOR(TTY_FULL)
+        CHECK_FOR(TTY_VCO)
+        CHECK_FOR(TTY_HCO)
+        CHECK_FOR(NO_MIC_HEADSET)
+        CHECK_FOR(FM_HEADSET)
+        CHECK_FOR(FM_SPEAKER)
+        CHECK_FOR(HEADSET_AND_SPEAKER) {}
+#undef CHECK_FOR
     }
-	else LOGE("Could not open MSM SND driver.");
 }
 
 AudioHardware::~AudioHardware()
@@ -201,12 +146,6 @@ AudioHardware::~AudioHardware()
         ::dlclose(acoustic);
         acoustic = 0;
     }
-    if (m7xsnddriverfd > 0)
-    {
-      close(m7xsnddriverfd);
-      m7xsnddriverfd = -1;
-    }
-    enable_preproc_mask = 0;
     mInit = false;
 }
 
@@ -219,19 +158,17 @@ AudioStreamOut* AudioHardware::openOutputStream(
         uint32_t devices, int *format, uint32_t *channels, uint32_t *sampleRate, status_t *status)
 {
     { // scope for the lock
-        //Mutex::Autolock lock(mLock);
-		android::Mutex::Autolock lock(mLock);
+        android::Mutex::Autolock lock(mLock);
 
-        // only one output stream allowed
+        AudioStreamOutMSM72xx* out;
         if (mOutput) {
-            if (status) {
-                *status = INVALID_OPERATION;
-            }
-            return 0;
+            // only one output stream allowed
+            out = mOutput;
+        } else {
+            //create new output stream
+            out = new AudioStreamOutMSM72xx();
         }
 
-        // create new output stream
-        AudioStreamOutMSM72xx* out = new AudioStreamOutMSM72xx();
         status_t lStatus = out->set(this, devices, format, channels, sampleRate);
         if (status) {
             *status = lStatus;
@@ -246,8 +183,7 @@ AudioStreamOut* AudioHardware::openOutputStream(
 }
 
 void AudioHardware::closeOutputStream(AudioStreamOut* out) {
-    //Mutex::Autolock lock(mLock);
-	android::Mutex::Autolock lock(mLock);
+    android::Mutex::Autolock lock(mLock);
     if (mOutput == 0 || mOutput != out) {
         LOGW("Attempt to close invalid output stream");
     }
@@ -286,8 +222,7 @@ AudioStreamIn* AudioHardware::openInputStream(
 }
 
 void AudioHardware::closeInputStream(AudioStreamIn* in) {
-    //Mutex::Autolock lock(mLock);
-	android::Mutex::Autolock lock(mLock);
+    android::Mutex::Autolock lock(mLock);
 
     ssize_t index = mInputs.indexOf((AudioStreamInMSM72xx *)in);
     if (index < 0) {
@@ -322,8 +257,7 @@ bool AudioHardware::checkOutputStandby()
 
 status_t AudioHardware::setMicMute(bool state)
 {
-    //Mutex::Autolock lock(mLock);
-	android::Mutex::Autolock lock(mLock);
+    android::Mutex::Autolock lock(mLock);
     return setMicMute_nosync(state);
 }
 
@@ -380,662 +314,18 @@ status_t AudioHardware::setParameters(const String8& keyValuePairs)
         if (mBluetoothId == 0) {
             LOGI("Using default acoustic parameters "
                  "(%s not in acoustic database)", value.string());
-            doRouting(NULL);
-        }
-    }
-
-#ifdef HAVE_FM_RADIO
-    key = String8(AudioParameter::keyFmOn);
-    int devices;
-    if (param.getInt(key, devices) == NO_ERROR) {
-       setFmOnOff(true);
-    }
-    key = String8(AudioParameter::keyFmOff);
-    if (param.getInt(key, devices) == NO_ERROR) {
-       setFmOnOff(false);
-    }
-#endif
-
-    key = String8(DUALMIC_KEY);
-    if (param.get(key, value) == NO_ERROR) {
-        if (value == "true") {
-            mDualMicEnabled = true;
-            LOGI("DualMike feature Enabled");
-        } else {
-            mDualMicEnabled = false;
-            LOGI("DualMike feature Disabled");
-        }
-        doRouting(NULL);
-    }
-
-    key = String8(TTY_MODE_KEY);
-    if (param.get(key, value) == NO_ERROR) {
-        if (value == "full") {
-            mTtyMode = TTY_FULL;
-        } else if (value == "hco") {
-            mTtyMode = TTY_HCO;
-        } else if (value == "vco") {
-            mTtyMode = TTY_VCO;
-        } else {
-            mTtyMode = TTY_OFF;
+            doRouting();
         }
-    } else {
-	mTtyMode = TTY_OFF;
     }
-    doRouting(NULL);
-
     return NO_ERROR;
 }
 
 String8 AudioHardware::getParameters(const String8& keys)
 {
     AudioParameter param = AudioParameter(keys);
-    String8 value;
-
-    String8 key = String8(DUALMIC_KEY);
-
-    if (param.get(key, value) == NO_ERROR) {
-        value = String8(mDualMicEnabled ? "true" : "false");
-        param.add(key, value);
-    }
-
-    LOGV("AudioHardware::getParameters() %s", param.toString().string());
     return param.toString();
 }
 
-int check_and_set_audpp_parameters(char *buf, int size)
-{
-    char *p, *ps;
-    static const char *const seps = ",";
-    int table_num;
-    int i, j;
-    int device_id = 0;
-    int samp_index = 0;
-    eq_filter_type eq[12];
-    int fd;
-    void *audioeq;
-    void *(*eq_cal)(int32_t, int32_t, int32_t, uint16_t, int32_t, int32_t *, int32_t *, uint16_t *);
-    uint16_t numerator[6];
-    uint16_t denominator[4];
-    uint16_t shift[2];
-
-    if ((buf[0] == 'A') && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
-        /* IIR filter */
-        if(buf[1] == '1') device_id=0;
-        if(buf[1] == '2') device_id=1;
-        if(buf[1] == '3') device_id=2;
-        if (!(p = strtok(buf, ",")))
-            goto token_err;
-
-        /* Table header */
-        table_num = strtol(p + 1, &ps, 10);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        /* Table description */
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        for (i = 0; i < 48; i++) {
-            iir_cfg[device_id].iir_params[i] = (uint16_t)strtol(p, &ps, 16);
-            if (!(p = strtok(NULL, seps)))
-                goto token_err;
-        }
-        rx_iir_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        iir_cfg[device_id].num_bands = (uint16_t)strtol(p, &ps, 16);
-
-    } else if ((buf[0] == 'B') && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
-        /* This is the ADRC record we are looking for.  Tokenize it */
-        if(buf[1] == '1') device_id=0;
-        if(buf[1] == '2') device_id=1;
-        if(buf[1] == '3') device_id=2;
-        adrc_filter_exists[device_id] = true;
-        if (!(p = strtok(buf, ",")))
-            goto token_err;
-
-        /* Table header */
-        table_num = strtol(p + 1, &ps, 10);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        /* Table description */
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[0] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[1] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[2] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[3] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[4] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[5] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[6] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        adrc_cfg[device_id].adrc_params[7] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-    } else if (buf[0] == 'C' && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
-        /* This is the EQ record we are looking for.  Tokenize it */
-        if(buf[1] == '1') device_id=0;
-        if(buf[1] == '2') device_id=1;
-        if(buf[1] == '3') device_id=2;
-        if (!(p = strtok(buf, ",")))
-            goto token_err;
-
-        /* Table header */
-        table_num = strtol(p + 1, &ps, 10);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        /* Table description */
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        eq_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        LOGI("EQ flag = %02x.", eq_flag[device_id]);
-
-        audioeq = ::dlopen("/system/lib/libaudioeq.so", RTLD_NOW);
-        if (audioeq == NULL) {
-            LOGE("audioeq library open failure");
-            return -1;
-        }
-        eq_cal = (void *(*) (int32_t, int32_t, int32_t, uint16_t, int32_t, int32_t *, int32_t *, uint16_t *))::dlsym(audioeq, "audioeq_calccoefs");
-        memset(&eqalizer[device_id], 0, sizeof(eqalizer));
-        /* Temp add the bands here */
-        eqalizer[device_id].bands = 8;
-        for (i = 0; i < eqalizer[device_id].bands; i++) {
-
-            eq[i].gain = (uint16_t)strtol(p, &ps, 16);
-
-            if (!(p = strtok(NULL, seps)))
-                goto token_err;
-            eq[i].freq = (uint16_t)strtol(p, &ps, 16);
-
-            if (!(p = strtok(NULL, seps)))
-                goto token_err;
-            eq[i].type = (uint16_t)strtol(p, &ps, 16);
-
-            if (!(p = strtok(NULL, seps)))
-                goto token_err;
-            eq[i].qf = (uint16_t)strtol(p, &ps, 16);
-
-            if (!(p = strtok(NULL, seps)))
-                goto token_err;
-
-            eq_cal(eq[i].gain, eq[i].freq, 48000, eq[i].type, eq[i].qf, (int32_t*)numerator, (int32_t *)denominator, shift);
-            for (j = 0; j < 6; j++) {
-                eqalizer[device_id].params[ ( i * 6) + j] = numerator[j];
-            }
-            for (j = 0; j < 4; j++) {
-                eqalizer[device_id].params[(eqalizer[device_id].bands * 6) + (i * 4) + j] = denominator[j];
-            }
-            eqalizer[device_id].params[(eqalizer[device_id].bands * 10) + i] = shift[0];
-        }
-        ::dlclose(audioeq);
-
-    } else if ((buf[0] == 'D') && ((buf[1] == '1') || (buf[1] == '2') || (buf[1] == '3'))) {
-     /* This is the MB_ADRC record we are looking for.  Tokenize it */
-        if(buf[1] == '1') device_id=0;
-        if(buf[1] == '2') device_id=1;
-        if(buf[1] == '3') device_id=2;
-        mbadrc_filter_exists[device_id] = true;
-        if (!(p = strtok(buf, ",")))
-            goto token_err;
-          /* Table header */
-        table_num = strtol(p + 1, &ps, 10);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        /* Table description */
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        mbadrc_cfg[device_id].num_bands = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        mbadrc_cfg[device_id].down_samp_level = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        mbadrc_cfg[device_id].adrc_delay = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        mbadrc_cfg[device_id].ext_buf_size = (uint16_t)strtol(p, &ps, 16);
-        int ext_buf_count = mbadrc_cfg[device_id].ext_buf_size / 2;
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        mbadrc_cfg[device_id].ext_partition = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        mbadrc_cfg[device_id].ext_buf_msw = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        mbadrc_cfg[device_id].ext_buf_lsw = (uint16_t)strtol(p, &ps, 16);
-
-        for(i = 0;i < mbadrc_cfg[device_id].num_bands; i++) {
-            for(j = 0; j < 10; j++) {
-                if (!(p = strtok(NULL, seps)))
-                    goto token_err;
-                mbadrc_cfg[device_id].adrc_band[i].adrc_band_params[j] = (uint16_t)strtol(p, &ps, 16);
-            }
-        }
-
-        for(i = 0;i < mbadrc_cfg[device_id].ext_buf_size/2; i++) {
-            if (!(p = strtok(NULL, seps)))
-                goto token_err;
-            mbadrc_cfg[device_id].ext_buf.buff[i] = (uint16_t)strtol(p, &ps, 16);
-        }
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        mbadrc_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
-        LOGV("MBADRC flag = %02x.", mbadrc_flag[device_id]);
-    }else if ((buf[0] == 'E') || (buf[0] == 'F') || (buf[0] == 'G')){
-     //Pre-Processing Features TX_IIR,NS,AGC
-        switch (buf[1]) {
-                case '1':
-                        samp_index = 0;
-                        break;
-                case '2':
-                        samp_index = 1;
-                        break;
-                case '3':
-                        samp_index = 2;
-                        break;
-                case '4':
-                        samp_index = 3;
-                        break;
-                case '5':
-                        samp_index = 4;
-                        break;
-                case '6':
-                        samp_index = 5;
-                        break;
-                case '7':
-                        samp_index = 6;
-                        break;
-                case '8':
-                        samp_index = 7;
-                        break;
-                case '9':
-                        samp_index = 8;
-                        break;
-                default:
-                        return -EINVAL;
-                        break;
-        }
-
-        if (buf[0] == 'E')  {
-        /* TX_IIR filter */
-        if (!(p = strtok(buf, ","))){
-            goto token_err;}
-
-        /* Table header */
-        table_num = strtol(p + 1, &ps, 10);
-        if (!(p = strtok(NULL, seps))){
-            goto token_err;}
-        /* Table description */
-        if (!(p = strtok(NULL, seps))){
-            goto token_err;}
-
-        for (i = 0; i < 48; i++) {
-            j = (i >= 40)? i : ((i % 2)? (i - 1) : (i + 1));
-            tx_iir_cfg[samp_index].iir_params[j] = (uint16_t)strtol(p, &ps, 16);
-            if (!(p = strtok(NULL, seps))){
-                goto token_err;}
-        }
-
-        tx_iir_cfg[samp_index].active_flag = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps))){
-            goto token_err;}
-
-        txiir_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        tx_iir_cfg[samp_index].num_bands = (uint16_t)strtol(p, &ps, 16);
-
-        tx_iir_cfg[samp_index].cmd_id = 0;
-
-        LOGV("TX IIR flag = %02x.", txiir_flag[device_id]);
-        if (txiir_flag[device_id] != 0)
-             enable_preproc_mask |= TX_IIR_ENABLE;
-        } else if(buf[0] == 'F')  {
-        /* AGC filter */
-        if (!(p = strtok(buf, ",")))
-            goto token_err;
-
-        /* Table header */
-        table_num = strtol(p + 1, &ps, 10);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        /* Table description */
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        tx_agc_cfg[samp_index].cmd_id = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        tx_agc_cfg[samp_index].tx_agc_param_mask = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        tx_agc_cfg[samp_index].tx_agc_enable_flag = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        tx_agc_cfg[samp_index].static_gain = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        tx_agc_cfg[samp_index].adaptive_gain_flag = (uint16_t)strtol(p, &ps, 16);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        for (i = 0; i < 19; i++) {
-            tx_agc_cfg[samp_index].agc_params[i] = (uint16_t)strtol(p, &ps, 16);
-            if (!(p = strtok(NULL, seps)))
-                goto token_err;
-            }
-
-        agc_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
-        LOGV("AGC flag = %02x.", agc_flag[device_id]);
-        if (agc_flag[device_id != 0])
-            enable_preproc_mask |= AGC_ENABLE;
-        } else if ((buf[0] == 'G')) {
-        /* This is the NS record we are looking for.  Tokenize it */
-        if (!(p = strtok(buf, ",")))
-            goto token_err;
-
-        /* Table header */
-        table_num = strtol(p + 1, &ps, 10);
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-
-        /* Table description */
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].cmd_id = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].ec_mode_new = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].dens_gamma_n = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].dens_nfe_block_size = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].dens_limit_ns = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].dens_limit_ns_d = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].wb_gamma_e = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_cfg[samp_index].wb_gamma_n = (uint16_t)strtol(p, &ps, 16);
-
-        if (!(p = strtok(NULL, seps)))
-            goto token_err;
-        ns_flag[device_id] = (uint16_t)strtol(p, &ps, 16);
-
-        LOGV("NS flag = %02x.", ns_flag[device_id]);
-        if (ns_flag[device_id] != 0)
-            enable_preproc_mask |= NS_ENABLE;
-        }
-    }
-    return 0;
-
-token_err:
-    LOGE("malformatted pcm control buffer");
-    return -EINVAL;
-}
-
-static int get_audpp_filter(void)
-{
-    struct stat st;
-    char *read_buf;
-    char *next_str, *current_str;
-    int csvfd;
-
-    LOGI("get_audpp_filter");
-    static const char *const path =
-        "/system/etc/AudioFilter.csv";
-    csvfd = open(path, O_RDONLY);
-    if (csvfd < 0) {
-        /* failed to open normal acoustic file ... */
-        LOGE("failed to open AUDIO_NORMAL_FILTER %s: %s (%d).",
-             path, strerror(errno), errno);
-        return -1;
-    } else LOGI("open %s success.", path);
-
-    if (fstat(csvfd, &st) < 0) {
-        LOGE("failed to stat %s: %s (%d).",
-             path, strerror(errno), errno);
-        close(csvfd);
-        return -1;
-    }
-
-    read_buf = (char *) mmap(0, st.st_size,
-                    PROT_READ | PROT_WRITE,
-                    MAP_PRIVATE,
-                    csvfd, 0);
-
-    if (read_buf == MAP_FAILED) {
-        LOGE("failed to mmap parameters file: %s (%d)",
-             strerror(errno), errno);
-        close(csvfd);
-        return -1;
-    }
-
-    current_str = read_buf;
-
-    while (1) {
-        int len;
-        next_str = strchr(current_str, '\n');
-        if (!next_str)
-           break;
-        len = next_str - current_str;
-        *next_str++ = '\0';
-        if (check_and_set_audpp_parameters(current_str, len)) {
-            LOGI("failed to set audpp parameters, exiting.");
-            munmap(read_buf, st.st_size);
-            close(csvfd);
-            return -1;
-        }
-        current_str = next_str;
-    }
-
-    munmap(read_buf, st.st_size);
-    close(csvfd);
-    return 0;
-}
-
-static int msm72xx_enable_postproc(bool state)
-{
-    int fd;
-    int device_id=0;
-
-    if (!audpp_filter_inited)
-    {
-        LOGE("Parsing error in AudioFilter.csv.");
-        return -EINVAL;
-    }
-    if(snd_device < 0) {
-        LOGE("Enabling/Disabling post proc features for device: %d", snd_device);
-        return -EINVAL;
-    }
-
-    if(snd_device == SND_DEVICE_SPEAKER)
-    {
-        device_id = 0;
-        LOGI("set device to SND_DEVICE_SPEAKER device_id=0");
-    }
-    if(snd_device == SND_DEVICE_HANDSET)
-    {
-        device_id = 1;
-        LOGI("set device to SND_DEVICE_HANDSET device_id=1");
-    }
-    if(snd_device == SND_DEVICE_HEADSET)
-    {
-        device_id = 2;
-        LOGI("set device to SND_DEVICE_HEADSET device_id=2");
-    }
-
-    fd = open(PCM_CTL_DEVICE, O_RDWR);
-    if (fd < 0) {
-        LOGE("Cannot open PCM Ctl device");
-        return -EPERM;
-    }
-
-    if(mbadrc_filter_exists[device_id] && state)
-    {
-        LOGV("MBADRC Enabled");
-        post_proc_feature_mask &= ADRC_DISABLE;
-        if ((mbadrc_flag[device_id] == 0) && (post_proc_feature_mask & MBADRC_ENABLE))
-        {
-            LOGV("MBADRC Disable");
-            post_proc_feature_mask &= MBADRC_DISABLE;
-        }
-        else if(post_proc_feature_mask & MBADRC_ENABLE)
-        {
-            LOGV("MBADRC Enabled %d", post_proc_feature_mask);
-
-            if (ioctl(fd, AUDIO_SET_MBADRC, &mbadrc_cfg[device_id]) < 0)
-            {
-                LOGE("set mbadrc filter error");
-            }
-        }
-    }
-    else if (adrc_filter_exists[device_id] && state)
-    {
-        post_proc_feature_mask &= MBADRC_DISABLE;
-        LOGV("ADRC Enabled %d", post_proc_feature_mask);
-
-        if (adrc_flag[device_id] == 0 && (post_proc_feature_mask & ADRC_ENABLE))
-            post_proc_feature_mask &= ADRC_DISABLE;
-        else if(post_proc_feature_mask & ADRC_ENABLE)
-        {
-            LOGI("ADRC Filter ADRC FLAG = %02x.", adrc_flag[device_id]);
-            LOGI("ADRC Filter COMP THRESHOLD = %02x.", adrc_cfg[device_id].adrc_params[0]);
-            LOGI("ADRC Filter COMP SLOPE = %02x.", adrc_cfg[device_id].adrc_params[1]);
-            LOGI("ADRC Filter COMP RMS TIME = %02x.", adrc_cfg[device_id].adrc_params[2]);
-            LOGI("ADRC Filter COMP ATTACK[0] = %02x.", adrc_cfg[device_id].adrc_params[3]);
-            LOGI("ADRC Filter COMP ATTACK[1] = %02x.", adrc_cfg[device_id].adrc_params[4]);
-            LOGI("ADRC Filter COMP RELEASE[0] = %02x.", adrc_cfg[device_id].adrc_params[5]);
-            LOGI("ADRC Filter COMP RELEASE[1] = %02x.", adrc_cfg[device_id].adrc_params[6]);
-            LOGI("ADRC Filter COMP DELAY = %02x.", adrc_cfg[device_id].adrc_params[7]);
-            if (ioctl(fd, AUDIO_SET_ADRC, &adrc_cfg[device_id]) < 0)
-            {
-                LOGE("set adrc filter error.");
-            }
-        }
-    }
-    else
-    {
-        LOGV("MBADRC and ADRC Disabled");
-        post_proc_feature_mask &= (MBADRC_DISABLE | ADRC_DISABLE);
-    }
-
-    if (eq_flag[device_id] == 0 && (post_proc_feature_mask & EQ_ENABLE))
-        post_proc_feature_mask &= EQ_DISABLE;
-    else if ((post_proc_feature_mask & EQ_ENABLE) && state)
-    {
-        LOGI("Setting EQ Filter");
-        if (ioctl(fd, AUDIO_SET_EQ, &eqalizer[device_id]) < 0) {
-            LOGE("set Equalizer error.");
-        }
-    }
-
-    if (rx_iir_flag[device_id] == 0 && (post_proc_feature_mask & RX_IIR_ENABLE))
-        post_proc_feature_mask &= RX_IIR_DISABLE;
-    else if ((post_proc_feature_mask & RX_IIR_ENABLE)&& state)
-    {
-        LOGI("IIR Filter FLAG = %02x.", rx_iir_flag[device_id]);
-        LOGI("IIR NUMBER OF BANDS = %02x.", iir_cfg[device_id].num_bands);
-        LOGI("IIR Filter N1 = %02x.", iir_cfg[device_id].iir_params[0]);
-        LOGI("IIR Filter N2 = %02x.",  iir_cfg[device_id].iir_params[1]);
-        LOGI("IIR Filter N3 = %02x.",  iir_cfg[device_id].iir_params[2]);
-        LOGI("IIR Filter N4 = %02x.",  iir_cfg[device_id].iir_params[3]);
-        LOGI("IIR FILTER M1 = %02x.",  iir_cfg[device_id].iir_params[24]);
-        LOGI("IIR FILTER M2 = %02x.", iir_cfg[device_id].iir_params[25]);
-        LOGI("IIR FILTER M3 = %02x.",  iir_cfg[device_id].iir_params[26]);
-        LOGI("IIR FILTER M4 = %02x.",  iir_cfg[device_id].iir_params[27]);
-        LOGI("IIR FILTER M16 = %02x.",  iir_cfg[device_id].iir_params[39]);
-        LOGI("IIR FILTER SF1 = %02x.",  iir_cfg[device_id].iir_params[40]);
-         if (ioctl(fd, AUDIO_SET_RX_IIR, &iir_cfg[device_id]) < 0)
-        {
-            LOGE("set rx iir filter error.");
-        }
-    }
-
-    if(state){
-        LOGI("Enabling post proc features with mask 0x%04x", post_proc_feature_mask);
-        if (ioctl(fd, AUDIO_ENABLE_AUDPP, &post_proc_feature_mask) < 0) {
-            LOGE("enable audpp error");
-            close(fd);
-            return -EPERM;
-        }
-    } else{
-        int disable_mask = 0;
-
-        if(post_proc_feature_mask & MBADRC_ENABLE) disable_mask |= MBADRC_DISABLE;
-        if(post_proc_feature_mask & ADRC_ENABLE) disable_mask |= ADRC_DISABLE;
-        if(post_proc_feature_mask & EQ_ENABLE) disable_mask |= EQ_DISABLE;
-        if(post_proc_feature_mask & RX_IIR_ENABLE) disable_mask |= RX_IIR_DISABLE;
-
-        LOGI("disabling post proc features with mask 0x%04x", post_proc_feature_mask);
-        if (ioctl(fd, AUDIO_ENABLE_AUDPP, &disable_mask) < 0) {
-            LOGE("enable audpp error");
-            close(fd);
-            return -EPERM;
-        }
-   }
-
-   close(fd);
-   return 0;
-}
 
 static unsigned calculate_audpre_table_index(unsigned index)
 {
@@ -1054,10 +344,8 @@ static unsigned calculate_audpre_table_index(unsigned index)
 }
 size_t AudioHardware::getInputBufferSize(uint32_t sampleRate, int format, int channelCount)
 {
-    if ( (format != AudioSystem::PCM_16_BIT) &&
-         (format != AudioSystem::AMR_NB)     &&
-         (format != AudioSystem::AAC)){
-        LOGW("getInputBufferSize bad format: 0x%x", format);
+    if (format != AudioSystem::PCM_16_BIT) {
+        LOGW("getInputBufferSize bad format: %d", format);
         return 0;
     }
     if (channelCount < 1 || channelCount > 2) {
@@ -1065,26 +353,22 @@ size_t AudioHardware::getInputBufferSize(uint32_t sampleRate, int format, int ch
         return 0;
     }
 
-    if(format == AudioSystem::AMR_NB)
-       return 320*channelCount;
-    else if (format == AudioSystem::AAC)
-       return 2048;
-    else
-       return 2048*channelCount;
+    return 2048*channelCount;
 }
 
 static status_t set_volume_rpc(uint32_t device,
                                uint32_t method,
-                               uint32_t volume,
-                               int m7xsnddriverfd)
+                               uint32_t volume)
 {
+    int fd;
 #if LOG_SND_RPC
     LOGD("rpc_snd_set_volume(%d, %d, %d)\n", device, method, volume);
 #endif
 
     if (device == -1UL) return NO_ERROR;
 
-    if (m7xsnddriverfd < 0) {
+    fd = open("/dev/msm_snd", O_RDWR);
+    if (fd < 0) {
         LOGE("Can not open snd device");
         return -EPERM;
     }
@@ -1102,10 +386,12 @@ static status_t set_volume_rpc(uint32_t device,
      args.method = method;
      args.volume = volume;
 
-     if (ioctl(m7xsnddriverfd, SND_SET_VOLUME, &args) < 0) {
+     if (ioctl(fd, SND_SET_VOLUME, &args) < 0) {
          LOGE("snd_set_volume error.");
+         close(fd);
          return -EIO;
      }
+     close(fd);
      return NO_ERROR;
 }
 
@@ -1119,75 +405,45 @@ status_t AudioHardware::setVoiceVolume(float v)
         v = 1.0;
     }
 
-    int vol = lrint(v * 7.0);
+    int vol = lrint(v * 5.0);
     LOGD("setVoiceVolume(%f)\n", v);
-    LOGI("Setting in-call volume to %d (available range is 0 to 7)\n", vol);
-
-    if ((mCurSndDevice != -1) && ((mCurSndDevice == SND_DEVICE_TTY_HEADSET) || (mCurSndDevice == SND_DEVICE_TTY_VCO)))
-    {
-        vol = 1;
-        LOGI("For TTY device in FULL or VCO mode, the volume level is set to: %d \n", vol);
-    }
+    LOGI("Setting in-call volume to %d (available range is 0 to 5)\n", vol);
 
-    //Mutex::Autolock lock(mLock);
-	android::Mutex::Autolock lock(mLock);
-    set_volume_rpc(SND_DEVICE_CURRENT, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    android::Mutex::Autolock lock(mLock);
+    set_volume_rpc(SND_DEVICE_CURRENT, SND_METHOD_VOICE, vol);
     return NO_ERROR;
 }
 
 status_t AudioHardware::setMasterVolume(float v)
 {
-    //Mutex::Autolock lock(mLock);
-	android::Mutex::Autolock lock(mLock);
-    int vol = ceil(v * 7.0);
+    android::Mutex::Autolock lock(mLock);
+    int vol = ceil(v * 5.0);
     LOGI("Set master volume to %d.\n", vol);
-    set_volume_rpc(SND_DEVICE_HANDSET, SND_METHOD_VOICE, vol, m7xsnddriverfd);
-    set_volume_rpc(SND_DEVICE_SPEAKER, SND_METHOD_VOICE, vol, m7xsnddriverfd);
-    set_volume_rpc(SND_DEVICE_BT,      SND_METHOD_VOICE, vol, m7xsnddriverfd);
-    set_volume_rpc(SND_DEVICE_HEADSET, SND_METHOD_VOICE, vol, m7xsnddriverfd);
-    set_volume_rpc(SND_DEVICE_IN_S_SADC_OUT_HANDSET, SND_METHOD_VOICE, vol, m7xsnddriverfd);
-    set_volume_rpc(SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE, SND_METHOD_VOICE, vol, m7xsnddriverfd);
+    /*
+    set_volume_rpc(SND_DEVICE_HANDSET, SND_METHOD_VOICE, vol);
+    set_volume_rpc(SND_DEVICE_SPEAKER, SND_METHOD_VOICE, vol);
+    set_volume_rpc(SND_DEVICE_BT,      SND_METHOD_VOICE, vol);
+    set_volume_rpc(SND_DEVICE_HEADSET, SND_METHOD_VOICE, vol);
+    */
     // We return an error code here to let the audioflinger do in-software
     // volume on top of the maximum volume that we set through the SND API.
     // return error - software mixer will handle it
     return -1;
 }
 
-#ifdef HAVE_FM_RADIO
-status_t AudioHardware::setFmOnOff(int onoff)
-{
-    int ret;
-
-    if (onoff) {
-	if(fmfd < 0)
-	    fmfd = open("/dev/si4708", O_RDWR);
-        mFmRadioEnabled = true;
-	LOGV("mFmVolume=%i",mFmVolume);
-	if (ioctl(fmfd, Si4708_IOC_SET_VOL, &mFmVolume) < 0) {
-	    LOGE("set_volume_fm error.");
-            return -EIO;
-        }
-    } else {
-        close(fmfd);
-        fmfd = -1;
-        mFmRadioEnabled = false;
-    }
-    LOGV("mFmRadioEnabled=%d", mFmRadioEnabled);
-    return doRouting(NULL);
-}
-#endif
-
 static status_t do_route_audio_rpc(uint32_t device,
-                                   bool ear_mute, bool mic_mute, int m7xsnddriverfd)
+                                   bool ear_mute, bool mic_mute)
 {
     if (device == -1UL)
         return NO_ERROR;
 
+    int fd;
 #if LOG_SND_RPC
     LOGD("rpc_snd_set_device(%d, %d, %d)\n", device, ear_mute, mic_mute);
 #endif
 
-    if (m7xsnddriverfd < 0) {
+    fd = open("/dev/msm_snd", O_RDWR);
+    if (fd < 0) {
         LOGE("Can not open snd device");
         return -EPERM;
     }
@@ -1204,28 +460,21 @@ static status_t do_route_audio_rpc(uint32_t device,
     struct msm_snd_device_config args;
     args.device = device;
     args.ear_mute = ear_mute ? SND_MUTE_MUTED : SND_MUTE_UNMUTED;
-    if((device != SND_DEVICE_CURRENT) && (!mic_mute)) {
-        //Explicitly mute the mic to release DSP resources
-        args.mic_mute = SND_MUTE_MUTED;
-        if (ioctl(m7xsnddriverfd, SND_SET_DEVICE, &args) < 0) {
-            LOGE("snd_set_device error.");
-            return -EIO;
-        }
-    }
     args.mic_mute = mic_mute ? SND_MUTE_MUTED : SND_MUTE_UNMUTED;
 
-    if (ioctl(m7xsnddriverfd, SND_SET_DEVICE, &args) < 0) {
+    if (ioctl(fd, SND_SET_DEVICE, &args) < 0) {
         LOGE("snd_set_device error.");
+        close(fd);
         return -EIO;
     }
 
+    close(fd);
     return NO_ERROR;
 }
 
 // always call with mutex held
 status_t AudioHardware::doAudioRouteOrMute(uint32_t device)
 {
-#if 0
     if (device == (uint32_t)SND_DEVICE_BT || device == (uint32_t)SND_DEVICE_CARKIT) {
         if (mBluetoothId) {
             device = mBluetoothId;
@@ -1233,77 +482,56 @@ status_t AudioHardware::doAudioRouteOrMute(uint32_t device)
             device = SND_DEVICE_BT_EC_OFF;
         }
     }
-#endif
-    /* QCOM caveat: Audio will be routed to speaker if device=handset and mute=true */
-    /* Also, the audio circuit causes battery drain unless mute=true */
-    /* Android < 2.0 uses MODE_IN_CALL for routing audio to earpiece */
-    /* Android >= 2.0 advises to use STREAM_VOICE_CALL streams and setSpeakerphoneOn() */
-    /* Android >= 2.3 uses MODE_IN_COMMUNICATION for SIP calls */
-    bool mute = !isInCall();
-    if(mute && (device == SND_DEVICE_HANDSET)) {
-        /* workaround to emulate Android >= 2.0 behaviour */
-        /* enable routing to earpiece (unmute) if mic is selected as input */
-        mute = !mBuiltinMicSelected;
-    }
-
-    mFmPrev=mFmRadioEnabled;
-#ifdef HAVE_FM_RADIO
-    if(mFmRadioEnabled && (device == SND_DEVICE_HEADSET)) {
-      mute = 0;
-      LOGI("unmute for radio");
-    }
-#endif
-    LOGD("doAudioRouteOrMute() device %x, mMode %d, mMicMute %d, mBuiltinMicSelected %d, %s",
-        device, mMode, mMicMute, mBuiltinMicSelected, mute ? "muted" : "audio circuit active");
-    return do_route_audio_rpc(device, mute, mMicMute, m7xsnddriverfd);
-
+    LOGV("doAudioRouteOrMute() device %x, mMode %d, mMicMute %d", device, mMode, mMicMute);
+    return do_route_audio_rpc(device,
+                              mMode != AudioSystem::MODE_IN_CALL, mMicMute);
 }
 
-status_t AudioHardware::doRouting(AudioStreamInMSM72xx *input)
+status_t AudioHardware::doRouting()
 {
     /* currently this code doesn't work without the htc libacoustic */
+    if (!acoustic)
+        return 0;
 
-    //Mutex::Autolock lock(mLock);
-	android::Mutex::Autolock lock(mLock);
+    android::Mutex::Autolock lock(mLock);
     uint32_t outputDevices = mOutput->devices();
     status_t ret = NO_ERROR;
-    int new_snd_device = -1;
-    int new_post_proc_feature_mask = 0;
-
-    //int (*msm72xx_enable_audpp)(int);
-    //msm72xx_enable_audpp = (int (*)(int))::dlsym(acoustic, "msm72xx_enable_audpp");
-
-    if (input != NULL) {
-        uint32_t inputDevice = input->devices();
+    int (*msm72xx_enable_audpp)(int);
+    msm72xx_enable_audpp = (int (*)(int))::dlsym(acoustic, "msm72xx_enable_audpp");
+    int audProcess = (ADRC_DISABLE | EQ_DISABLE | RX_IIR_DISABLE);
+    AudioStreamInMSM72xx *input = getActiveInput_l();
+    uint32_t inputDevice = (input == NULL) ? 0 : input->devices();
+    int sndDevice = -1;
+
+    if (inputDevice != 0) {
         LOGI("do input routing device %x\n", inputDevice);
-        mBuiltinMicSelected = (inputDevice == AudioSystem::DEVICE_IN_BUILTIN_MIC);
-        // ignore routing device information when we start a recording in voice
-        // call
-        // Recording will happen through currently active tx device
-        if(inputDevice == AudioSystem::DEVICE_IN_VOICE_CALL)
-            return NO_ERROR;
-        if (inputDevice != 0) {
-            if (inputDevice & AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET) {
-                LOGI("Routing audio to Bluetooth PCM\n");
-                new_snd_device = SND_DEVICE_BT;
-            } else if (inputDevice & AudioSystem::DEVICE_IN_WIRED_HEADSET) {
-                    LOGI("Routing audio to Wired Headset\n");
-                    new_snd_device = SND_DEVICE_HEADSET;
+        if (inputDevice & AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET) {
+            LOGI("Routing audio to Bluetooth PCM\n");
+            sndDevice = SND_DEVICE_BT;
+        } else if (inputDevice & AudioSystem::DEVICE_IN_WIRED_HEADSET) {
+            if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) &&
+                (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER)) {
+                LOGI("Routing audio to Wired Headset and Speaker\n");
+                sndDevice = SND_DEVICE_HEADSET_AND_SPEAKER;
+                audProcess = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE);
+            } else {
+                LOGI("Routing audio to Wired Headset\n");
+                sndDevice = SND_DEVICE_HEADSET;
+            }
+        } else {
+            if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
+                LOGI("Routing audio to Speakerphone\n");
+                sndDevice = SND_DEVICE_SPEAKER;
+                audProcess = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE);
             } else {
-                if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
-                    LOGI("Routing audio to Speakerphone\n");
-                    new_snd_device = SND_DEVICE_SPEAKER;
-                    new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
-                } else {
-                    LOGI("Routing audio to Handset\n");
-                    new_snd_device = SND_DEVICE_HANDSET;
-                }
+                LOGI("Routing audio to Handset\n");
+                sndDevice = SND_DEVICE_HANDSET;
             }
         }
     }
-
     // if inputDevice == 0, restore output routing
-    if (new_snd_device == -1) {
+
+    if (sndDevice == -1) {
         if (outputDevices & (outputDevices - 1)) {
             if ((outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) == 0) {
                 LOGW("Hardware does not support requested route combination (%#X),"
@@ -1311,81 +539,48 @@ status_t AudioHardware::doRouting(AudioStreamInMSM72xx *input)
             }
         }
 
-        if ((mTtyMode != TTY_OFF) && (mMode == AudioSystem::MODE_IN_CALL) &&
-                (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET)) {
-            if (mTtyMode == TTY_FULL) {
-                LOGI("Routing audio to TTY FULL Mode\n");
-                new_snd_device = SND_DEVICE_TTY_HEADSET;
-            } else if (mTtyMode == TTY_VCO) {
-                LOGI("Routing audio to TTY VCO Mode\n");
-                new_snd_device = SND_DEVICE_TTY_VCO;
-            } else if (mTtyMode == TTY_HCO) {
-                LOGI("Routing audio to TTY HCO Mode\n");
-                new_snd_device = SND_DEVICE_TTY_HCO;
-            }
-        } else if (outputDevices &
-                   (AudioSystem::DEVICE_OUT_BLUETOOTH_SCO | AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET)) {
+        if (outputDevices &
+            (AudioSystem::DEVICE_OUT_BLUETOOTH_SCO | AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET)) {
             LOGI("Routing audio to Bluetooth PCM\n");
-            new_snd_device = SND_DEVICE_BT;
+            sndDevice = SND_DEVICE_BT;
         } else if (outputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT) {
             LOGI("Routing audio to Bluetooth PCM\n");
-            new_snd_device = SND_DEVICE_CARKIT;
-#ifdef COMBO_DEVICE_SUPPORTED
+            sndDevice = SND_DEVICE_CARKIT;
         } else if ((outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) &&
                    (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER)) {
             LOGI("Routing audio to Wired Headset and Speaker\n");
-            new_snd_device = SND_DEVICE_HEADSET_AND_SPEAKER;
-            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+            sndDevice = SND_DEVICE_HEADSET_AND_SPEAKER;
+            audProcess = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE);
         } else if (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE) {
             if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
                 LOGI("Routing audio to No microphone Wired Headset and Speaker (%d,%x)\n", mMode, outputDevices);
-                new_snd_device = SND_DEVICE_HEADSET_AND_SPEAKER;
-                new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+                sndDevice = SND_DEVICE_HEADSET_AND_SPEAKER;
+                audProcess = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE);
             } else {
                 LOGI("Routing audio to No microphone Wired Headset (%d,%x)\n", mMode, outputDevices);
-                new_snd_device = SND_DEVICE_NO_MIC_HEADSET;
+                sndDevice = SND_DEVICE_NO_MIC_HEADSET;
             }
-#endif
         } else if (outputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) {
             LOGI("Routing audio to Wired Headset\n");
-            new_snd_device = SND_DEVICE_HEADSET;
-            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+            sndDevice = SND_DEVICE_HEADSET;
         } else if (outputDevices & AudioSystem::DEVICE_OUT_SPEAKER) {
             LOGI("Routing audio to Speakerphone\n");
-            new_snd_device = SND_DEVICE_SPEAKER;
-            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+            sndDevice = SND_DEVICE_SPEAKER;
+            audProcess = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE);
         } else {
             LOGI("Routing audio to Handset\n");
-            new_snd_device = SND_DEVICE_HANDSET;
-            new_post_proc_feature_mask = (ADRC_ENABLE | EQ_ENABLE | RX_IIR_ENABLE | MBADRC_ENABLE);
+            sndDevice = SND_DEVICE_HANDSET;
         }
     }
 
-    if (mDualMicEnabled && mMode == AudioSystem::MODE_IN_CALL) {
-        if (new_snd_device == SND_DEVICE_HANDSET) {
-            LOGI("Routing audio to handset with DualMike enabled\n");
-            new_snd_device = SND_DEVICE_IN_S_SADC_OUT_HANDSET;
-        } else if (new_snd_device == SND_DEVICE_SPEAKER) {
-            LOGI("Routing audio to speakerphone with DualMike enabled\n");
-            new_snd_device = SND_DEVICE_IN_S_SADC_OUT_SPEAKER_PHONE;
+    if (sndDevice != -1 && sndDevice != mCurSndDevice) {
+        ret = doAudioRouteOrMute(sndDevice);
+        if ((*msm72xx_enable_audpp) == 0 ) {
+            LOGE("Could not open msm72xx_enable_audpp()");
+        } else {
+            msm72xx_enable_audpp(audProcess);
         }
-    }
-
-    if ((new_snd_device != -1 && new_snd_device != mCurSndDevice) || mFmRadioEnabled != mFmPrev) {
-        ret = doAudioRouteOrMute(new_snd_device);
-
-       //disable post proc first for previous session
-       if(playback_in_progress)
-           msm72xx_enable_postproc(false);
-
-       //enable post proc for new device
-       snd_device = new_snd_device;
-       post_proc_feature_mask = new_post_proc_feature_mask;
-
-       if(playback_in_progress)
-           msm72xx_enable_postproc(true);
-
-       mCurSndDevice = new_snd_device;
+        mCurSndDevice = sndDevice;
     }
 
     return ret;
@@ -1393,8 +588,7 @@ status_t AudioHardware::doRouting(AudioStreamInMSM72xx *input)
 
 status_t AudioHardware::checkMicMute()
 {
-    //Mutex::Autolock lock(mLock);
-	android::Mutex::Autolock lock(mLock);
+    android::Mutex::Autolock lock(mLock);
     if (mMode != AudioSystem::MODE_IN_CALL) {
         setMicMute_nosync(true);
     }
@@ -1537,7 +731,7 @@ ssize_t AudioHardware::AudioStreamOutMSM72xx::write(const void* buffer, size_t b
         config.sample_rate = sampleRate();
         config.buffer_size = bufferSize();
         config.buffer_count = AUDIO_HW_NUM_OUT_BUF;
-        config.type = CODEC_TYPE_PCM;
+        config.codec_type = CODEC_TYPE_PCM;
         status = ioctl(mFd, AUDIO_SET_CONFIG, &config);
         if (status < 0) {
             LOGE("Cannot set config");
@@ -1570,9 +764,6 @@ ssize_t AudioHardware::AudioStreamOutMSM72xx::write(const void* buffer, size_t b
     if (mStartCount) {
         if (--mStartCount == 0) {
             ioctl(mFd, AUDIO_START, 0);
-            playback_in_progress = true;
-            //enable post processing
-            msm72xx_enable_postproc(true);
         }
     }
     return bytes;
@@ -1592,9 +783,6 @@ status_t AudioHardware::AudioStreamOutMSM72xx::standby()
 {
     status_t status = NO_ERROR;
     if (!mStandby && mFd >= 0) {
-        //disable post processing
-        msm72xx_enable_postproc(false);
-        playback_in_progress = false;
         ::close(mFd);
         mFd = -1;
     }
@@ -1647,8 +835,7 @@ status_t AudioHardware::AudioStreamOutMSM72xx::setParameters(const String8& keyV
     if (param.getInt(key, device) == NO_ERROR) {
         mDevices = device;
         LOGV("set output routing %x", mDevices);
-	status = mHardware->setParameters(keyValuePairs);
-        status = mHardware->doRouting(NULL);
+        status = mHardware->doRouting();
         param.remove(key);
     }
 
@@ -1693,13 +880,8 @@ status_t AudioHardware::AudioStreamInMSM72xx::set(
         AudioHardware* hw, uint32_t devices, int *pFormat, uint32_t *pChannels, uint32_t *pRate,
         AudioSystem::audio_in_acoustics acoustic_flags)
 {
-    if ((pFormat == 0) ||
-        ((*pFormat != AUDIO_HW_IN_FORMAT) &&
-         (*pFormat != AudioSystem::AMR_NB) &&
-         (*pFormat != AudioSystem::AAC)))
-    {
+    if (pFormat == 0 || *pFormat != AUDIO_HW_IN_FORMAT) {
         *pFormat = AUDIO_HW_IN_FORMAT;
-        LOGE("audio format bad value");
         return BAD_VALUE;
     }
     if (pRate == 0) {
@@ -1711,8 +893,8 @@ status_t AudioHardware::AudioStreamInMSM72xx::set(
         return BAD_VALUE;
     }
 
-    if (pChannels == 0 || (*pChannels & (AudioSystem::CHANNEL_IN_MONO | AudioSystem::CHANNEL_IN_STEREO)) == 0)
-    {
+    if (pChannels == 0 || (*pChannels != AudioSystem::CHANNEL_IN_MONO &&
+        *pChannels != AudioSystem::CHANNEL_IN_STEREO)) {
         *pChannels = AUDIO_HW_IN_CHANNELS;
         return BAD_VALUE;
     }
@@ -1725,33 +907,29 @@ status_t AudioHardware::AudioStreamInMSM72xx::set(
         return -EPERM;
     }
 
-    struct msm_audio_config config;
-    struct msm_audio_voicememo_config gcfg;
-    memset(&gcfg,0,sizeof(gcfg));
-    status_t status = 0;
-    if(*pFormat == AUDIO_HW_IN_FORMAT)
-    {
     // open audio input device
-        status = ::open(PCM_IN_DEVICE, O_RDWR);
-        if (status < 0) {
-            LOGE("Cannot open %s errno: %d", PCM_IN_DEVICE, errno);
-            goto Error;
-        }
-        mFd = status;
+    status_t status = ::open("/dev/msm_pcm_in", O_RDWR);
+    if (status < 0) {
+        LOGE("Cannot open /dev/msm_pcm_in errno: %d", errno);
+        goto Error;
+    }
+    mFd = status;
 
-        // configuration
-        status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
-        if (status < 0) {
-            LOGE("Cannot read config");
-           goto Error;
-        }
+    // configuration
+    LOGV("get config");
+    struct msm_audio_config config;
+    status = ioctl(mFd, AUDIO_GET_CONFIG, &config);
+    if (status < 0) {
+        LOGE("Cannot read config");
+        goto Error;
+    }
 
     LOGV("set config");
     config.channel_count = AudioSystem::popCount(*pChannels);
     config.sample_rate = *pRate;
     config.buffer_size = bufferSize();
     config.buffer_count = 2;
-        config.type = CODEC_TYPE_PCM;
+    config.codec_type = CODEC_TYPE_PCM;
     status = ioctl(mFd, AUDIO_SET_CONFIG, &config);
     if (status < 0) {
         LOGE("Cannot set config");
@@ -1782,212 +960,32 @@ status_t AudioHardware::AudioStreamInMSM72xx::set(
     mChannels = *pChannels;
     mSampleRate = config.sample_rate;
     mBufferSize = config.buffer_size;
-    }
-    else if(*pFormat == AudioSystem::AMR_NB)
-      {
-
-      // open vocie memo input device
-      status = ::open(VOICE_MEMO_DEVICE, O_RDWR);
-      if (status < 0) {
-          LOGE("Cannot open Voice Memo device for read");
-          goto Error;
-      }
-      mFd = status;
-      /* Config param */
-      if(ioctl(mFd, AUDIO_GET_CONFIG, &config))
-      {
-        LOGE(" Error getting buf config param AUDIO_GET_CONFIG \n");
-        goto  Error;
-      }
-
-      LOGV("The Config buffer size is %d", config.buffer_size);
-      LOGV("The Config buffer count is %d", config.buffer_count);
-      LOGV("The Config Channel count is %d", config.channel_count);
-      LOGV("The Config Sample rate is %d", config.sample_rate);
-
-      mDevices = devices;
-      mChannels = *pChannels;
-      mSampleRate = config.sample_rate;
-
-      if (mDevices == AudioSystem::DEVICE_IN_VOICE_CALL)
-      {
-        if ((mChannels & AudioSystem::CHANNEL_IN_VOICE_DNLINK) &&
-            (mChannels & AudioSystem::CHANNEL_IN_VOICE_UPLINK)) {
-          LOGI("Recording Source: Voice Call Both Uplink and Downlink");
-          gcfg.rec_type = RPC_VOC_REC_BOTH;
-        } else if (mChannels & AudioSystem::CHANNEL_IN_VOICE_DNLINK) {
-          LOGI("Recording Source: Voice Call DownLink");
-          gcfg.rec_type = RPC_VOC_REC_FORWARD;
-        } else if (mChannels & AudioSystem::CHANNEL_IN_VOICE_UPLINK) {
-          LOGI("Recording Source: Voice Call UpLink");
-          gcfg.rec_type = RPC_VOC_REC_REVERSE;
-        }
-      }
-      else {
-        LOGI("Recording Source: Mic/Headset");
-        gcfg.rec_type = RPC_VOC_REC_REVERSE;
-      }
-
-      gcfg.rec_interval_ms = 0; // AV sync
-      gcfg.auto_stop_ms = 0;
-
-      switch (*pFormat)
-      {
-        case AudioSystem::AMR_NB:
-        {
-          LOGI("Recording Format: AMR_NB");
-          gcfg.capability = RPC_VOC_CAP_AMR; // RPC_VOC_CAP_AMR (64)
-          gcfg.max_rate = RPC_VOC_AMR_RATE_1220; // Max rate (Fixed frame)
-          gcfg.min_rate = RPC_VOC_AMR_RATE_1220; // Min rate (Fixed frame length)
-          gcfg.frame_format = RPC_VOC_PB_AMR; // RPC_VOC_PB_AMR
-          mFormat = AudioSystem::AMR_NB;
-          mBufferSize = 320;
-          break;
-        }
-
-
-        default:
-        break;
-      }
-
-      gcfg.dtx_enable = 0;
-      gcfg.data_req_ms = 20;
-
-      /* Set Via  config param */
-      if (ioctl(mFd, AUDIO_SET_VOICEMEMO_CONFIG, &gcfg))
-      {
-        LOGE("Error: AUDIO_SET_VOICEMEMO_CONFIG failed\n");
-        goto  Error;
-      }
-
-      if (ioctl(mFd, AUDIO_GET_VOICEMEMO_CONFIG, &gcfg))
-      {
-        LOGE("Error: AUDIO_GET_VOICEMEMO_CONFIG failed\n");
-        goto  Error;
-      }
-
-      LOGV("After set rec_type = 0x%8x\n",gcfg.rec_type);
-      LOGV("After set rec_interval_ms = 0x%8x\n",gcfg.rec_interval_ms);
-      LOGV("After set auto_stop_ms = 0x%8x\n",gcfg.auto_stop_ms);
-      LOGV("After set capability = 0x%8x\n",gcfg.capability);
-      LOGV("After set max_rate = 0x%8x\n",gcfg.max_rate);
-      LOGV("After set min_rate = 0x%8x\n",gcfg.min_rate);
-      LOGV("After set frame_format = 0x%8x\n",gcfg.frame_format);
-      LOGV("After set dtx_enable = 0x%8x\n",gcfg.dtx_enable);
-      LOGV("After set data_req_ms = 0x%8x\n",gcfg.data_req_ms);
-    }
-    else if(*pFormat == AudioSystem::AAC) {
-      // open AAC input device
-               status = ::open(PCM_IN_DEVICE, O_RDWR);
-               if (status < 0) {
-                     LOGE("Cannot open AAC input  device for read");
-                     goto Error;
-               }
-               mFd = status;
-
-      /* Config param */
-               if(ioctl(mFd, AUDIO_GET_CONFIG, &config))
-               {
-                     LOGE(" Error getting buf config param AUDIO_GET_CONFIG \n");
-                     goto  Error;
-               }
-
-      LOGV("The Config buffer size is %d", config.buffer_size);
-      LOGV("The Config buffer count is %d", config.buffer_count);
-      LOGV("The Config Channel count is %d", config.channel_count);
-      LOGV("The Config Sample rate is %d", config.sample_rate);
-
-      mDevices = devices;
-      mChannels = *pChannels;
-      mSampleRate = *pRate;
-      mBufferSize = 2048;
-      mFormat = *pFormat;
-
-      config.channel_count = AudioSystem::popCount(*pChannels);
-      config.sample_rate = *pRate;
-      config.type = 1; // Configuring PCM_IN_DEVICE to AAC format
-
-      if (ioctl(mFd, AUDIO_SET_CONFIG, &config)) {
-             LOGE(" Error in setting config of msm_pcm_in device \n");
-                   goto Error;
-        }
-    }
 
     //mHardware->setMicMute_nosync(false);
     mState = AUDIO_INPUT_OPENED;
 
-    //if (!acoustic)
-    //    return NO_ERROR;
-
-    if (audpp_filter_inited)
-    {
-        int fd;
-        audpre_index = calculate_audpre_table_index(mSampleRate);
-        if(audpre_index < 0) {
-             LOGE("wrong sampling rate");
-             goto Error;
-        }
-
-        fd = open(PREPROC_CTL_DEVICE, O_RDWR);
-        if (fd < 0) {
-             LOGE("Cannot open PreProc Ctl device");
-             return -EPERM;
-        }
-
-        if (enable_preproc_mask & AGC_ENABLE) {
-            /* Setting AGC Params */
-            LOGI("AGC Filter Param1= %02x.", tx_agc_cfg[audpre_index].cmd_id);
-            LOGI("AGC Filter Param2= %02x.", tx_agc_cfg[audpre_index].tx_agc_param_mask);
-            LOGI("AGC Filter Param3= %02x.", tx_agc_cfg[audpre_index].tx_agc_enable_flag);
-            LOGI("AGC Filter Param4= %02x.", tx_agc_cfg[audpre_index].static_gain);
-            LOGI("AGC Filter Param5= %02x.", tx_agc_cfg[audpre_index].adaptive_gain_flag);
-            LOGI("AGC Filter Param6= %02x.", tx_agc_cfg[audpre_index].agc_params[0]);
-            LOGI("AGC Filter Param7= %02x.", tx_agc_cfg[audpre_index].agc_params[18]);
-            if ((enable_preproc_mask & AGC_ENABLE) &&
-                (ioctl(fd, AUDIO_SET_AGC, &tx_agc_cfg[audpre_index]) < 0))
-            {
-                LOGE("set AGC filter error.");
-            }
-        }
+    if (!acoustic)
+        return NO_ERROR;
 
-        if (enable_preproc_mask & NS_ENABLE) {
-            /* Setting NS Params */
-            LOGI("NS Filter Param1= %02x.", ns_cfg[audpre_index].cmd_id);
-            LOGI("NS Filter Param2= %02x.", ns_cfg[audpre_index].ec_mode_new);
-            LOGI("NS Filter Param3= %02x.", ns_cfg[audpre_index].dens_gamma_n);
-            LOGI("NS Filter Param4= %02x.", ns_cfg[audpre_index].dens_nfe_block_size);
-            LOGI("NS Filter Param5= %02x.", ns_cfg[audpre_index].dens_limit_ns);
-            LOGI("NS Filter Param6= %02x.", ns_cfg[audpre_index].dens_limit_ns_d);
-            LOGI("NS Filter Param7= %02x.", ns_cfg[audpre_index].wb_gamma_e);
-            LOGI("NS Filter Param8= %02x.", ns_cfg[audpre_index].wb_gamma_n);
-            if ((enable_preproc_mask & NS_ENABLE) &&
-                (ioctl(fd, AUDIO_SET_NS, &ns_cfg[audpre_index]) < 0))
-            {
-                LOGE("set NS filter error.");
-            }
-        }
+    audpre_index = calculate_audpre_table_index(mSampleRate);
+    tx_iir_index = (audpre_index * 2) + (hw->checkOutputStandby() ? 0 : 1);
+    LOGD("audpre_index = %d, tx_iir_index = %d\n", audpre_index, tx_iir_index);
 
-        if (enable_preproc_mask & TX_IIR_ENABLE) {
-            /* Setting TX_IIR Params */
-            LOGI("TX_IIR Filter Param1= %02x.", tx_iir_cfg[audpre_index].cmd_id);
-            LOGI("TX_IIR Filter Param2= %02x.", tx_iir_cfg[audpre_index].active_flag);
-            LOGI("TX_IIR Filter Param3= %02x.", tx_iir_cfg[audpre_index].num_bands);
-            LOGI("TX_IIR Filter Param4= %02x.", tx_iir_cfg[audpre_index].iir_params[0]);
-            LOGI("TX_IIR Filter Param5= %02x.", tx_iir_cfg[audpre_index].iir_params[1]);
-            LOGI("TX_IIR Filter Param6 %02x.", tx_iir_cfg[audpre_index].iir_params[47]);
-            if ((enable_preproc_mask & TX_IIR_ENABLE) &&
-                (ioctl(fd, AUDIO_SET_TX_IIR, &tx_iir_cfg[audpre_index]) < 0))
-            {
-               LOGE("set TX IIR filter error.");
-            }
-        }
-        /*Setting AUDPRE_ENABLE*/
-        if (ioctl(fd, AUDIO_ENABLE_AUDPRE, &enable_preproc_mask) < 0)
-        {
-           LOGE("set AUDPRE_ENABLE error.");
-        }
-        close(fd);
-    }
+    /**
+     * If audio-preprocessing failed, we should not block record.
+     */
+    int (*msm72xx_set_audpre_params)(int, int);
+    msm72xx_set_audpre_params = (int (*)(int, int))::dlsym(acoustic, "msm72xx_set_audpre_params");
+    status = msm72xx_set_audpre_params(audpre_index, tx_iir_index);
+    if (status < 0)
+        LOGE("Cannot set audpre parameters");
+
+    int (*msm72xx_enable_audpre)(int, int, int);
+    msm72xx_enable_audpre = (int (*)(int, int, int))::dlsym(acoustic, "msm72xx_enable_audpre");
+    mAcoustics = acoustic_flags;
+    status = msm72xx_enable_audpre((int)acoustic_flags, audpre_index, tx_iir_index);
+    if (status < 0)
+        LOGE("Cannot enable audpre");
 
     return NO_ERROR;
 
@@ -2011,28 +1009,20 @@ ssize_t AudioHardware::AudioStreamInMSM72xx::read( void* buffer, ssize_t bytes)
     if (!mHardware) return -1;
 
     size_t count = bytes;
-    size_t  aac_framesize= bytes;
     uint8_t* p = static_cast<uint8_t*>(buffer);
-    uint32_t* recogPtr = (uint32_t *)p;
-    uint16_t* frameCountPtr;
-    uint16_t* frameSizePtr;
 
     if (mState < AUDIO_INPUT_OPENED) {
-        AudioHardware *hw = mHardware;
-        hw->mLock.lock();
-        status_t status = set(hw, mDevices, &mFormat, &mChannels, &mSampleRate, mAcoustics);
-        hw->mLock.unlock();
-        if (status != NO_ERROR) {
+        android::Mutex::Autolock lock(mHardware->mLock);
+        if (set(mHardware, mDevices, &mFormat, &mChannels, &mSampleRate, mAcoustics) != NO_ERROR) {
             return -1;
         }
-        mFirstread = false;
     }
 
     if (mState < AUDIO_INPUT_STARTED) {
         mState = AUDIO_INPUT_STARTED;
         // force routing to input device
         mHardware->clearCurDevice();
-        mHardware->doRouting(this);
+        mHardware->doRouting();
         if (ioctl(mFd, AUDIO_START, 0)) {
             LOGE("Error starting record");
             standby();
@@ -2040,59 +1030,17 @@ ssize_t AudioHardware::AudioStreamInMSM72xx::read( void* buffer, ssize_t bytes)
         }
     }
 
-    // Resetting the bytes value, to return the appropriate read value
-    bytes = 0;
-    if (mFormat == AudioSystem::AAC)
-    {
-        *((uint32_t*)recogPtr) = 0x51434F4D ;// ('Q','C','O', 'M') Number to identify format as AAC by higher layers
-        recogPtr++;
-        frameCountPtr = (uint16_t*)recogPtr;
-        *frameCountPtr = 0;
-        p += 3*sizeof(uint16_t);
-        count -= 3*sizeof(uint16_t);
-    }
-    while (count > 0) {
-
-        if (mFormat == AudioSystem::AAC) {
-            frameSizePtr = (uint16_t *)p;
-            p += sizeof(uint16_t);
-            if(!(count > 2)) break;
-            count -= sizeof(uint16_t);
-        }
-
-        ssize_t bytesRead = ::read(mFd, p, count);
-        if (bytesRead > 0) {
-            LOGV("Number of Bytes read = %d", bytesRead);
+    while (count) {
+        ssize_t bytesRead = ::read(mFd, buffer, count);
+        if (bytesRead >= 0) {
             count -= bytesRead;
             p += bytesRead;
-            bytes += bytesRead;
-            LOGV("Total Number of Bytes read = %d", bytes);
-
-            if (mFormat == AudioSystem::AAC){
-                *frameSizePtr =  bytesRead;
-                (*frameCountPtr)++;
-            }
-
-            if(!mFirstread)
-            {
-               mFirstread = true;
-               break;
-            }
-
-        }
-        else if(bytesRead == 0)
-        {
-         LOGI("Bytes Read = %d ,Buffer no longer sufficient",bytesRead);
-         break;
         } else {
             if (errno != EAGAIN) return bytesRead;
             mRetryCount++;
             LOGW("EAGAIN - retrying");
         }
     }
-    if (mFormat == AudioSystem::AAC)
-         return aac_framesize;
-
     return bytes;
 }
 
@@ -2108,7 +1056,7 @@ status_t AudioHardware::AudioStreamInMSM72xx::standby()
     if (!mHardware) return -1;
     // restore output routing if necessary
     mHardware->clearCurDevice();
-    mHardware->doRouting(this);
+    mHardware->doRouting();
     return NO_ERROR;
 }
 
@@ -2152,7 +1100,7 @@ status_t AudioHardware::AudioStreamInMSM72xx::setParameters(const String8& keyVa
             status = BAD_VALUE;
         } else {
             mDevices = device;
-            status = mHardware->doRouting(this);
+            status = mHardware->doRouting();
         }
         param.remove(key);
     }
@@ -2163,24 +1111,9 @@ status_t AudioHardware::AudioStreamInMSM72xx::setParameters(const String8& keyVa
     return status;
 }
 
-#ifdef HAVE_FM_RADIO
-
-status_t AudioHardware::setFmVolume(float v)
-{
-    mFmVolume = (AudioSystem::logToLinear(v) +5) / 7;
-    if(mFmRadioEnabled) {
-	if (ioctl(fmfd, Si4708_IOC_SET_VOL, &mFmVolume) < 0) {
-	    LOGE("set_volume_fm error.");
-            return -EIO;
-        }
-    }
-    return NO_ERROR;
-}
-#endif
-
 String8 AudioHardware::AudioStreamInMSM72xx::getParameters(const String8& keys)
 {
-    android::AudioParameter param = AudioParameter(keys);
+    AudioParameter param = AudioParameter(keys);
     String8 value;
     String8 key = String8(AudioParameter::keyRouting);
 
diff --git a/device/zte/blade/libaudio/AudioHardware.h b/device/zte/blade/libaudio/AudioHardware.h
index dcfd352..2b31d52 100644
--- a/device/zte/blade/libaudio/AudioHardware.h
+++ b/device/zte/blade/libaudio/AudioHardware.h
@@ -22,17 +22,13 @@
 
 #include <utils/threads.h>
 #include <utils/SortedVector.h>
-#include <utils/Log.h>
-#include <utils/String8.h>
 
 #include <hardware_legacy/AudioHardwareBase.h>
-#include <media/AudioRecord.h>
+
 extern "C" {
 #include "msm_audio.h"
-#include "msm_audio_voicememo.h"
 }
 
-//namespace android {
 namespace android_audio_legacy {
 
 // ----------------------------------------------------------------------------
@@ -55,14 +51,8 @@ namespace android_audio_legacy {
 #define ADRC_DISABLE 0x0000
 #define EQ_ENABLE    0x0002
 #define EQ_DISABLE   0x0000
-#define RX_IIR_ENABLE  0x0004
-#define RX_IIR_DISABLE 0x0000
-#define MBADRC_ENABLE  0x0010
-#define MBADRC_DISABLE 0x0000
-
-#define AGC_ENABLE     0x0001
-#define NS_ENABLE      0x0002
-#define TX_IIR_ENABLE  0x0004
+#define RX_IIR_ENABLE   0x0004
+#define RX_IIR_DISABLE  0x0000
 
 struct eq_filter_type {
     int16_t gain;
@@ -81,8 +71,13 @@ struct rx_iir_filter {
     uint16_t iir_params[48];
 };
 
-struct adrc_filter {
-    uint16_t adrc_params[8];
+struct msm_audio_config {
+    uint32_t buffer_size;
+    uint32_t buffer_count;
+    uint32_t channel_count;
+    uint32_t sample_rate;
+    uint32_t codec_type;
+    uint32_t unused[3];
 };
 
 struct msm_audio_stats {
@@ -90,60 +85,6 @@ struct msm_audio_stats {
     uint32_t unused[3];
 };
 
-struct tx_iir {
-        uint16_t  cmd_id;
-        uint16_t  active_flag;
-        uint16_t  num_bands;
-        uint16_t iir_params[48];
-};
-
-struct ns {
-        uint16_t  cmd_id;
-        uint16_t  ec_mode_new;
-        uint16_t  dens_gamma_n;
-        uint16_t  dens_nfe_block_size;
-        uint16_t  dens_limit_ns;
-        uint16_t  dens_limit_ns_d;
-        uint16_t  wb_gamma_e;
-        uint16_t  wb_gamma_n;
-};
-
-struct tx_agc {
-        uint16_t  cmd_id;
-        uint16_t  tx_agc_param_mask;
-        uint16_t  tx_agc_enable_flag;
-        uint16_t  static_gain;
-        int16_t   adaptive_gain_flag;
-        uint16_t  agc_params[19];
-};
-
-struct adrc_config {
-    uint16_t adrc_band_params[10];
-};
-
-struct adrc_ext_buf {
-    int16_t buff[196];
-};
-
-struct mbadrc_filter {
-    uint16_t num_bands;
-    uint16_t down_samp_level;
-    uint16_t adrc_delay;
-    uint16_t ext_buf_size;
-    uint16_t ext_partition;
-    uint16_t ext_buf_msw;
-    uint16_t ext_buf_lsw;
-    struct adrc_config adrc_band[5];
-    struct adrc_ext_buf  ext_buf;
-};
-
-enum tty_modes {
-    TTY_OFF = 0,
-    TTY_VCO = 1,
-    TTY_HCO = 2,
-    TTY_FULL = 3
-};
-
 #define CODEC_TYPE_PCM 0
 #define AUDIO_HW_NUM_OUT_BUF 2  // Number of buffers in audio driver for output
 // TODO: determine actual audio DSP and hardware latency
@@ -168,9 +109,7 @@ public:
 
     virtual status_t    setVoiceVolume(float volume);
     virtual status_t    setMasterVolume(float volume);
-#ifdef HAVE_FM_RADIO
-    virtual status_t    setFmVolume(float volume);
-#endif
+
     virtual status_t    setMode(int mode);
 
     // mic mute
@@ -214,10 +153,7 @@ private:
     status_t    dumpInternals(int fd, const Vector<String16>& args);
     uint32_t    getInputSampleRate(uint32_t sampleRate);
     bool        checkOutputStandby();
-    status_t    doRouting(AudioStreamInMSM72xx *input);
-#ifdef HAVE_FM_RADIO
-    status_t    setFmOnOff(int onoff);
-#endif
+    status_t    doRouting();
     AudioStreamInMSM72xx*   getActiveInput_l();
 
     class AudioStreamOutMSM72xx : public AudioStreamOut {
@@ -244,6 +180,8 @@ private:
         virtual String8     getParameters(const String8& keys);
                 uint32_t    devices() { return mDevices; }
         virtual status_t    getRenderPosition(uint32_t *dspFrames);
+        virtual status_t    addAudioEffect(effect_handle_t effect){return INVALID_OPERATION;}
+        virtual status_t    removeAudioEffect(effect_handle_t effect){return INVALID_OPERATION;}
 
     private:
                 AudioHardware* mHardware;
@@ -283,6 +221,8 @@ private:
         virtual unsigned int  getInputFramesLost() const { return 0; }
                 uint32_t    devices() { return mDevices; }
                 int         state() const { return mState; }
+        virtual status_t    addAudioEffect(effect_handle_t effect){return INVALID_OPERATION;}
+        virtual status_t    removeAudioEffect(effect_handle_t effect){return INVALID_OPERATION;}
 
     private:
                 AudioHardware* mHardware;
@@ -295,7 +235,6 @@ private:
                 size_t      mBufferSize;
                 AudioSystem::audio_in_acoustics mAcoustics;
                 uint32_t    mDevices;
-                bool        mFirstread;
     };
 
             static const uint32_t inputSamplingRates[];
@@ -304,25 +243,29 @@ private:
             bool        mBluetoothNrec;
             uint32_t    mBluetoothId;
             AudioStreamOutMSM72xx*  mOutput;
-            //SortedVector <AudioStreamInMSM72xx*>   mInputs;
-            android::SortedVector<AudioStreamInMSM72xx*>   mInputs;
+            android::SortedVector <AudioStreamInMSM72xx*>   mInputs;
 
             msm_snd_endpoint *mSndEndpoints;
             int mNumSndEndpoints;
             int mCurSndDevice;
-	    int mFmRadioEnabled;
-	    int mFmPrev;
-	    int mFmVolume;
-            int m7xsnddriverfd;
-            int fmfd;
-            bool        mDualMicEnabled;
-            int         mTtyMode;
-
-            bool        mBuiltinMicSelected;
 
      friend class AudioStreamInMSM72xx;
-            //Mutex       mLock;
-			android::Mutex       mLock;
+            android::Mutex       mLock;
+
+            int SND_DEVICE_CURRENT;
+            int SND_DEVICE_HANDSET;
+            int SND_DEVICE_SPEAKER;
+            int SND_DEVICE_HEADSET;
+            int SND_DEVICE_BT;
+            int SND_DEVICE_CARKIT;
+            int SND_DEVICE_TTY_FULL;
+            int SND_DEVICE_TTY_VCO;
+            int SND_DEVICE_TTY_HCO;
+            int SND_DEVICE_NO_MIC_HEADSET;
+            int SND_DEVICE_FM_HEADSET;
+            int SND_DEVICE_HEADSET_AND_SPEAKER;
+            int SND_DEVICE_FM_SPEAKER;
+            int SND_DEVICE_BT_EC_OFF;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/device/zte/blade/libaudio/AudioPolicyManager.cpp b/device/zte/blade/libaudio/AudioPolicyManager.cpp
index f9c3344..2662b5a 100644
--- a/device/zte/blade/libaudio/AudioPolicyManager.cpp
+++ b/device/zte/blade/libaudio/AudioPolicyManager.cpp
@@ -19,9 +19,7 @@
 #include <utils/Log.h>
 #include "AudioPolicyManager.h"
 #include <media/mediarecorder.h>
-#include <fcntl.h>
 
-//namespace android {
 namespace android_audio_legacy {
 
 
@@ -44,152 +42,4 @@ extern "C" void destroyAudioPolicyManager(AudioPolicyInterface *interface)
     delete interface;
 }
 
-uint32_t AudioPolicyManager::getDeviceForStrategy(routing_strategy strategy, bool fromCache)
-{
-    uint32_t device = 0;
-
-    if (fromCache) {
-        LOGV("getDeviceForStrategy() from cache strategy %d, device %x", strategy, mDeviceForStrategy[strategy]);
-        return mDeviceForStrategy[strategy];
-    }
-
-    switch (strategy) {
-    case STRATEGY_DTMF:
-        if (mPhoneState != AudioSystem::MODE_IN_CALL) {
-            // when off call, DTMF strategy follows the same rules as MEDIA strategy
-            device = getDeviceForStrategy(STRATEGY_MEDIA, false);
-            break;
-        }
-        // when in call, DTMF and PHONE strategies follow the same rules
-        // FALL THROUGH
-
-    case STRATEGY_PHONE:
-        // for phone strategy, we first consider the forced use and then the available devices by order
-        // of priority
-        switch (mForceUse[AudioSystem::FOR_COMMUNICATION]) {
-        case AudioSystem::FORCE_BT_SCO:
-            if (mPhoneState != AudioSystem::MODE_IN_CALL || strategy != STRATEGY_DTMF) {
-                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
-                if (device) break;
-            }
-            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
-            if (device) break;
-            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO;
-            if (device) break;
-            // if SCO device is requested but no SCO device is available, fall back to default case
-            // FALL THROUGH
-
-        default:    // FORCE_NONE
-            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE;
-            if (device) break;
-            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET;
-            if (device) break;
-#ifdef WITH_A2DP
-            // when not in a phone call, phone strategy should route STREAM_VOICE_CALL to A2DP
-            if (mPhoneState != AudioSystem::MODE_IN_CALL) {
-                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP;
-                if (device) break;
-                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
-                if (device) break;
-            }
-#endif
-            if (mPhoneState == AudioSystem::MODE_RINGTONE)
-                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
-            if (device) break;
-
-            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_EARPIECE;
-            if (device == 0) {
-                LOGE("getDeviceForStrategy() earpiece device not found");
-            }
-            break;
-
-        case AudioSystem::FORCE_SPEAKER:
-            if (mPhoneState != AudioSystem::MODE_IN_CALL || strategy != STRATEGY_DTMF) {
-                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
-                if (device) break;
-            }
-#ifdef WITH_A2DP
-            // when not in a phone call, phone strategy should route STREAM_VOICE_CALL to
-            // A2DP speaker when forcing to speaker output
-            if (mPhoneState != AudioSystem::MODE_IN_CALL) {
-                device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;
-                if (device) break;
-            }
-#endif
-            device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
-            if (device == 0) {
-                LOGE("getDeviceForStrategy() speaker device not found");
-            }
-            break;
-        }
-    break;
-
-    case STRATEGY_SONIFICATION:
-        device = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
-        if (device == 0) {
-            LOGE("getDeviceForStrategy() speaker device not found");
-        }
-        // The second device used for sonification is the same as the device used by media strategy
-        // FALL THROUGH
-
-    case STRATEGY_MEDIA_SONIFICATION:
-        // If incall, just select the STRATEGY_PHONE device: The rest of the behavior is handled by
-        // handleIncallSonification().
-        if (mPhoneState == AudioSystem::MODE_IN_CALL) {
-            device = getDeviceForStrategy(STRATEGY_PHONE, false);
-            break;
-        }
-
-    case STRATEGY_MEDIA: {
-        uint32_t device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_AUX_DIGITAL;
-#ifdef WITH_A2DP
-        if (mA2dpOutput != 0) {
-            if (strategy == STRATEGY_SONIFICATION && !a2dpUsedForSonification()) {
-                break;
-            }
-            if (device2 == 0) {
-                device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP;
-            }
-            if (device2 == 0) {
-                device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
-            }
-            if (device2 == 0) {
-                device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;
-            }
-        }
-#endif
-        if (device2 == 0) {
-            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE;
-        }
-        if (device2 == 0) {
-            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADSET;
-        }
-        if (device2 == 0) {
-            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
-        }
-        if (device2 == 0) {
-            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_EARPIECE;
-        }
-
-        // device is DEVICE_OUT_SPEAKER if we come from case STRATEGY_SONIFICATION, 0 otherwise
-        device |= device2;
-        // Do not play media stream if in call and the requested device would change the hardware
-        // output routing
-        if (mPhoneState == AudioSystem::MODE_IN_CALL &&
-            !AudioSystem::isA2dpDevice((AudioSystem::audio_devices)device) &&
-            device != getDeviceForStrategy(STRATEGY_PHONE)) {
-            device = 0;
-            LOGV("getDeviceForStrategy() incompatible media and phone devices");
-        }
-        } break;
-
-    default:
-        LOGW("getDeviceForStrategy() unknown strategy: %d", strategy);
-        break;
-    }
-
-    LOGV("getDeviceForStrategy() strategy %d, device %x", strategy, device);
-    return device;
-}
-
 }; // namespace android
diff --git a/device/zte/blade/libaudio/AudioPolicyManager.h b/device/zte/blade/libaudio/AudioPolicyManager.h
index 8b3af89..561e90b 100644
--- a/device/zte/blade/libaudio/AudioPolicyManager.h
+++ b/device/zte/blade/libaudio/AudioPolicyManager.h
@@ -23,8 +23,6 @@
 #include <hardware_legacy/AudioPolicyManagerBase.h>
 
 
-//namespace android {
-
 namespace android_audio_legacy {
 
 class AudioPolicyManager: public AudioPolicyManagerBase
@@ -36,7 +34,6 @@ public:
 
         virtual ~AudioPolicyManager() {}
 
-        virtual uint32_t getDeviceForStrategy(routing_strategy strategy, bool fromCache = true);
 protected:
         // true is current platform implements a back microphone
         virtual bool hasBackMicrophone() const { return false; }
diff --git a/device/zte/blade/libcamera/Android.mk b/device/zte/blade/libcamera/Android.mk
index 393ff22..d1376b5 100644
--- a/device/zte/blade/libcamera/Android.mk
+++ b/device/zte/blade/libcamera/Android.mk
@@ -1,38 +1,31 @@
-ifeq ($(TARGET_BOOTLOADER_BOARD_NAME),blade)
 
-# When zero we link against libmmcamera; when 1, we dlopen libmmcamera.
-DLOPEN_LIBMMCAMERA:=1
+BUILD_OLD_LIBCAMERA:=
+ifeq ($(BUILD_OLD_LIBCAMERA),true)
 
+# When zero we link against libqcamera; when 1, we dlopen libqcamera.
+DLOPEN_LIBQCAMERA:=1
+
+ifneq ($(BUILD_TINY_ANDROID),true)
 
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
-LOCAL_MODULE_TAGS := optional
 
-LOCAL_PRELINK_MODULE := false
+LOCAL_CFLAGS:=-fno-short-enums
+LOCAL_CFLAGS+=-DDLOPEN_LIBQCAMERA=$(DLOPEN_LIBQCAMERA)
 
 LOCAL_SRC_FILES:= QualcommCameraHardware.cpp
 
-LOCAL_CFLAGS:= -DDLOPEN_LIBMMCAMERA=$(DLOPEN_LIBMMCAMERA)
-
-## Can be raised to 6 to improve framerate, at the cost of allocating
-## more ADSP memory. Use 0xa68000 as pool size in kernel to test
-LOCAL_CFLAGS+= -DNUM_PREVIEW_BUFFERS=4 -D_ANDROID_
-
-LOCAL_C_INCLUDES+= \
-    $(TARGET_OUT_HEADERS)/mm-camera \
-    $(TARGET_OUT_HEADERS)/mm-still/jpeg \
-
-LOCAL_SHARED_LIBRARIES:= libutils libui libcamera_client liblog libcutils
-
-LOCAL_SHARED_LIBRARIES+= libbinder
-ifneq ($(DLOPEN_LIBMMCAMERA),1)
+LOCAL_SHARED_LIBRARIES:= libutils libbinder libui liblog libcamera_client
+ifneq ($(DLOPEN_LIBQCAMERA),1)
 LOCAL_SHARED_LIBRARIES+= liboemcamera
 else
 LOCAL_SHARED_LIBRARIES+= libdl
 endif
 
 LOCAL_MODULE:= libcamera
+LOCAL_MODULE_TAGS := optional
 include $(BUILD_SHARED_LIBRARY)
 
-endif
+endif # not BUILD_TINY_ANDROID
+endif # not BUILD_OLD_LIBCAMERA
diff --git a/device/zte/blade/libcamera/QualcommCameraHardware.cpp b/device/zte/blade/libcamera/QualcommCameraHardware.cpp
index 4b16b51..9dbc95c 100644
--- a/device/zte/blade/libcamera/QualcommCameraHardware.cpp
+++ b/device/zte/blade/libcamera/QualcommCameraHardware.cpp
@@ -1,4776 +1,2283 @@
 /*
-** Copyright 2008, Google Inc.
-** Copyright (c) 2009, Code Aurora Forum. All rights reserved.
-** Copyright (c) 2010, Ricardo Cerqueira
+** Copyright 2008, The Android Open-Source Project
 **
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
+** Licensed under the Apache License, Version 2.0 (the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
 **
-**     http://www.apache.org/licenses/LICENSE-2.0
+**     http://www.apache.org/licenses/LICENSE-2.0 
 **
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
+** Unless required by applicable law or agreed to in writing, software 
+** distributed under the License is distributed on an "AS IS" BASIS, 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+** See the License for the specific language governing permissions and 
 ** limitations under the License.
-**
-** NOTICE - (RC)
-**
-** All alterations done to this file to add support for the Z71 terminal
-** are intended for use with CyanogenMod. This includes all the support
-** for ov5642, and the reverse engineered bits like ioctls and EXIF.
-** Please do not change the EXIF header without asking me first.
 */
 
-//#define LOG_NDEBUG 0
-#define LOG_NIDEBUG 0
+// TODO
+// -- replace Condition::wait with Condition::waitRelative
+// -- use read/write locks
+
+#define LOG_NDEBUG 0
 #define LOG_TAG "QualcommCameraHardware"
 #include <utils/Log.h>
-
-#include "QualcommCameraHardware.h"
-
-#include <utils/Errors.h>
 #include <utils/threads.h>
 #include <binder/MemoryHeapPmem.h>
 #include <utils/String16.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <time.h>
 #include <fcntl.h>
-#include <cutils/properties.h>
-#include <math.h>
+#include <unistd.h>
 #if HAVE_ANDROID_OS
 #include <linux/android_pmem.h>
 #endif
-#include <linux/ioctl.h>
-#include <camera/CameraParameters.h>
-
-#include "linux/msm_mdp.h"
-#include <linux/fb.h>
+#include <camera_ifc.h>
+#if DLOPEN_LIBQCAMERA
+#include <dlfcn.h>
+#endif
 
-#define LIKELY(exp)   __builtin_expect(!!(exp), 1)
-#define UNLIKELY(exp) __builtin_expect(!!(exp), 0)
+#define PRINT_TIME 0
 
 extern "C" {
-#include <fcntl.h>
-#include <time.h>
-#include <pthread.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <termios.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <signal.h>
-#include <errno.h>
-#include <sys/mman.h>
-#include <sys/system_properties.h>
-#include <sys/time.h>
-#include <stdlib.h>
-
-#include <msm_camera.h>
 
-#define DEFAULT_PICTURE_WIDTH  1024
-#define DEFAULT_PICTURE_HEIGHT 768
-#define THUMBNAIL_BUFFER_SIZE (THUMBNAIL_WIDTH * THUMBNAIL_HEIGHT * 3/2)
-#define MAX_ZOOM_LEVEL 20
-#define NOT_FOUND -1
-// Number of video buffers held by kernal (initially 1,2 &3)
-#define ACTIVE_VIDEO_BUFFERS 3
-
-#if DLOPEN_LIBMMCAMERA
-#include <dlfcn.h>
-
-void* (*LINK_cam_conf)(void *data);
-void* (*LINK_cam_frame)(void *data);
-bool  (*LINK_jpeg_encoder_init)();
-void  (*LINK_jpeg_encoder_join)();
-bool  (*LINK_jpeg_encoder_encode)(const cam_ctrl_dimension_t *dimen,
-                                  const uint8_t *thumbnailbuf, int thumbnailfd,
-                                  const uint8_t *snapshotbuf, int snapshotfd,
-                                  common_crop_t *scaling_parms, exif_tags_info_t *exif_data,
-                                  int exif_table_numEntries, int jpegPadding);
-void (*LINK_camframe_terminate)(void);
-//for 720p
-// Function to add a video buffer to free Q
-void (*LINK_camframe_free_video)(struct msm_frame *frame);
-// Function pointer , called by camframe when a video frame is available.
-void (**LINK_camframe_video_callback)(struct msm_frame * frame);
-// To flush free Q in cam frame.
-void (*LINK_cam_frame_flush_free_video)(void);
-
-int8_t (*LINK_jpeg_encoder_setMainImageQuality)(uint32_t quality);
-int8_t (*LINK_jpeg_encoder_setThumbnailQuality)(uint32_t quality);
-int8_t (*LINK_jpeg_encoder_setRotation)(uint32_t rotation);
-int8_t (*LINK_jpeg_encoder_setLocation)(const camera_position_type *location);
-const struct camera_size_type *(*LINK_default_sensor_get_snapshot_sizes)(int *len);
-int (*LINK_launch_cam_conf_thread)(void);
-int (*LINK_release_cam_conf_thread)(void);
-int8_t (*LINK_zoom_crop_upscale)(uint32_t width, uint32_t height,
-    uint32_t cropped_width, uint32_t cropped_height, uint8_t *img_buf);
-
-// callbacks
-void  (**LINK_mmcamera_camframe_callback)(struct msm_frame *frame);
-void  (**LINK_mmcamera_jpegfragment_callback)(uint8_t *buff_ptr,
-                                              uint32_t buff_size);
-void  (**LINK_mmcamera_jpeg_callback)(jpeg_event_t status);
-void  (**LINK_mmcamera_shutter_callback)(common_crop_t *crop);
-void  (**LINK_camframe_timeout_callback)(void);
-#else
-#define LINK_cam_conf cam_conf
-#define LINK_cam_frame cam_frame
-#define LINK_jpeg_encoder_init jpeg_encoder_init
-#define LINK_jpeg_encoder_join jpeg_encoder_join
-#define LINK_jpeg_encoder_encode jpeg_encoder_encode
-#define LINK_camframe_terminate camframe_terminate
-#define LINK_jpeg_encoder_setMainImageQuality jpeg_encoder_setMainImageQuality
-#define LINK_jpeg_encoder_setThumbnailQuality jpeg_encoder_setThumbnailQuality
-#define LINK_jpeg_encoder_setRotation jpeg_encoder_setRotation
-#define LINK_jpeg_encoder_setLocation jpeg_encoder_setLocation
-#define LINK_default_sensor_get_snapshot_sizes default_sensor_get_snapshot_sizes
-#define LINK_launch_cam_conf_thread launch_cam_conf_thread
-#define LINK_release_cam_conf_thread release_cam_conf_thread
-#define LINK_zoom_crop_upscale zoom_crop_upscale
-extern void (*mmcamera_camframe_callback)(struct msm_frame *frame);
-extern void (*mmcamera_jpegfragment_callback)(uint8_t *buff_ptr,
-                                      uint32_t buff_size);
-extern void (*mmcamera_jpeg_callback)(jpeg_event_t status);
-extern void (*mmcamera_shutter_callback)(common_crop_t *crop);
+static inline void print_time()
+{
+#if PRINT_TIME
+    struct timeval time; 
+    gettimeofday(&time, NULL);
+    LOGV("time: %lld us.", time.tv_sec * 1000000LL + time.tv_usec);
 #endif
+}
 
-} // extern "C"
-
-#ifndef HAVE_CAMERA_SIZE_TYPE
-struct camera_size_type {
+typedef struct {
     int width;
     int height;
-};
-#endif
-
-typedef struct crop_info_struct {
-    uint32_t x;
-    uint32_t y;
-    uint32_t w;
-    uint32_t h;
-} zoom_crop_info;
-
-union zoomimage
-{
-    char d[sizeof(struct mdp_blit_req_list) + sizeof(struct mdp_blit_req) * 1];
-    struct mdp_blit_req_list list;
-} zoomImage;
-
-//Default to VGA
-#define DEFAULT_PREVIEW_WIDTH 480
-#define DEFAULT_PREVIEW_HEIGHT 320
+} preview_size_type;
 
-/*
- * Modifying preview size requires modification
- * in bitmasks for boardproperties
- */
-
-static const camera_size_type preview_sizes[] = {
-    { 1280, 720 }, // 720P, reserved
-    { 800, 480 }, // WVGA
-    { 768, 432 },
-    { 720, 480 },
-    { 640, 480 }, // VGA
-    { 576, 432 },
+// These sizes have to be a multiple of 16 in each dimension
+static preview_size_type preview_sizes[] = {
     { 480, 320 }, // HVGA
-    { 384, 288 },
+    { 432, 320 }, // 1.35-to-1, for photos. (Rounded up from 1.3333 to 1)
     { 352, 288 }, // CIF
     { 320, 240 }, // QVGA
     { 240, 160 }, // SQVGA
     { 176, 144 }, // QCIF
 };
-#define PREVIEW_SIZE_COUNT (sizeof(preview_sizes)/sizeof(camera_size_type))
-
-static camera_size_type supportedPreviewSizes[PREVIEW_SIZE_COUNT];
-static unsigned int previewSizeCount;
+#define PREVIEW_SIZE_COUNT (sizeof(preview_sizes)/sizeof(preview_size_type))
+
+// default preview size is QVGA
+#define DEFAULT_PREVIEW_SETTING 0
+
+#define LIKELY( exp )       (__builtin_expect( (exp) != 0, true  ))
+#define UNLIKELY( exp )     (__builtin_expect( (exp) != 0, false ))
+
+    /* some functions we need from libqcamera */
+    extern void rex_start();
+    extern void rex_shutdown();
+
+    /* callbacks */
+#if DLOPEN_LIBQCAMERA == 0
+    extern void (*rex_signal_ready)();
+    extern uint8_t* (*cam_mmap_preview)(uint32_t size,
+                                                 uint32_t *phy_addr,
+                                                 uint32_t index);
+    extern uint8_t* (*cam_mmap_snapshot)(uint32_t size,
+                                                 uint32_t *phy_addr,
+                                                 uint32_t index);
+    extern int (*cam_munmap_preview)(uint32_t *phy_addr,
+                                     uint32_t size,
+                                     uint32_t index);
+    extern int (*cam_munmap_snapshot)(uint32_t *phy_addr,
+                                      uint32_t size,
+                                      uint32_t index);
+
+    extern clear_module_pmem(qdsp_module_type module);
+
+    extern void camera_assoc_pmem(qdsp_module_type module,
+                                  int pmem_fd, 
+                                  void *addr,
+                                  uint32_t length,
+                                  int external);
+
+    extern int camera_release_pmem(qdsp_module_type module,
+                                   void *addr,
+                                   uint32_t size,
+                                   uint32_t force);
+
+#define LINK_camera_assoc_pmem             camera_assoc_pmem
+#define LINK_clear_module_pmem             clear_module_pmem
+#define LINK_camera_release_pmem           camera_release_pmem
+#define LINK_camera_encode_picture         camera_encode_picture
+#define LINK_camera_init                   camera_init
+#define LINK_camera_af_init                camera_af_init
+#define LINK_camera_release_frame          camera_release_frame
+#define LINK_camera_set_dimensions         camera_set_dimensions
+#define LINK_camera_set_encode_properties  camera_set_encode_properties
+#define LINK_camera_set_parm               camera_set_parm
+#define LINK_camera_set_parm_2             camera_set_parm_2
+#define LINK_camera_set_position           camera_set_position
+#define LINK_camera_set_thumbnail_properties camera_set_thumbnail_properties
+#define LINK_camera_start                  camera_start
+#define LINK_camera_start_preview          camera_start_preview
+#define LINK_camera_start_focus            camera_start_focus
+#define LINK_camera_stop_focus             camera_stop_focus
+#define LINK_camera_stop                   camera_stop
+#define LINK_camera_stop_preview           camera_stop_preview
+#define LINK_camera_take_picture           camera_take_picture
+#define LINK_rex_shutdown                  rex_shutdown
+#define LINK_rex_start                     rex_start
+#define LINK_rex_signal_ready              rex_signal_ready
+
+#define LINK_cam_mmap_preview   cam_mmap_preview
+#define LINK_cam_munmap_preview cam_munmap_preview
+#define LINK_cam_mmap_snapshot  cam_mmap_snapshot
+#define LINK_cam_munmap_snapshot cam_munmap_snapshot
 
-board_property boardProperties[] = {
-        {TARGET_MSM7625, 0x00000fff},
-        {TARGET_MSM7627, 0x000006ff},
-        {TARGET_MSM7630, 0x00000fff},
-        {TARGET_QSD8250, 0x00000fff}
-};
+#else
 
-//static const camera_size_type* picture_sizes;
-//static int PICTURE_SIZE_COUNT;
-/*       TODO
- * Ideally this should be a populated by lower layers.
- * But currently this is no API to do that at lower layer.
- * Hence populating with default sizes for now. This needs
- * to be changed once the API is supported.
- */
-//sorted on column basis
-static const camera_size_type picture_sizes[] = {
-//    { 2592, 1944 }, // 5MP
-    { 2560, 1920 }, // 5MP (slightly reduced)
-    { 2048, 1536 }, // 3MP QXGA
-    //{ 1920, 1080 }, //HD1080
-    { 1600, 1200 }, // 2MP UXGA
-    { 1280, 768 }, //WXGA
-    { 1280, 720 }, //HD720
-    { 1024, 768}, // 1MP XGA
-//    { 800, 600 }, //SVGA
-    { 800, 480 }, // WVGA
-    { 640, 480 }, // VGA
-    { 352, 288 }, //CIF
-    { 320, 240 }, // QVGA
-    { 176, 144 } // QCIF
-};
-static int PICTURE_SIZE_COUNT = sizeof(picture_sizes)/sizeof(camera_size_type);
-static const camera_size_type * picture_sizes_ptr;
-static int supportedPictureSizesCount;
+    /* Function pointers to assign to */
 
-#ifdef Q12
-#undef Q12
-#endif
+    void (**LINK_rex_signal_ready)();
 
-#define Q12 4096
+    uint8_t* (**LINK_cam_mmap_preview)(
+        uint32_t size,
+        uint32_t *phy_addr,
+        uint32_t index);
 
-static const target_map targetList [] = {
-    { "msm7625", TARGET_MSM7625 },
-    { "msm7627", TARGET_MSM7627 },
-    { "qsd8250", TARGET_QSD8250 },
-    { "msm7630", TARGET_MSM7630 }
-};
-static targetType mCurrentTarget = TARGET_MSM7627;
+    int (**LINK_cam_munmap_preview)(
+        uint32_t *phy_addr,
+        uint32_t size,
+        uint32_t index);
 
-typedef struct {
-    uint32_t aspect_ratio;
-    uint32_t width;
-    uint32_t height;
-} thumbnail_size_type;
-
-static thumbnail_size_type thumbnail_sizes[] = {
-    { 7281, 512, 288 }, //1.777778
-    { 6826, 480, 288 }, //1.666667
-    { 6144, 432, 288 }, //1.5
-    { 5461, 512, 384 }, //1.333333
-    { 5006, 352, 288 }, //1.222222
-};
-#define THUMBNAIL_SIZE_COUNT (sizeof(thumbnail_sizes)/sizeof(thumbnail_size_type))
-#define DEFAULT_THUMBNAIL_SETTING 2
-#define THUMBNAIL_WIDTH_STR "512"
-#define THUMBNAIL_HEIGHT_STR "384"
-#define THUMBNAIL_SMALL_HEIGHT 144
+    uint8_t* (**LINK_cam_mmap_snapshot)(
+        uint32_t size,
+        uint32_t *phy_addr,
+        uint32_t index);
 
-static int attr_lookup(const str_map arr[], int len, const char *name)
-{
-    if (name) {
-        for (int i = 0; i < len; i++) {
-            if (!strcmp(arr[i].desc, name))
-                return arr[i].val;
-        }
-    }
-    return NOT_FOUND;
-}
+    int (**LINK_cam_munmap_snapshot)(
+        uint32_t *phy_addr,
+        uint32_t size,
+        uint32_t index);
 
-// round to the next power of two
-static inline unsigned clp2(unsigned x)
-{
-    x = x - 1;
-    x = x | (x >> 1);
-    x = x | (x >> 2);
-    x = x | (x >> 4);
-    x = x | (x >> 8);
-    x = x | (x >>16);
-    return x + 1;
-}
+    /* Function pointers to resolve */
 
-static int exif_table_numEntries = 0;
-#define MAX_EXIF_TABLE_ENTRIES 7
-exif_tags_info_t exif_data[MAX_EXIF_TABLE_ENTRIES];
-static zoom_crop_info zoomCropInfo;
-static void *mLastQueuedFrame = NULL;
-#define RECORD_BUFFERS_7x30 8
-#define RECORD_BUFFERS_8x50 8
-static int kRecordBufferCount;
+    void (*LINK_camera_assoc_pmem)(qdsp_module_type module,
+                                   int pmem_fd, 
+                                   void *addr,
+                                   uint32_t length,
+                                   int external);
 
+    void (*LINK_clear_module_pmem)(qdsp_module_type module);
 
-namespace android {
+    int (*LINK_camera_release_pmem)(qdsp_module_type module,
+                                    void *addr,
+                                    uint32_t size,
+                                    uint32_t force);
 
-static const int PICTURE_FORMAT_JPEG = 1;
-static const int PICTURE_FORMAT_RAW = 2;
+    camera_ret_code_type (*LINK_camera_encode_picture) (
+        camera_frame_type *frame,
+        camera_handle_type *handle,
+        camera_cb_f_type callback,
+        void *client_data);
 
-// from aeecamera.h
-static const str_map whitebalance[] = {
-    { CameraParameters::WHITE_BALANCE_AUTO,            CAMERA_WB_AUTO },
-    { CameraParameters::WHITE_BALANCE_INCANDESCENT,    CAMERA_WB_INCANDESCENT },
-    { CameraParameters::WHITE_BALANCE_FLUORESCENT,     CAMERA_WB_FLUORESCENT },
-    { CameraParameters::WHITE_BALANCE_DAYLIGHT,        CAMERA_WB_DAYLIGHT },
-    { CameraParameters::WHITE_BALANCE_CLOUDY_DAYLIGHT, CAMERA_WB_CLOUDY_DAYLIGHT }
-};
+    void (*LINK_camera_init)(void);
 
-// from camera_effect_t. This list must match aeecamera.h
-static const str_map effects[] = {
-    { CameraParameters::EFFECT_NONE,       CAMERA_EFFECT_OFF },
-    { CameraParameters::EFFECT_MONO,       CAMERA_EFFECT_MONO },
-    { CameraParameters::EFFECT_NEGATIVE,   CAMERA_EFFECT_NEGATIVE },
-    { CameraParameters::EFFECT_SOLARIZE,   CAMERA_EFFECT_SOLARIZE },
-    { CameraParameters::EFFECT_SEPIA,      CAMERA_EFFECT_SEPIA },
-//    { CameraParameters::EFFECT_POSTERIZE,  CAMERA_EFFECT_POSTERIZE },
-    { CameraParameters::EFFECT_WHITEBOARD, CAMERA_EFFECT_WHITEBOARD },
-    { CameraParameters::EFFECT_BLACKBOARD, CAMERA_EFFECT_BLACKBOARD },
-//    { CameraParameters::EFFECT_AQUA,       CAMERA_EFFECT_AQUA }
-};
+    void (*LINK_camera_af_init)(void);
 
-// from qcamera/common/camera.h
-static const str_map autoexposure[] = {
-    { CameraParameters::AUTO_EXPOSURE_FRAME_AVG,  CAMERA_AEC_FRAME_AVERAGE },
-    { CameraParameters::AUTO_EXPOSURE_CENTER_WEIGHTED, CAMERA_AEC_CENTER_WEIGHTED },
-    { CameraParameters::AUTO_EXPOSURE_SPOT_METERING, CAMERA_AEC_SPOT_METERING }
-};
+    camera_ret_code_type (*LINK_camera_release_frame)(void);
 
-// from qcamera/common/camera.h
-static const str_map antibanding[] = {
-    { CameraParameters::ANTIBANDING_OFF,  CAMERA_ANTIBANDING_OFF },
-    { CameraParameters::ANTIBANDING_50HZ, CAMERA_ANTIBANDING_50HZ },
-    { CameraParameters::ANTIBANDING_60HZ, CAMERA_ANTIBANDING_60HZ },
-    { CameraParameters::ANTIBANDING_AUTO, CAMERA_ANTIBANDING_AUTO }
-};
+    camera_ret_code_type (*LINK_camera_set_dimensions) (
+        uint16_t picture_width,
+        uint16_t picture_height,
+        uint16_t display_width,
+#ifdef FEATURE_CAMERA_V7
+        uint16_t display_height,
+#endif
+        camera_cb_f_type callback,
+        void *client_data);
+
+    camera_ret_code_type (*LINK_camera_set_encode_properties)(
+        camera_encode_properties_type *encode_properties);
+
+    camera_ret_code_type (*LINK_camera_set_parm) (
+        camera_parm_type id,
+        int32_t          parm,
+        camera_cb_f_type callback,
+        void            *client_data);
+
+    camera_ret_code_type (*LINK_camera_set_parm_2) (
+        camera_parm_type id,
+        int32_t          parm1,
+        int32_t          parm2,
+        camera_cb_f_type callback,
+        void            *client_data);
+
+    camera_ret_code_type (*LINK_camera_set_position) (
+        camera_position_type *position,
+        camera_cb_f_type      callback,
+        void                 *client_data);
+
+    camera_ret_code_type (*LINK_camera_set_thumbnail_properties) (
+                              uint32_t width,
+                              uint32_t height,
+                              uint32_t quality);
+
+    camera_ret_code_type (*LINK_camera_start) (
+        camera_cb_f_type callback,
+        void *client_data
+#ifdef FEATURE_NATIVELINUX
+        ,int  display_height,
+        int  display_width
+#endif /* FEATURE_NATIVELINUX */
+        );
+
+    camera_ret_code_type (*LINK_camera_start_preview) (
+        camera_cb_f_type callback,
+        void *client_data);
+
+    camera_ret_code_type (*LINK_camera_start_focus) (
+        camera_focus_e_type focus,
+        camera_cb_f_type callback,
+        void *client_data);
+
+    camera_ret_code_type (*LINK_camera_stop_focus) (void);
+
+    camera_ret_code_type (*LINK_camera_stop) (
+        camera_cb_f_type callback,
+        void *client_data);
+
+    camera_ret_code_type (*LINK_camera_stop_preview) (void);
+
+    camera_ret_code_type (*LINK_camera_take_picture) (
+        camera_cb_f_type    callback,
+        void               *client_data
+#if !defined FEATURE_CAMERA_ENCODE_PROPERTIES && defined FEATURE_CAMERA_V7
+        ,camera_raw_type camera_raw_mode
+#endif /* nFEATURE_CAMERA_ENCODE_PROPERTIES && FEATURE_CAMERA_V7 */
+        );
+    
+    int (*LINK_rex_start)(void);
 
-/* Mapping from MCC to antibanding type */
-struct country_map {
-    uint32_t country_code;
-    camera_antibanding_type type;
-};
+    int (*LINK_rex_shutdown)(void);
 
-static struct country_map country_numeric[] = {
-    { 202, CAMERA_ANTIBANDING_50HZ }, // Greece
-    { 204, CAMERA_ANTIBANDING_50HZ }, // Netherlands
-    { 206, CAMERA_ANTIBANDING_50HZ }, // Belgium
-    { 208, CAMERA_ANTIBANDING_50HZ }, // France
-    { 212, CAMERA_ANTIBANDING_50HZ }, // Monaco
-    { 213, CAMERA_ANTIBANDING_50HZ }, // Andorra
-    { 214, CAMERA_ANTIBANDING_50HZ }, // Spain
-    { 216, CAMERA_ANTIBANDING_50HZ }, // Hungary
-    { 219, CAMERA_ANTIBANDING_50HZ }, // Croatia
-    { 220, CAMERA_ANTIBANDING_50HZ }, // Serbia
-    { 222, CAMERA_ANTIBANDING_50HZ }, // Italy
-    { 226, CAMERA_ANTIBANDING_50HZ }, // Romania
-    { 228, CAMERA_ANTIBANDING_50HZ }, // Switzerland
-    { 230, CAMERA_ANTIBANDING_50HZ }, // Czech Republic
-    { 231, CAMERA_ANTIBANDING_50HZ }, // Slovakia
-    { 232, CAMERA_ANTIBANDING_50HZ }, // Austria
-    { 234, CAMERA_ANTIBANDING_50HZ }, // United Kingdom
-    { 235, CAMERA_ANTIBANDING_50HZ }, // United Kingdom
-    { 238, CAMERA_ANTIBANDING_50HZ }, // Denmark
-    { 240, CAMERA_ANTIBANDING_50HZ }, // Sweden
-    { 242, CAMERA_ANTIBANDING_50HZ }, // Norway
-    { 244, CAMERA_ANTIBANDING_50HZ }, // Finland
-    { 246, CAMERA_ANTIBANDING_50HZ }, // Lithuania
-    { 247, CAMERA_ANTIBANDING_50HZ }, // Latvia
-    { 248, CAMERA_ANTIBANDING_50HZ }, // Estonia
-    { 250, CAMERA_ANTIBANDING_50HZ }, // Russian Federation
-    { 255, CAMERA_ANTIBANDING_50HZ }, // Ukraine
-    { 257, CAMERA_ANTIBANDING_50HZ }, // Belarus
-    { 259, CAMERA_ANTIBANDING_50HZ }, // Moldova
-    { 260, CAMERA_ANTIBANDING_50HZ }, // Poland
-    { 262, CAMERA_ANTIBANDING_50HZ }, // Germany
-    { 266, CAMERA_ANTIBANDING_50HZ }, // Gibraltar
-    { 268, CAMERA_ANTIBANDING_50HZ }, // Portugal
-    { 270, CAMERA_ANTIBANDING_50HZ }, // Luxembourg
-    { 272, CAMERA_ANTIBANDING_50HZ }, // Ireland
-    { 274, CAMERA_ANTIBANDING_50HZ }, // Iceland
-    { 276, CAMERA_ANTIBANDING_50HZ }, // Albania
-    { 278, CAMERA_ANTIBANDING_50HZ }, // Malta
-    { 280, CAMERA_ANTIBANDING_50HZ }, // Cyprus
-    { 282, CAMERA_ANTIBANDING_50HZ }, // Georgia
-    { 283, CAMERA_ANTIBANDING_50HZ }, // Armenia
-    { 284, CAMERA_ANTIBANDING_50HZ }, // Bulgaria
-    { 286, CAMERA_ANTIBANDING_50HZ }, // Turkey
-    { 288, CAMERA_ANTIBANDING_50HZ }, // Faroe Islands
-    { 290, CAMERA_ANTIBANDING_50HZ }, // Greenland
-    { 293, CAMERA_ANTIBANDING_50HZ }, // Slovenia
-    { 294, CAMERA_ANTIBANDING_50HZ }, // Macedonia
-    { 295, CAMERA_ANTIBANDING_50HZ }, // Liechtenstein
-    { 297, CAMERA_ANTIBANDING_50HZ }, // Montenegro
-    { 302, CAMERA_ANTIBANDING_60HZ }, // Canada
-    { 310, CAMERA_ANTIBANDING_60HZ }, // United States of America
-    { 311, CAMERA_ANTIBANDING_60HZ }, // United States of America
-    { 312, CAMERA_ANTIBANDING_60HZ }, // United States of America
-    { 313, CAMERA_ANTIBANDING_60HZ }, // United States of America
-    { 314, CAMERA_ANTIBANDING_60HZ }, // United States of America
-    { 315, CAMERA_ANTIBANDING_60HZ }, // United States of America
-    { 316, CAMERA_ANTIBANDING_60HZ }, // United States of America
-    { 330, CAMERA_ANTIBANDING_60HZ }, // Puerto Rico
-    { 334, CAMERA_ANTIBANDING_60HZ }, // Mexico
-    { 338, CAMERA_ANTIBANDING_50HZ }, // Jamaica
-    { 340, CAMERA_ANTIBANDING_50HZ }, // Martinique
-    { 342, CAMERA_ANTIBANDING_50HZ }, // Barbados
-    { 346, CAMERA_ANTIBANDING_60HZ }, // Cayman Islands
-    { 350, CAMERA_ANTIBANDING_60HZ }, // Bermuda
-    { 352, CAMERA_ANTIBANDING_50HZ }, // Grenada
-    { 354, CAMERA_ANTIBANDING_60HZ }, // Montserrat
-    { 362, CAMERA_ANTIBANDING_50HZ }, // Netherlands Antilles
-    { 363, CAMERA_ANTIBANDING_60HZ }, // Aruba
-    { 364, CAMERA_ANTIBANDING_60HZ }, // Bahamas
-    { 365, CAMERA_ANTIBANDING_60HZ }, // Anguilla
-    { 366, CAMERA_ANTIBANDING_50HZ }, // Dominica
-    { 368, CAMERA_ANTIBANDING_60HZ }, // Cuba
-    { 370, CAMERA_ANTIBANDING_60HZ }, // Dominican Republic
-    { 372, CAMERA_ANTIBANDING_60HZ }, // Haiti
-    { 401, CAMERA_ANTIBANDING_50HZ }, // Kazakhstan
-    { 402, CAMERA_ANTIBANDING_50HZ }, // Bhutan
-    { 404, CAMERA_ANTIBANDING_50HZ }, // India
-    { 405, CAMERA_ANTIBANDING_50HZ }, // India
-    { 410, CAMERA_ANTIBANDING_50HZ }, // Pakistan
-    { 413, CAMERA_ANTIBANDING_50HZ }, // Sri Lanka
-    { 414, CAMERA_ANTIBANDING_50HZ }, // Myanmar
-    { 415, CAMERA_ANTIBANDING_50HZ }, // Lebanon
-    { 416, CAMERA_ANTIBANDING_50HZ }, // Jordan
-    { 417, CAMERA_ANTIBANDING_50HZ }, // Syria
-    { 418, CAMERA_ANTIBANDING_50HZ }, // Iraq
-    { 419, CAMERA_ANTIBANDING_50HZ }, // Kuwait
-    { 420, CAMERA_ANTIBANDING_60HZ }, // Saudi Arabia
-    { 421, CAMERA_ANTIBANDING_50HZ }, // Yemen
-    { 422, CAMERA_ANTIBANDING_50HZ }, // Oman
-    { 424, CAMERA_ANTIBANDING_50HZ }, // United Arab Emirates
-    { 425, CAMERA_ANTIBANDING_50HZ }, // Israel
-    { 426, CAMERA_ANTIBANDING_50HZ }, // Bahrain
-    { 427, CAMERA_ANTIBANDING_50HZ }, // Qatar
-    { 428, CAMERA_ANTIBANDING_50HZ }, // Mongolia
-    { 429, CAMERA_ANTIBANDING_50HZ }, // Nepal
-    { 430, CAMERA_ANTIBANDING_50HZ }, // United Arab Emirates
-    { 431, CAMERA_ANTIBANDING_50HZ }, // United Arab Emirates
-    { 432, CAMERA_ANTIBANDING_50HZ }, // Iran
-    { 434, CAMERA_ANTIBANDING_50HZ }, // Uzbekistan
-    { 436, CAMERA_ANTIBANDING_50HZ }, // Tajikistan
-    { 437, CAMERA_ANTIBANDING_50HZ }, // Kyrgyz Rep
-    { 438, CAMERA_ANTIBANDING_50HZ }, // Turkmenistan
-    { 440, CAMERA_ANTIBANDING_60HZ }, // Japan
-    { 441, CAMERA_ANTIBANDING_60HZ }, // Japan
-    { 452, CAMERA_ANTIBANDING_50HZ }, // Vietnam
-    { 454, CAMERA_ANTIBANDING_50HZ }, // Hong Kong
-    { 455, CAMERA_ANTIBANDING_50HZ }, // Macao
-    { 456, CAMERA_ANTIBANDING_50HZ }, // Cambodia
-    { 457, CAMERA_ANTIBANDING_50HZ }, // Laos
-    { 460, CAMERA_ANTIBANDING_50HZ }, // China
-    { 466, CAMERA_ANTIBANDING_60HZ }, // Taiwan
-    { 470, CAMERA_ANTIBANDING_50HZ }, // Bangladesh
-    { 472, CAMERA_ANTIBANDING_50HZ }, // Maldives
-    { 502, CAMERA_ANTIBANDING_50HZ }, // Malaysia
-    { 505, CAMERA_ANTIBANDING_50HZ }, // Australia
-    { 510, CAMERA_ANTIBANDING_50HZ }, // Indonesia
-    { 514, CAMERA_ANTIBANDING_50HZ }, // East Timor
-    { 515, CAMERA_ANTIBANDING_60HZ }, // Philippines
-    { 520, CAMERA_ANTIBANDING_50HZ }, // Thailand
-    { 525, CAMERA_ANTIBANDING_50HZ }, // Singapore
-    { 530, CAMERA_ANTIBANDING_50HZ }, // New Zealand
-    { 535, CAMERA_ANTIBANDING_60HZ }, // Guam
-    { 536, CAMERA_ANTIBANDING_50HZ }, // Nauru
-    { 537, CAMERA_ANTIBANDING_50HZ }, // Papua New Guinea
-    { 539, CAMERA_ANTIBANDING_50HZ }, // Tonga
-    { 541, CAMERA_ANTIBANDING_50HZ }, // Vanuatu
-    { 542, CAMERA_ANTIBANDING_50HZ }, // Fiji
-    { 544, CAMERA_ANTIBANDING_60HZ }, // American Samoa
-    { 545, CAMERA_ANTIBANDING_50HZ }, // Kiribati
-    { 546, CAMERA_ANTIBANDING_50HZ }, // New Caledonia
-    { 548, CAMERA_ANTIBANDING_50HZ }, // Cook Islands
-    { 602, CAMERA_ANTIBANDING_50HZ }, // Egypt
-    { 603, CAMERA_ANTIBANDING_50HZ }, // Algeria
-    { 604, CAMERA_ANTIBANDING_50HZ }, // Morocco
-    { 605, CAMERA_ANTIBANDING_50HZ }, // Tunisia
-    { 606, CAMERA_ANTIBANDING_50HZ }, // Libya
-    { 607, CAMERA_ANTIBANDING_50HZ }, // Gambia
-    { 608, CAMERA_ANTIBANDING_50HZ }, // Senegal
-    { 609, CAMERA_ANTIBANDING_50HZ }, // Mauritania
-    { 610, CAMERA_ANTIBANDING_50HZ }, // Mali
-    { 611, CAMERA_ANTIBANDING_50HZ }, // Guinea
-    { 613, CAMERA_ANTIBANDING_50HZ }, // Burkina Faso
-    { 614, CAMERA_ANTIBANDING_50HZ }, // Niger
-    { 616, CAMERA_ANTIBANDING_50HZ }, // Benin
-    { 617, CAMERA_ANTIBANDING_50HZ }, // Mauritius
-    { 618, CAMERA_ANTIBANDING_50HZ }, // Liberia
-    { 619, CAMERA_ANTIBANDING_50HZ }, // Sierra Leone
-    { 620, CAMERA_ANTIBANDING_50HZ }, // Ghana
-    { 621, CAMERA_ANTIBANDING_50HZ }, // Nigeria
-    { 622, CAMERA_ANTIBANDING_50HZ }, // Chad
-    { 623, CAMERA_ANTIBANDING_50HZ }, // Central African Republic
-    { 624, CAMERA_ANTIBANDING_50HZ }, // Cameroon
-    { 625, CAMERA_ANTIBANDING_50HZ }, // Cape Verde
-    { 627, CAMERA_ANTIBANDING_50HZ }, // Equatorial Guinea
-    { 631, CAMERA_ANTIBANDING_50HZ }, // Angola
-    { 633, CAMERA_ANTIBANDING_50HZ }, // Seychelles
-    { 634, CAMERA_ANTIBANDING_50HZ }, // Sudan
-    { 636, CAMERA_ANTIBANDING_50HZ }, // Ethiopia
-    { 637, CAMERA_ANTIBANDING_50HZ }, // Somalia
-    { 638, CAMERA_ANTIBANDING_50HZ }, // Djibouti
-    { 639, CAMERA_ANTIBANDING_50HZ }, // Kenya
-    { 640, CAMERA_ANTIBANDING_50HZ }, // Tanzania
-    { 641, CAMERA_ANTIBANDING_50HZ }, // Uganda
-    { 642, CAMERA_ANTIBANDING_50HZ }, // Burundi
-    { 643, CAMERA_ANTIBANDING_50HZ }, // Mozambique
-    { 645, CAMERA_ANTIBANDING_50HZ }, // Zambia
-    { 646, CAMERA_ANTIBANDING_50HZ }, // Madagascar
-    { 647, CAMERA_ANTIBANDING_50HZ }, // France
-    { 648, CAMERA_ANTIBANDING_50HZ }, // Zimbabwe
-    { 649, CAMERA_ANTIBANDING_50HZ }, // Namibia
-    { 650, CAMERA_ANTIBANDING_50HZ }, // Malawi
-    { 651, CAMERA_ANTIBANDING_50HZ }, // Lesotho
-    { 652, CAMERA_ANTIBANDING_50HZ }, // Botswana
-    { 653, CAMERA_ANTIBANDING_50HZ }, // Swaziland
-    { 654, CAMERA_ANTIBANDING_50HZ }, // Comoros
-    { 655, CAMERA_ANTIBANDING_50HZ }, // South Africa
-    { 657, CAMERA_ANTIBANDING_50HZ }, // Eritrea
-    { 702, CAMERA_ANTIBANDING_60HZ }, // Belize
-    { 704, CAMERA_ANTIBANDING_60HZ }, // Guatemala
-    { 706, CAMERA_ANTIBANDING_60HZ }, // El Salvador
-    { 708, CAMERA_ANTIBANDING_60HZ }, // Honduras
-    { 710, CAMERA_ANTIBANDING_60HZ }, // Nicaragua
-    { 712, CAMERA_ANTIBANDING_60HZ }, // Costa Rica
-    { 714, CAMERA_ANTIBANDING_60HZ }, // Panama
-    { 722, CAMERA_ANTIBANDING_50HZ }, // Argentina
-    { 724, CAMERA_ANTIBANDING_60HZ }, // Brazil
-    { 730, CAMERA_ANTIBANDING_50HZ }, // Chile
-    { 732, CAMERA_ANTIBANDING_60HZ }, // Colombia
-    { 734, CAMERA_ANTIBANDING_60HZ }, // Venezuela
-    { 736, CAMERA_ANTIBANDING_50HZ }, // Bolivia
-    { 738, CAMERA_ANTIBANDING_60HZ }, // Guyana
-    { 740, CAMERA_ANTIBANDING_60HZ }, // Ecuador
-    { 742, CAMERA_ANTIBANDING_50HZ }, // French Guiana
-    { 744, CAMERA_ANTIBANDING_50HZ }, // Paraguay
-    { 746, CAMERA_ANTIBANDING_60HZ }, // Suriname
-    { 748, CAMERA_ANTIBANDING_50HZ }, // Uruguay
-    { 750, CAMERA_ANTIBANDING_50HZ }, // Falkland Islands
-};
+#endif
 
-#define country_number (sizeof(country_numeric) / sizeof(country_map))
-
-/* Look up pre-sorted antibanding_type table by current MCC. */
-static camera_antibanding_type camera_get_location(void) {
-    char value[PROP_VALUE_MAX];
-    char country_value[PROP_VALUE_MAX];
-    uint32_t country_code, count;
-    memset(value, 0x00, sizeof(value));
-    memset(country_value, 0x00, sizeof(country_value));
-    if (!__system_property_get("gsm.operator.numeric", value)) {
-        return CAMERA_ANTIBANDING_60HZ;
-    }
-    memcpy(country_value, value, 3);
-    country_code = atoi(country_value);
-    LOGD("value:%s, country value:%s, country code:%d\n",
-            value, country_value, country_code);
-    int left = 0;
-    int right = country_number - 1;
-    while (left <= right) {
-        int index = (left + right) >> 1;
-        if (country_numeric[index].country_code == country_code)
-            return country_numeric[index].type;
-        else if (country_numeric[index].country_code > country_code)
-            right = index - 1;
-        else
-            left = index + 1;
-    }
-    return CAMERA_ANTIBANDING_60HZ;
 }
 
-// from camera.h, led_mode_t
-static const str_map flash[] = {
-    { CameraParameters::FLASH_MODE_OFF,  LED_MODE_OFF },
-    { CameraParameters::FLASH_MODE_AUTO, LED_MODE_AUTO },
-    { CameraParameters::FLASH_MODE_ON, LED_MODE_ON },
-    { "torch", LED_MODE_ON }
-};
+#include "QualcommCameraHardware.h"
 
-// from mm-camera/common/camera.h.
-static const str_map iso[] = {
-    { CameraParameters::ISO_AUTO,  CAMERA_ISO_AUTO},
-    { CameraParameters::ISO_HJR,   CAMERA_ISO_DEBLUR},
-    { CameraParameters::ISO_100,   CAMERA_ISO_100},
-    { CameraParameters::ISO_200,   CAMERA_ISO_200},
-    { CameraParameters::ISO_400,   CAMERA_ISO_400},
-    { CameraParameters::ISO_800,   CAMERA_ISO_800 }
-};
+namespace android {
 
+    static Mutex singleton_lock;
+    static Mutex rex_init_lock;
+    static Condition rex_init_wait;
+
+    static uint8_t* malloc_preview(uint32_t, uint32_t *, uint32_t);
+    static uint8_t* malloc_raw(uint32_t, uint32_t *, uint32_t);
+    static int free_preview(uint32_t *, uint32_t , uint32_t);
+    static int free_raw(uint32_t *, uint32_t , uint32_t);
+    static int reassoc(qdsp_module_type module);
+    static void cb_rex_signal_ready(void);
+
+    QualcommCameraHardware::QualcommCameraHardware()
+        : mParameters(),
+          mPreviewHeight(-1),
+          mPreviewWidth(-1),
+          mRawHeight(-1),
+          mRawWidth(-1),
+          mCameraState(QCS_INIT),
+          mShutterCallback(0),
+          mRawPictureCallback(0),
+          mJpegPictureCallback(0),
+          mPictureCallbackCookie(0),
+          mAutoFocusCallback(0),
+          mAutoFocusCallbackCookie(0),
+          mPreviewCallback(0),
+          mPreviewCallbackCookie(0),
+          mRecordingCallback(0),
+          mRecordingCallbackCookie(0),
+          mPreviewFrameSize(0),
+          mRawSize(0),
+          mPreviewCount(0)
+    {
+        LOGV("constructor EX");
+    }
 
-#define DONT_CARE 0
-static const str_map focus_modes[] = {
-    { CameraParameters::FOCUS_MODE_AUTO,     AF_MODE_AUTO},
-    { CameraParameters::FOCUS_MODE_INFINITY, DONT_CARE },
-    { CameraParameters::FOCUS_MODE_NORMAL,   AF_MODE_NORMAL },
-    { CameraParameters::FOCUS_MODE_MACRO,    AF_MODE_MACRO }
-};
+    void QualcommCameraHardware::initDefaultParameters()
+    {
+        CameraParameters p;
+
+        preview_size_type* ps = &preview_sizes[DEFAULT_PREVIEW_SETTING];
+        p.setPreviewSize(ps->width, ps->height);
+        p.setPreviewFrameRate(15);
+        p.setPreviewFormat("yuv420sp");
+        p.setPictureFormat("jpeg"); // we do not look at this currently
+        p.setPictureSize(2048, 1536);
+        p.set("jpeg-quality", "100"); // maximum quality
+
+        // These values must be multiples of 16, so we can't do 427x320, which is the exact size on
+        // screen we want to display at. 480x360 doesn't work either since it's a multiple of 8.
+        p.set("jpeg-thumbnail-width", "512");
+        p.set("jpeg-thumbnail-height", "384");
+        p.set("jpeg-thumbnail-quality", "90");
+
+        p.set("nightshot-mode", "0"); // off
+        p.set("luma-adaptation", "0"); // FIXME: turning it on causes a crash
+        p.set("antibanding", "auto"); // flicker detection and elimination
+        p.set("whitebalance", "auto");
+        p.set("rotation", "0");
 
-static const str_map lensshade[] = {
-    { CameraParameters::LENSSHADE_ENABLE, TRUE },
-    { CameraParameters::LENSSHADE_DISABLE, FALSE }
-};
+#if 0
+        p.set("gps-timestamp", "1199145600"); // Jan 1, 2008, 00:00:00
+        p.set("gps-latitude", "37.736071"); // A little house in San Francisco
+        p.set("gps-longitude", "-122.441983");
+        p.set("gps-altitude", "21"); // meters
+#endif
 
-struct SensorType {
-    const char *name;
-    int rawPictureWidth;
-    int rawPictureHeight;
-    bool hasAutoFocusSupport;
-    int max_supported_snapshot_width;
-    int max_supported_snapshot_height;
-    int bitMask;
-};
+        // List supported picture size values
+        p.set("picture-size-values", "2048x1536,1600x1200,1024x768");
 
-static SensorType sensorTypes[] = {
-        { "5mp", 2608, 1960, true,  2592, 1944,0x00000fff },
-        { "5mp", 5184, 1944, true,  2592, 1944,0x00000fff }, // actual 5MP blade
-        { "5mp", 2560, 1920, true,  2560, 1920,0x00000fff }, //should be 5MP blade
-        { "3mp", 2064, 1544, false, 2048, 1536,0x000007ff },
-        { "3mp", 4096, 1536, true, 2048, 1536,0x000007ff }, // 3MP blade
-        { "2mp", 3200, 1200, false, 1600, 1200,0x000007ff } };
+        // List supported antibanding values
+        p.set("antibanding-values",
+              "off,50hz,60hz,auto");
 
+        // List supported effects:
+        p.set("effect-values",
+              "off,mono,negative,solarize,sepia,posterize,whiteboard,"\
+              "blackboard,aqua");
 
-static SensorType * sensorType;
+        // List supported exposure-offset:
+        p.set("exposure-offset-values",
+              "0,1,2,3,4,5,6,7,8,9,10");
 
-static const str_map picture_formats[] = {
-        {CameraParameters::PIXEL_FORMAT_JPEG, PICTURE_FORMAT_JPEG},
-        {CameraParameters::PIXEL_FORMAT_RAW, PICTURE_FORMAT_RAW}
-};
+        // List of whitebalance values
+        p.set("whitebalance-values",
+              "auto,incandescent,fluorescent,daylight,cloudy");
 
-static bool parameter_string_initialized = false;
-static String8 preview_size_values;
-static String8 picture_size_values;
-static String8 antibanding_values;
-static String8 effect_values;
-static String8 autoexposure_values;
-static String8 whitebalance_values;
-static String8 flash_values;
-static String8 focus_mode_values;
-static String8 iso_values;
-static String8 lensshade_values;
-static String8 picture_format_values;
-static String8 preview_frame_rate_values;
-
-static String8 create_sizes_str(const camera_size_type *sizes, int len) {
-    String8 str;
-    char buffer[32];
-
-    if (len > 0) {
-        sprintf(buffer, "%dx%d", sizes[0].width, sizes[0].height);
-        str.append(buffer);
-    }
-    for (int i = 1; i < len; i++) {
-        sprintf(buffer, ",%dx%d", sizes[i].width, sizes[i].height);
-        str.append(buffer);
+        // List of ISO values
+        p.set("iso-values", "auto,high");
+
+        if (setParameters(p) != NO_ERROR) {
+            LOGE("Failed to set default parameters?!");
+        }
     }
-    return str;
-}
 
-static String8 create_values_str(const str_map *values, int len) {
-    String8 str;
+#define ROUND_TO_PAGE(x)  (((x)+0xfff)&~0xfff)
+
+    // Called with mStateLock held!
+    void QualcommCameraHardware::startCameraIfNecessary()
+    {
+        if (mCameraState == QCS_INIT) {
+
+#if DLOPEN_LIBQCAMERA == 1
 
-    if (len > 0) {
-        str.append(values[0].desc);
+            LOGV("loading libqcamera");
+            libqcamera = ::dlopen("liboemcamera.so", RTLD_NOW);
+            if (!libqcamera) {
+                LOGE("FATAL ERROR: could not dlopen liboemcamera.so: %s", dlerror());
+                return;
+            }
+  
+            *(void **)&LINK_camera_assoc_pmem =
+                ::dlsym(libqcamera, "camera_assoc_pmem");
+            *(void **)&LINK_clear_module_pmem =
+                ::dlsym(libqcamera, "clear_module_pmem");
+            *(void **)&LINK_camera_release_pmem =
+                ::dlsym(libqcamera, "camera_release_pmem");
+            *(void **)&LINK_camera_encode_picture =
+                ::dlsym(libqcamera, "camera_encode_picture");
+            *(void **)&LINK_camera_init =
+                ::dlsym(libqcamera, "camera_init");
+            *(void **)&LINK_camera_af_init =
+                ::dlsym(libqcamera, "camera_af_init");
+            *(void **)&LINK_camera_release_frame =
+                ::dlsym(libqcamera, "camera_release_frame");
+            *(void **)&LINK_camera_set_dimensions =
+                ::dlsym(libqcamera, "camera_set_dimensions");
+            *(void **)&LINK_camera_set_encode_properties =
+                ::dlsym(libqcamera, "camera_set_encode_properties");
+            *(void **)&LINK_camera_set_parm =
+                ::dlsym(libqcamera, "camera_set_parm");
+            *(void **)&LINK_camera_set_parm_2 =
+                ::dlsym(libqcamera, "camera_set_parm_2");
+            *(void **)&LINK_camera_set_position =
+                ::dlsym(libqcamera, "camera_set_position");
+            *(void **)&LINK_camera_set_thumbnail_properties  =
+                ::dlsym(libqcamera, "camera_set_thumbnail_properties");
+            *(void **)&LINK_camera_start =
+                ::dlsym(libqcamera, "camera_start");
+            *(void **)&LINK_camera_start_preview =
+                ::dlsym(libqcamera, "camera_start_preview");
+            *(void **)&LINK_camera_start_focus =
+                ::dlsym(libqcamera, "camera_start_focus");
+            *(void **)&LINK_camera_stop_focus =
+                ::dlsym(libqcamera, "camera_stop_focus");
+            *(void **)&LINK_camera_stop =
+                ::dlsym(libqcamera, "camera_stop");
+            *(void **)&LINK_camera_stop_preview =
+                ::dlsym(libqcamera, "camera_stop_preview");
+            *(void **)&LINK_camera_take_picture =
+                ::dlsym(libqcamera, "camera_take_picture");
+            *(void **)&LINK_rex_shutdown =
+                ::dlsym(libqcamera, "rex_shutdown");
+            *(void **)&LINK_rex_start =
+                ::dlsym(libqcamera, "rex_start");
+            *(void **)&LINK_rex_signal_ready =
+                ::dlsym(libqcamera, "rex_signal_ready");
+            *(void **)&LINK_cam_mmap_preview =
+                ::dlsym(libqcamera, "cam_mmap_preview");
+            *(void **)&LINK_cam_munmap_preview =
+                ::dlsym(libqcamera, "cam_munmap_preview");
+            *(void **)&LINK_cam_mmap_snapshot =
+                ::dlsym(libqcamera, "cam_mmap_snapshot");
+            *(void **)&LINK_cam_munmap_snapshot =
+                ::dlsym(libqcamera, "cam_munmap_snapshot");
+            
+            *LINK_rex_signal_ready = cb_rex_signal_ready;
+            *LINK_cam_mmap_preview = malloc_preview;
+            *LINK_cam_munmap_preview = free_preview;
+            *LINK_cam_mmap_snapshot = malloc_raw;
+            *LINK_cam_munmap_snapshot = free_raw;
+#else
+            LINK_rex_signal_ready = cb_rex_signal_ready;
+            LINK_cam_mmap_preview = malloc_preview;
+            LINK_cam_munmap_preview = free_preview;
+            LINK_cam_mmap_snapshot = malloc_raw;
+            LINK_cam_munmap_snapshot = free_raw;
+#endif // DLOPEN_LIBQCAMERA == 1
+            
+            rex_init_lock.lock();
+            LINK_rex_start();
+            LOGV("waiting for REX to initialize.");
+            rex_init_wait.wait(rex_init_lock);
+            LOGV("REX is ready.");
+            rex_init_lock.unlock();
+            
+            LINK_camera_init();
+            
+            LOGV("starting REX emulation");
+            // NOTE: camera_start() takes (height, width), not (width, height).
+            LINK_camera_start(camera_cb, this,
+                              mPreviewHeight, mPreviewWidth);
+            while(mCameraState != QCS_IDLE &&
+                  mCameraState != QCS_ERROR) {
+                LOGV("init camera: waiting for QCS_IDLE");
+                mStateWait.wait(mStateLock);
+                LOGV("init camera: woke up");
+            }
+            LOGV("init camera: initializing parameters");
+        }
+        else LOGV("camera hardware has been started already");
     }
-    for (int i = 1; i < len; i++) {
-        str.append(",");
-        str.append(values[i].desc);
+
+    status_t QualcommCameraHardware::dump(int fd, const Vector<String16>& args) const
+    {
+        const size_t SIZE = 256;
+        char buffer[SIZE];
+        String8 result;
+        
+        // Dump internal primitives.
+        snprintf(buffer, 255, "QualcommCameraHardware::dump: state (%d)\n", mCameraState);
+        result.append(buffer);
+        snprintf(buffer, 255, "preview width(%d) x height (%d)\n", mPreviewWidth, mPreviewHeight);
+        result.append(buffer);
+        snprintf(buffer, 255, "raw width(%d) x height (%d)\n", mRawWidth, mRawHeight);
+        result.append(buffer);
+        snprintf(buffer, 255, "preview frame size(%d), raw size (%d), jpeg size (%d) and jpeg max size (%d)\n", mPreviewFrameSize, mRawSize, mJpegSize, mJpegMaxSize);
+        result.append(buffer);
+        write(fd, result.string(), result.size());
+        
+        // Dump internal objects.
+        if (mPreviewHeap != 0) {
+            mPreviewHeap->dump(fd, args);
+        }
+        if (mRawHeap != 0) {
+            mRawHeap->dump(fd, args);
+        }
+        if (mJpegHeap != 0) {
+            mJpegHeap->dump(fd, args);
+        }
+        mParameters.dump(fd, args);
+        return NO_ERROR;
     }
-    return str;
-}
+    
+    bool QualcommCameraHardware::initPreview()
+    {
+//      LINK_clear_module_pmem(QDSP_MODULE_VFETASK);
+
+        startCameraIfNecessary();
 
-static String8 create_values_range_str(int min, int max){
-    String8 str;
-    char buffer[32];
+        // Tell libqcamera what the preview and raw dimensions are.  We
+        // call this method even if the preview dimensions have not changed,
+        // because the picture ones may have.
+        //
+        // NOTE: if this errors out, mCameraState != QCS_IDLE, which will be
+        //       checked by the caller of this method.
 
-    if(min <= max){
-        snprintf(buffer, sizeof(buffer), "%d", min);
-        str.append(buffer);
+        setCameraDimensions();
 
-        for (int i = min + 1; i <= max; i++) {
-            snprintf(buffer, sizeof(buffer), ",%d", i);
-            str.append(buffer);
+        LOGV("initPreview: preview size=%dx%d", mPreviewWidth, mPreviewHeight);
+
+        mPreviewFrameSize = mPreviewWidth * mPreviewHeight * 3 / 2; // reality
+        mPreviewHeap =
+            new PreviewPmemPool(kRawFrameHeaderSize +
+                                mPreviewWidth * mPreviewHeight * 2, // worst
+                                kPreviewBufferCount,
+                                mPreviewFrameSize,
+                                kRawFrameHeaderSize,
+                                "preview");
+        
+        if (!mPreviewHeap->initialized()) {
+            mPreviewHeap = NULL;
+            return false;
         }
-    }
-    return str;
-}
 
-extern "C" {
-//------------------------------------------------------------------------
-//   : 720p busyQ funcitons
-//   --------------------------------------------------------------------
-static struct fifo_queue g_busy_frame_queue =
-    {0, 0, 0, PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER};
-};
-/*===========================================================================
- * FUNCTION      cam_frame_wait_video
- *
- * DESCRIPTION    this function waits a video in the busy queue
- * ===========================================================================*/
+//      LINK_camera_af_init();
 
-static void cam_frame_wait_video (void)
-{
-    LOGV("cam_frame_wait_video E ");
-    if ((g_busy_frame_queue.num_of_frames) <=0){
-        pthread_cond_wait(&(g_busy_frame_queue.wait), &(g_busy_frame_queue.mut));
+        return true;
     }
-    LOGV("cam_frame_wait_video X");
-    return;
-}
 
-/*===========================================================================
- * FUNCTION      cam_frame_flush_video
- *
- * DESCRIPTION    this function deletes all the buffers in  busy queue
- * ===========================================================================*/
-void cam_frame_flush_video (void)
-{
-    LOGV("cam_frame_flush_video: in n = %d\n", g_busy_frame_queue.num_of_frames);
-    pthread_mutex_lock(&(g_busy_frame_queue.mut));
+    void QualcommCameraHardware::deinitPreview()
+    {
+        mPreviewHeap = NULL;
+    }
 
-    while (g_busy_frame_queue.front)
+    // Called with mStateLock held!
+    bool QualcommCameraHardware::initRaw(bool initJpegHeap)
     {
-       //dequeue from the busy queue
-       struct fifo_node *node  = dequeue (&g_busy_frame_queue);
-       if(node)
-           free(node);
+        LOGV("initRaw E");
+        startCameraIfNecessary();
+
+        // Tell libqcamera what the preview and raw dimensions are.  We
+        // call this method even if the preview dimensions have not changed,
+        // because the picture ones may have.
+        //
+        // NOTE: if this errors out, mCameraState != QCS_IDLE, which will be
+        //       checked by the caller of this method.
+
+        setCameraDimensions();
+
+        LOGV("initRaw: picture size=%dx%d",
+             mRawWidth, mRawHeight);
+
+        // Note that we enforce yuv420 in setParameters().
+
+        mRawSize =
+            mRawWidth * mRawHeight * 3 / 2; /* reality */
+
+        mJpegMaxSize = mRawWidth * mRawHeight * 2;
+
+        LOGV("initRaw: clearing old mJpegHeap.");
+        mJpegHeap = NULL;
+
+        LOGV("initRaw: initializing mRawHeap.");
+        mRawHeap =
+            new RawPmemPool("/dev/pmem_camera",
+                            kRawFrameHeaderSize + mJpegMaxSize, /* worst */
+                            kRawBufferCount,
+                            mRawSize,
+                            kRawFrameHeaderSize,
+                            "snapshot camera");
+
+        if (!mRawHeap->initialized()) {
+            LOGE("initRaw X failed: error initializing mRawHeap");
+            mRawHeap = NULL;
+            return false;
+        }
+
+        if (initJpegHeap) {
+            LOGV("initRaw: initializing mJpegHeap.");
+            mJpegHeap =
+                new AshmemPool(mJpegMaxSize,
+                               kJpegBufferCount,
+                               0, // we do not know how big the picture wil be
+                               0,
+                               "jpeg");
+            if (!mJpegHeap->initialized()) {
+                LOGE("initRaw X failed: error initializing mJpegHeap.");
+                mJpegHeap = NULL;
+                mRawHeap = NULL;
+                return false;
+            }
+        }
 
-       LOGV("cam_frame_flush_video: node \n");
+        LOGV("initRaw X success");
+        return true;
     }
-    pthread_mutex_unlock(&(g_busy_frame_queue.mut));
-    LOGV("cam_frame_flush_video: out n = %d\n", g_busy_frame_queue.num_of_frames);
-    return ;
-}
-/*===========================================================================
- * FUNCTION      cam_frame_get_video
- *
- * DESCRIPTION    this function returns a video frame from the head
- * ===========================================================================*/
-static struct msm_frame * cam_frame_get_video()
-{
-    struct msm_frame *p = NULL;
-    LOGV("cam_frame_get_video... in\n");
-    LOGV("cam_frame_get_video... got lock\n");
-    if (g_busy_frame_queue.front)
+
+    void QualcommCameraHardware::release()
     {
-        //dequeue
-       struct fifo_node *node  = dequeue (&g_busy_frame_queue);
-       if (node)
-       {
-           p = (struct msm_frame *)node->f;
-           free (node);
-       }
-       LOGV("cam_frame_get_video... out = %x\n", p->buffer);
+        LOGV("release E");
+
+        Mutex::Autolock l(&mLock);
+
+        // Either preview was ongoing, or we are in the middle or taking a
+        // picture.  It's the caller's responsibility to make sure the camera
+        // is in the idle or init state before destroying this object.
+
+        if (mCameraState != QCS_IDLE && mCameraState != QCS_INIT) {
+            LOGE("Serious error: the camera state is %s, "
+                 "not QCS_IDLE or QCS_INIT!",
+                 getCameraStateStr(mCameraState));
+        }
+        
+        mStateLock.lock();
+        if (mCameraState != QCS_INIT) {
+            // When libqcamera detects an error, it calls camera_cb from the
+            // call to LINK_camera_stop, which would cause a deadlock if we
+            // held the mStateLock.  For this reason, we have an intermediate
+            // state QCS_INTERNAL_STOPPING, which we use to check to see if the
+            // camera_cb was called inline.
+            mCameraState = QCS_INTERNAL_STOPPING;
+            mStateLock.unlock();
+
+            LOGV("stopping camera.");
+            LINK_camera_stop(stop_camera_cb, this);
+
+            mStateLock.lock();
+            if (mCameraState == QCS_INTERNAL_STOPPING) {
+                while (mCameraState != QCS_INIT &&
+                       mCameraState != QCS_ERROR) {
+                    LOGV("stopping camera: waiting for QCS_INIT");
+                    mStateWait.wait(mStateLock);
+                }
+            }
+
+            LOGV("Shutting REX down.");
+            LINK_rex_shutdown();
+            LOGV("REX has shut down.");
+#if DLOPEN_LIBQCAMERA
+            if (libqcamera) {
+                unsigned ref = ::dlclose(libqcamera);
+                LOGV("dlclose(libqcamera) refcount %d", ref);
+            }
+#endif
+            mCameraState = QCS_INIT;
+        }
+        mStateLock.unlock();
+
+        LOGV("release X");
     }
-    return p;
-}
 
-/*===========================================================================
- * FUNCTION      cam_frame_post_video
- *
- * DESCRIPTION    this function add a busy video frame to the busy queue tails
- * ===========================================================================*/
-static void cam_frame_post_video (struct msm_frame *p)
-{
-    if (!p)
+    QualcommCameraHardware::~QualcommCameraHardware()
     {
-        LOGE("post video , buffer is null");
-        return;
+        LOGV("~QualcommCameraHardware E");
+        Mutex::Autolock singletonLock(&singleton_lock);
+        singleton.clear();
+        LOGV("~QualcommCameraHardware X");
     }
-    LOGV("cam_frame_post_video... in = %x\n", (unsigned int)(p->buffer));
-    pthread_mutex_lock(&(g_busy_frame_queue.mut));
-    LOGV("post_video got lock. q count before enQ %d", g_busy_frame_queue.num_of_frames);
-    //enqueue to busy queue
-    struct fifo_node *node = (struct fifo_node *)malloc (sizeof (struct fifo_node));
-    if (node)
+
+    sp<IMemoryHeap> QualcommCameraHardware::getPreviewHeap() const
     {
-        LOGV(" post video , enqueing in busy queue");
-        node->f = p;
-        node->next = NULL;
-        enqueue (&g_busy_frame_queue, node);
-        LOGV("post_video got lock. q count after enQ %d", g_busy_frame_queue.num_of_frames);
+        LOGV("getPreviewHeap");
+        return mPreviewHeap != NULL ? mPreviewHeap->mHeap : NULL;
     }
-    else
+
+    sp<IMemoryHeap> QualcommCameraHardware::getRawHeap() const
     {
-        LOGE("cam_frame_post_video error... out of memory\n");
+        return mRawHeap != NULL ? mRawHeap->mHeap : NULL;
     }
 
-    pthread_mutex_unlock(&(g_busy_frame_queue.mut));
-    pthread_cond_signal(&(g_busy_frame_queue.wait));
+    bool QualcommCameraHardware::setCallbacks(
+        preview_callback pcb, void *puser,
+        recording_callback rcb, void *ruser)
+    {
+        Mutex::Autolock cbLock(&mCallbackLock);
+        mPreviewCallback = pcb;
+        mPreviewCallbackCookie = puser;
+        mRecordingCallback = rcb;
+        mRecordingCallbackCookie = ruser;
+        return mPreviewCallback != NULL ||
+            mRecordingCallback != NULL;
+    }
+
+    status_t QualcommCameraHardware::startPreviewInternal(
+        preview_callback pcb, void *puser,
+        recording_callback rcb, void *ruser)
+    {
+        LOGV("startPreview E");
 
-    LOGV("cam_frame_post_video... out = %x\n", p->buffer);
+        if (mCameraState == QCS_PREVIEW_IN_PROGRESS) {
+            LOGE("startPreview is already in progress, doing nothing.");
+            // We might want to change the callback functions while preview is
+            // streaming, for example to enable or disable recording.
+            setCallbacks(pcb, puser, rcb, ruser);
+            return NO_ERROR;
+        }
 
-    return;
-}
+        // We check for these two states explicitly because it is possible
+        // for startPreview() to be called in response to a raw or JPEG
+        // callback, but before we've updated the state from QCS_WAITING_RAW
+        // or QCS_WAITING_JPEG to QCS_IDLE.  This is because in camera_cb(),
+        // we update the state *after* we've made the callback.  See that
+        // function for an explanation.
 
-void QualcommCameraHardware::storeTargetType(void) {
-    char mDeviceName[PROPERTY_VALUE_MAX];
-    property_get("ro.product.device",mDeviceName," ");
-    mCurrentTarget = TARGET_MAX;
-    for( int i = 0; i < TARGET_MAX ; i++) {
-        if( !strncmp(mDeviceName, targetList[i].targetStr, 7)) {
-            mCurrentTarget = targetList[i].targetEnum;
-            break;
+        if (mCameraState == QCS_WAITING_RAW ||
+            mCameraState == QCS_WAITING_JPEG) {
+            while (mCameraState != QCS_IDLE &&
+                   mCameraState != QCS_ERROR) {
+                LOGV("waiting for QCS_IDLE");
+                mStateWait.wait(mStateLock);
+            }
         }
-    }
-    mCurrentTarget = TARGET_MSM7627;
-    LOGV(" Storing the current target type as %d ", mCurrentTarget );
-    return;
-}
 
-//-------------------------------------------------------------------------------------
-static Mutex singleton_lock;
-static bool singleton_releasing;
-static nsecs_t singleton_releasing_start_time;
-static const nsecs_t SINGLETON_RELEASING_WAIT_TIME = seconds_to_nanoseconds(5);
-static const nsecs_t SINGLETON_RELEASING_RECHECK_TIMEOUT = seconds_to_nanoseconds(1);
-static Condition singleton_wait;
-
-static void receive_camframe_callback(struct msm_frame *frame);
-static void receive_camframe_video_callback(struct msm_frame *frame); // 720p
-static void receive_jpeg_fragment_callback(uint8_t *buff_ptr, uint32_t buff_size);
-static void receive_jpeg_callback(jpeg_event_t status);
-static void receive_shutter_callback(common_crop_t *crop);
-static void receive_camframetimeout_callback(void);
-static int fb_fd = -1;
-static int32_t mMaxZoom = 0;
-static bool native_get_maxzoom(int camfd, void *pZm);
-
-static int dstOffset = 0;
-
-static int camerafd;
-pthread_t w_thread;
-
-void *opencamerafd(void *data) {
-    camerafd = open(MSM_CAMERA_CONTROL, O_RDWR);
-    return NULL;
-}
+        if (mCameraState != QCS_IDLE) {
+            LOGE("startPreview X Camera state is %s, expecting QCS_IDLE!",
+                getCameraStateStr(mCameraState));
+            return INVALID_OPERATION;
+        }
 
-/* When using MDP zoom, double the preview buffers. The usage of these
- * buffers is as follows:
- * 1. As all the buffers comes under a single FD, and at initial registration,
- * this FD will be passed to surface flinger, surface flinger can have access
- * to all the buffers when needed.
- * 2. Only "kPreviewBufferCount" buffers (SrcSet) will be registered with the
- * camera driver to receive preview frames. The remaining buffers (DstSet),
- * will be used at HAL and by surface flinger only when crop information
- * is present in the frame.
- * 3. When there is no crop information, there will be no call to MDP zoom,
- * and the buffers in SrcSet will be passed to surface flinger to display.
- * 4. With crop information present, MDP zoom will be called, and the final
- * data will be placed in a buffer from DstSet, and this buffer will be given
- * to surface flinger to display.
- */
-#define NUM_MORE_BUFS 2
-
-QualcommCameraHardware::QualcommCameraHardware()
-    : mParameters(),
-      mCameraRunning(false),
-      mPreviewInitialized(false),
-      mFrameThreadRunning(false),
-      mVideoThreadRunning(false),
-      mSnapshotThreadRunning(false),
-      mInSnapshotMode(false),
-      mJpegThreadRunning(false),
-      mSnapshotFormat(0),
-      mReleasedRecordingFrame(false),
-      mPreviewFrameSize(0),
-      mRawSize(0),
-      mCameraControlFd(-1),
-      mAutoFocusThreadRunning(false),
-      mAutoFocusFd(-1),
-      mBrightness(0),
-      mHJR(0),
-      mInPreviewCallback(false),
-      mUseOverlay(0),
-      mOverlay(0),
-      mMsgEnabled(0),
-      mNotifyCallback(0),
-      mDataCallback(0),
-      mDataCallbackTimestamp(0),
-      mCallbackCookie(0),
-      mInitialized(false),
-      mDebugFps(0)
-{
+        if (!initPreview()) {
+            LOGE("startPreview X initPreview failed.  Not starting preview.");
+            return UNKNOWN_ERROR;
+        }
 
-    // Start opening camera device in a separate thread/ Since this
-    // initializes the sensor hardware, this can take a long time. So,
-    // start the process here so it will be ready by the time it's
-    // needed.
-    if ((pthread_create(&w_thread, NULL, opencamerafd, NULL)) != 0) {
-        LOGE("Camera open thread creation failed");
-    }
+        setCallbacks(pcb, puser, rcb, ruser);
 
-    memset(&mDimension, 0, sizeof(mDimension));
-    memset(&mCrop, 0, sizeof(mCrop));
-    memset(&zoomCropInfo, 0, sizeof(zoom_crop_info));
-    storeTargetType();
-    char value[PROPERTY_VALUE_MAX];
-    property_get("persist.debug.sf.showfps", value, "0");
-    mDebugFps = atoi(value);
-    if( mCurrentTarget == TARGET_MSM7630 ) {
-        kPreviewBufferCountActual = kPreviewBufferCount;
-        kRecordBufferCount = RECORD_BUFFERS_7x30;
-        recordframes = new msm_frame[kRecordBufferCount];
-    }
-    else {
-        kPreviewBufferCountActual = kPreviewBufferCount + NUM_MORE_BUFS;
-        if( mCurrentTarget == TARGET_QSD8250 ) {
-            kRecordBufferCount = RECORD_BUFFERS_8x50;
-            recordframes = new msm_frame[kRecordBufferCount];
+        // hack to prevent first preview frame from being black
+        mPreviewCount = 0;
+
+        mCameraState = QCS_INTERNAL_PREVIEW_REQUESTED;
+        camera_ret_code_type qret =
+            LINK_camera_start_preview(camera_cb, this);
+        if (qret == CAMERA_SUCCESS) {
+            while(mCameraState != QCS_PREVIEW_IN_PROGRESS &&
+                  mCameraState != QCS_ERROR) {
+                LOGV("waiting for QCS_PREVIEW_IN_PROGRESS");
+                mStateWait.wait(mStateLock);
+            }
+        }
+        else {
+            LOGE("startPreview failed: sensor error.");
+            mCameraState = QCS_ERROR;
         }
-    }
 
-    switch(mCurrentTarget){
-        case TARGET_MSM7627:
-            jpegPadding = 8;
-            break;
-        case TARGET_QSD8250:
-        case TARGET_MSM7630:
-            jpegPadding = 0;
-            break;
-        default:
-            jpegPadding = 0;
-            break;
+        LOGV("startPreview X");
+        return mCameraState == QCS_PREVIEW_IN_PROGRESS ?
+            NO_ERROR : UNKNOWN_ERROR;
     }
-    LOGV("constructor EX");
-}
 
+    void QualcommCameraHardware::stopPreviewInternal()
+    {
+        LOGV("stopPreviewInternal E");
 
-void QualcommCameraHardware::filterPreviewSizes(){
+        if (mCameraState != QCS_PREVIEW_IN_PROGRESS) {
+            LOGE("Preview not in progress!");
+            return;
+        }
 
-    unsigned int boardMask = 0;
-    int prop = 0;
-    for(prop=0;prop<sizeof(boardProperties)/sizeof(board_property);prop++){
-        if(mCurrentTarget == boardProperties[prop].target){
-            boardMask = boardProperties[prop].previewSizeMask;
-            break;
+        if (mAutoFocusCallback != NULL) {
+            // WARNING: clear mAutoFocusCallback BEFORE you call
+            // camera_stop_focus.  The CAMERA_EXIT_CB_ABORT is (erroneously)
+            // delivered inline camera_stop_focus(), and we cannot acquire
+            // mStateLock, because that would cause a deadlock.  In any case,
+            // CAMERA_EXIT_CB_ABORT is delivered only when we call
+            // camera_stop_focus.
+            mAutoFocusCallback = NULL;
+            LINK_camera_stop_focus();
         }
-    }
 
-    if (!strcmp(mSensorInfo.name, "ov5642"))
-        boardMask = 0xff;
-
-    int bitMask = boardMask & sensorType->bitMask;
-    if(bitMask){
-        unsigned int mask = 1<<(PREVIEW_SIZE_COUNT-1);
-        previewSizeCount=0;
-        unsigned int i = 0;
-        while(mask){
-            if(mask&bitMask)
-                supportedPreviewSizes[previewSizeCount++] =
-                        preview_sizes[i];
-            i++;
-            mask = mask >> 1;
+        setCallbacks(NULL, NULL, NULL, NULL);
+        
+        mCameraState = QCS_INTERNAL_PREVIEW_STOPPING;
+
+        LINK_camera_stop_preview();
+        while (mCameraState != QCS_IDLE &&
+               mCameraState != QCS_ERROR)  {
+            LOGV("waiting for QCS_IDLE");
+            mStateWait.wait(mStateLock);
         }
+
+        LOGV("stopPreviewInternal: Freeing preview heap.");
+        mPreviewHeap = NULL;
+        mPreviewCallback = NULL;
+
+        LOGV("stopPreviewInternal: X Preview has stopped.");
     }
-}
 
-//filter Picture sizes based on max width and height
-void QualcommCameraHardware::filterPictureSizes(){
-    int i;
-    for(i=0;i<PICTURE_SIZE_COUNT;i++){
-        if(((picture_sizes[i].width <=
-                sensorType->max_supported_snapshot_width) &&
-           (picture_sizes[i].height <=
-                   sensorType->max_supported_snapshot_height))){
-            picture_sizes_ptr = picture_sizes + i;
-            supportedPictureSizesCount = PICTURE_SIZE_COUNT - i  ;
-            return ;
-        }
+    status_t QualcommCameraHardware::startPreview(
+        preview_callback pcb, void *puser)
+    {
+        Mutex::Autolock l(&mLock);
+        Mutex::Autolock stateLock(&mStateLock);
+        return startPreviewInternal(pcb, puser,
+                                    mRecordingCallback,
+                                    mRecordingCallbackCookie);
     }
-}
 
-void QualcommCameraHardware::initDefaultParameters()
-{
-    LOGV("initDefaultParameters E");
-
-    // Initialize constant parameter strings. This will happen only once in the
-    // lifetime of the mediaserver process.
-    if (!parameter_string_initialized) {
-        findSensorType();
-        antibanding_values = create_values_str(
-            antibanding, sizeof(antibanding) / sizeof(str_map));
-        effect_values = create_values_str(
-            effects, sizeof(effects) / sizeof(str_map));
-        autoexposure_values = create_values_str(
-            autoexposure, sizeof(autoexposure) / sizeof(str_map));
-        whitebalance_values = create_values_str(
-            whitebalance, sizeof(whitebalance) / sizeof(str_map));
-
-        //filter preview sizes
-        filterPreviewSizes();
-        preview_size_values = create_sizes_str(
-            supportedPreviewSizes, previewSizeCount);
-        //filter picture sizes
-        filterPictureSizes();
-        picture_size_values = create_sizes_str(
-                picture_sizes_ptr, supportedPictureSizesCount);
-
-        flash_values = create_values_str(
-            flash, sizeof(flash) / sizeof(str_map));
-        if(sensorType->hasAutoFocusSupport){
-            focus_mode_values = create_values_str(
-                    focus_modes, sizeof(focus_modes) / sizeof(str_map));
+    void QualcommCameraHardware::stopPreview() {
+        LOGV("stopPreview: E");
+        Mutex::Autolock l(&mLock);
+        if (!setCallbacks(NULL, NULL,
+                          mRecordingCallback,
+                          mRecordingCallbackCookie)) {
+            Mutex::Autolock statelock(&mStateLock);
+            stopPreviewInternal();
         }
-        iso_values = create_values_str(
-            iso,sizeof(iso)/sizeof(str_map));
-        lensshade_values = create_values_str(
-            lensshade,sizeof(lensshade)/sizeof(str_map));
-        picture_format_values = create_values_str(
-            picture_formats, sizeof(picture_formats)/sizeof(str_map));
-        preview_frame_rate_values = create_values_range_str(
-            MINIMUM_FPS, MAXIMUM_FPS);
-        parameter_string_initialized = true;
+        LOGV("stopPreview: X");
     }
 
-    mParameters.setPreviewSize(DEFAULT_PREVIEW_WIDTH, DEFAULT_PREVIEW_HEIGHT);
-    mDimension.display_width = DEFAULT_PREVIEW_WIDTH;
-    mDimension.display_height = DEFAULT_PREVIEW_HEIGHT;
-
-    mParameters.setPreviewFrameRate(DEFAULT_FPS);
-    if((strcmp(mSensorInfo.name, "vx6953")) &&
-        (strcmp(mSensorInfo.name, "VX6953")) &&
-        (strcmp(sensorType->name, "2mp"))){
-        mParameters.set(
-            CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES,
-            preview_frame_rate_values.string());
-    } else {
-        mParameters.set(
-            CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES,
-            DEFAULT_FPS);
-    }
-    mParameters.setPreviewFormat("yuv420sp"); // informative
-
-    mParameters.setPictureSize(DEFAULT_PICTURE_WIDTH, DEFAULT_PICTURE_HEIGHT);
-    mParameters.setPictureFormat("jpeg"); // informative
-
-    mParameters.set(CameraParameters::KEY_JPEG_QUALITY, "85"); // max quality
-    mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH,
-                    THUMBNAIL_WIDTH_STR); // informative
-    mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT,
-                    THUMBNAIL_HEIGHT_STR); // informative
-    mDimension.ui_thumbnail_width =
-            thumbnail_sizes[DEFAULT_THUMBNAIL_SETTING].width;
-    mDimension.ui_thumbnail_height =
-            thumbnail_sizes[DEFAULT_THUMBNAIL_SETTING].height;
-    mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
-
-    mParameters.set(CameraParameters::KEY_ANTIBANDING,
-                    CameraParameters::ANTIBANDING_OFF);
-    mParameters.set(CameraParameters::KEY_EFFECT,
-                    CameraParameters::EFFECT_NONE);
-    mParameters.set(CameraParameters::KEY_AUTO_EXPOSURE,
-                    CameraParameters::AUTO_EXPOSURE_FRAME_AVG);
-    mParameters.set(CameraParameters::KEY_WHITE_BALANCE,
-                    CameraParameters::WHITE_BALANCE_AUTO);
-    mParameters.set(CameraParameters::KEY_FOCUS_MODE,
-                    CameraParameters::FOCUS_MODE_AUTO);
-    mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS,
-                    "yuv420sp");
-
-    mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES,
-                    preview_size_values.string());
-    mParameters.set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES,
-                    picture_size_values.string());
-    mParameters.set(CameraParameters::KEY_SUPPORTED_ANTIBANDING,
-                    antibanding_values);
-    mParameters.set(CameraParameters::KEY_SUPPORTED_EFFECTS, effect_values);
-    mParameters.set(CameraParameters::KEY_SUPPORTED_AUTO_EXPOSURE, autoexposure_values);
-    mParameters.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE,
-                    whitebalance_values);
-    mParameters.set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES,
-                    focus_mode_values);
-    mParameters.set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS,
-                    picture_format_values);
-
-    if (mSensorInfo.flash_enabled) {
-        mParameters.set(CameraParameters::KEY_FLASH_MODE,
-                        CameraParameters::FLASH_MODE_OFF);
-        mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES,
-                        flash_values);
+    bool QualcommCameraHardware::previewEnabled() {
+        Mutex::Autolock l(&mLock);
+        return mCameraState == QCS_PREVIEW_IN_PROGRESS;
     }
 
-    mParameters.set(CameraParameters::KEY_MAX_SHARPNESS,
-            CAMERA_MAX_SHARPNESS);
-    mParameters.set(CameraParameters::KEY_MAX_CONTRAST,
-            CAMERA_MAX_CONTRAST);
-    mParameters.set(CameraParameters::KEY_MAX_SATURATION,
-            CAMERA_MAX_SATURATION);
-
-    mParameters.set("sharpness-max",
-            CAMERA_MAX_SHARPNESS);
-    mParameters.set("sharpness-def",
-            CAMERA_DEF_SHARPNESS);
-    mParameters.set("contrast-max",
-            CAMERA_MAX_CONTRAST);
-    mParameters.set("contrast-def",
-            CAMERA_DEF_CONTRAST);
-    mParameters.set("saturation-max",
-            CAMERA_MAX_SATURATION);
-    mParameters.set("saturation-def",
-            CAMERA_DEF_SATURATION);
-
-    mParameters.set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION,
-            CAMERA_MAX_EXPOSURE_COMPENSATION);
-    mParameters.set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION,
-            CAMERA_MIN_EXPOSURE_COMPENSATION);
-    mParameters.set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP,
-            CAMERA_EXPOSURE_COMPENSATION_STEP);
-
-    mParameters.set("luma-adaptation", "3");
-    mParameters.set("zoom-supported", "true");
-    mParameters.set("zoom-ratios", "100,105,110,115,120,125,130,135,140,145,150,155,160,165,170,175,180,185,190,195,200");
-    mParameters.set("max-zoom", MAX_ZOOM_LEVEL);
-    mParameters.set("zoom", 0);
-    mParameters.set(CameraParameters::KEY_PICTURE_FORMAT,
-                    CameraParameters::PIXEL_FORMAT_JPEG);
-
-    mParameters.set(CameraParameters::KEY_SHARPNESS,
-                    CAMERA_DEF_SHARPNESS);
-    mParameters.set(CameraParameters::KEY_CONTRAST,
-                    CAMERA_DEF_CONTRAST);
-    mParameters.set(CameraParameters::KEY_SATURATION,
-                    CAMERA_DEF_SATURATION);
-    mParameters.set(CameraParameters::KEY_EXPOSURE_COMPENSATION,
-                    CAMERA_DEF_EXPOSURE_COMPENSATION);
-
-    mParameters.set(CameraParameters::KEY_ISO_MODE,
-                    CameraParameters::ISO_AUTO);
-    mParameters.set(CameraParameters::KEY_LENSSHADE,
-                    CameraParameters::LENSSHADE_ENABLE);
-    mParameters.set(CameraParameters::KEY_SUPPORTED_ISO_MODES,
-                    iso_values);
-
-    if( (!strcmp(sensorType->name, "2mp")) ||
-        (!strcmp(mSensorInfo.name, "vx6953")) ||
-		(!strcmp(mSensorInfo.name, "ov5642")) ||
-		(!strcmp(mSensorInfo.name, "VX6953")) ) {
-        LOGI("Parameter Rolloff is not supported for this sensor");
-    } else {
-        mParameters.set(CameraParameters::KEY_SUPPORTED_LENSSHADE_MODES,
-                    lensshade_values);
+    status_t QualcommCameraHardware::startRecording(
+        recording_callback rcb, void *ruser)
+    {
+        Mutex::Autolock l(&mLock);
+        Mutex::Autolock stateLock(&mStateLock);
+        return startPreviewInternal(mPreviewCallback,
+                                    mPreviewCallbackCookie,
+                                    rcb, ruser);
     }
 
-    if (setParameters(mParameters) != NO_ERROR) {
-        LOGE("Failed to set default parameters?!");
+    void QualcommCameraHardware::stopRecording() {
+        LOGV("stopRecording: E");
+        Mutex::Autolock l(&mLock);
+        if (!setCallbacks(mPreviewCallback,
+                          mPreviewCallbackCookie,
+                          NULL, NULL)) {
+            Mutex::Autolock statelock(&mStateLock);
+            stopPreviewInternal();
+        }
+        LOGV("stopRecording: X");
     }
 
-    mUseOverlay = useOverlay();
-
-    /* Initialize the camframe_timeout_flag*/
-    Mutex::Autolock l(&mCamframeTimeoutLock);
-    camframe_timeout_flag = FALSE;
-    mPostViewHeap = NULL;
+    bool QualcommCameraHardware::recordingEnabled() {
+        Mutex::Autolock l(&mLock);
+        Mutex::Autolock stateLock(&mStateLock);
+        return mCameraState == QCS_PREVIEW_IN_PROGRESS &&
+            mRecordingCallback != NULL;
+    }
 
-    mInitialized = true;
+    void QualcommCameraHardware::releaseRecordingFrame(
+        const sp<IMemory>& mem __attribute__((unused)))
+    {
+        Mutex::Autolock l(&mLock);
+        LINK_camera_release_frame();
+    }
 
-    LOGV("initDefaultParameters X");
-}
+    status_t QualcommCameraHardware::autoFocus(autofocus_callback af_cb,
+                                               void *user)
+    {
+        LOGV("Starting auto focus.");
+        Mutex::Autolock l(&mLock);
+        Mutex::Autolock lock(&mStateLock);
 
-void QualcommCameraHardware::findSensorType(){
-    mDimension.picture_width = DEFAULT_PICTURE_WIDTH;
-    mDimension.picture_height = DEFAULT_PICTURE_HEIGHT;
-    bool ret = native_set_parm(CAMERA_SET_PARM_DIMENSION,
-                    sizeof(cam_ctrl_dimension_t), &mDimension);
-    if (ret) {
-        unsigned int i;
-        for (i = 0; i < sizeof(sensorTypes) / sizeof(SensorType); i++) {
-            if (sensorTypes[i].rawPictureHeight
-                    == mDimension.raw_picture_height) {
-                sensorType = sensorTypes + i;
-                return;
-            }
+        if (mCameraState != QCS_PREVIEW_IN_PROGRESS) {
+            LOGE("Invalid camera state %s: expecting QCS_PREVIEW_IN_PROGRESS,"
+                 " cannot start autofocus!",
+                 getCameraStateStr(mCameraState));
+            return INVALID_OPERATION;
         }
-    }
-    //default to 5 mp
-    LOGD("Failed to find a match for %d x %d, using 5M default",mDimension.raw_picture_width,mDimension.raw_picture_height);
-    sensorType = sensorTypes;
-    return;
-}
 
-#define ROUND_TO_PAGE(x)  (((x)+0xfff)&~0xfff)
+        if (mAutoFocusCallback != NULL) {
+            LOGV("Auto focus is already in progress");
+            return mAutoFocusCallback == af_cb ? NO_ERROR : INVALID_OPERATION;
+        }
 
-bool QualcommCameraHardware::startCamera()
-{
-    LOGV("startCamera E");
-    if( mCurrentTarget == TARGET_MAX ) {
-        LOGE(" Unable to determine the target type. Camera will not work ");
-        return false;
-    }
-#if DLOPEN_LIBMMCAMERA
-    libmmcamera = ::dlopen("liboemcamera.so", RTLD_NOW);
-    LOGV("loading liboemcamera at %p", libmmcamera);
-    if (!libmmcamera) {
-        LOGE("FATAL ERROR: could not dlopen liboemcamera.so: %s", dlerror());
-        return false;
+        mAutoFocusCallback = af_cb;
+        mAutoFocusCallbackCookie = user;
+        LINK_camera_start_focus(CAMERA_AUTO_FOCUS, camera_cb, this);
+        return NO_ERROR;
     }
 
-    *(void **)&LINK_cam_frame =
-        ::dlsym(libmmcamera, "cam_frame");
-    *(void **)&LINK_camframe_terminate =
-        ::dlsym(libmmcamera, "camframe_terminate");
-
-    *(void **)&LINK_jpeg_encoder_init =
-        ::dlsym(libmmcamera, "jpeg_encoder_init");
+    status_t QualcommCameraHardware::takePicture(shutter_callback shutter_cb,
+                                                 raw_callback raw_cb,
+                                                 jpeg_callback jpeg_cb,
+                                                 void* user)
+    {
+        LOGV("takePicture: E raw_cb = %p, jpeg_cb = %p",
+             raw_cb, jpeg_cb);
+        print_time();
+
+        Mutex::Autolock l(&mLock);
+        Mutex::Autolock stateLock(&mStateLock);
+
+        qualcomm_camera_state last_state = mCameraState;
+        if (mCameraState == QCS_PREVIEW_IN_PROGRESS) {
+            stopPreviewInternal();
+        }
+
+        // We check for these two states explicitly because it is possible
+        // for takePicture() to be called in response to a raw or JPEG
+        // callback, but before we've updated the state from QCS_WAITING_RAW
+        // or QCS_WAITING_JPEG to QCS_IDLE.  This is because in camera_cb(),
+        // we update the state *after* we've made the callback.  See that
+        // function for an explanation why.
+
+        if (mCameraState == QCS_WAITING_RAW ||
+            mCameraState == QCS_WAITING_JPEG) {
+            while (mCameraState != QCS_IDLE &&
+                   mCameraState != QCS_ERROR) {
+                LOGV("waiting for QCS_IDLE");
+                mStateWait.wait(mStateLock);
+            }
+        }
 
-    *(void **)&LINK_jpeg_encoder_encode =
-        ::dlsym(libmmcamera, "jpeg_encoder_encode");
+        if (mCameraState != QCS_IDLE) {
+            LOGE("takePicture: %sunexpected state %d, expecting QCS_IDLE",
+                 (last_state == QCS_PREVIEW_IN_PROGRESS ?
+                  "(stop preview) " : ""),
+                 mCameraState);
+            // If we had to stop preview in order to take a picture, and
+            // we failed to transition to a QCS_IDLE state, that's because
+            // of an internal error.
+            return last_state == QCS_PREVIEW_IN_PROGRESS ?
+                UNKNOWN_ERROR :
+                INVALID_OPERATION;
+        }
 
-    *(void **)&LINK_jpeg_encoder_join =
-        ::dlsym(libmmcamera, "jpeg_encoder_join");
+        if (!initRaw(jpeg_cb != NULL)) {
+            LOGE("initRaw failed.  Not taking picture.");
+            return UNKNOWN_ERROR;
+        }
 
-    *(void **)&LINK_mmcamera_camframe_callback =
-        ::dlsym(libmmcamera, "mmcamera_camframe_callback");
+        if (mCameraState != QCS_IDLE) {
+            LOGE("takePicture: (init raw) "
+                 "unexpected state %d, expecting QCS_IDLE",
+                mCameraState);
+            // If we had to stop preview in order to take a picture, and
+            // we failed to transition to a QCS_IDLE state, that's because
+            // of an internal error.
+            return last_state == QCS_PREVIEW_IN_PROGRESS ?
+                UNKNOWN_ERROR :
+                INVALID_OPERATION;
+        }
 
-    *LINK_mmcamera_camframe_callback = receive_camframe_callback;
+        {
+            Mutex::Autolock cbLock(&mCallbackLock);
+            mShutterCallback = shutter_cb;
+            mRawPictureCallback = raw_cb;
+            mJpegPictureCallback = jpeg_cb;
+            mPictureCallbackCookie = user;
+        }
 
-    *(void **)&LINK_mmcamera_jpegfragment_callback =
-        ::dlsym(libmmcamera, "mmcamera_jpegfragment_callback");
+        mCameraState = QCS_INTERNAL_RAW_REQUESTED;
 
-    *LINK_mmcamera_jpegfragment_callback = receive_jpeg_fragment_callback;
+        LINK_camera_take_picture(camera_cb, this);
 
-    *(void **)&LINK_mmcamera_jpeg_callback =
-        ::dlsym(libmmcamera, "mmcamera_jpeg_callback");
+        // It's possible for the YUV callback as well as the JPEG callbacks
+        // to be invoked before we even make it here, so we check for all
+        // possible result states from takePicture.
 
-    *LINK_mmcamera_jpeg_callback = receive_jpeg_callback;
+        while (mCameraState != QCS_WAITING_RAW &&
+               mCameraState != QCS_WAITING_JPEG &&
+               mCameraState != QCS_IDLE &&
+               mCameraState != QCS_ERROR)  {
+            LOGV("takePicture: waiting for QCS_WAITING_RAW or QCS_WAITING_JPEG");
+            mStateWait.wait(mStateLock);
+            LOGV("takePicture: woke up, state is %s",
+                 getCameraStateStr(mCameraState));
+        }
 
-    *(void **)&LINK_camframe_timeout_callback =
-        ::dlsym(libmmcamera, "camframe_timeout_callback");
+        LOGV("takePicture: X");
+        print_time();
+        return mCameraState != QCS_ERROR ?
+            NO_ERROR : UNKNOWN_ERROR;
+    }
 
-    *LINK_camframe_timeout_callback = receive_camframetimeout_callback;
+    status_t QualcommCameraHardware::cancelPicture(
+        bool cancel_shutter, bool cancel_raw, bool cancel_jpeg)
+    {
+        LOGV("cancelPicture: E cancel_shutter = %d, cancel_raw = %d, cancel_jpeg = %d",
+             cancel_shutter, cancel_raw, cancel_jpeg);
+        Mutex::Autolock l(&mLock);
+        Mutex::Autolock stateLock(&mStateLock);
+
+        switch (mCameraState) {
+        case QCS_INTERNAL_RAW_REQUESTED:
+        case QCS_WAITING_RAW:
+        case QCS_WAITING_JPEG:
+            LOGV("camera state is %s, stopping picture.",
+                 getCameraStateStr(mCameraState));
 
-    // 720 p new recording functions
-    *(void **)&LINK_cam_frame_flush_free_video = ::dlsym(libmmcamera, "cam_frame_flush_free_video");
+            {
+                Mutex::Autolock cbLock(&mCallbackLock);
+                if (cancel_shutter) mShutterCallback = NULL;
+                if (cancel_raw) mRawPictureCallback = NULL;
+                if (cancel_jpeg) mJpegPictureCallback = NULL;
+            }
 
-    *(void **)&LINK_camframe_free_video = ::dlsym(libmmcamera, "cam_frame_add_free_video");
+            while (mCameraState != QCS_IDLE &&
+                   mCameraState != QCS_ERROR)  {
+                LOGV("cancelPicture: waiting for QCS_IDLE");
+                mStateWait.wait(mStateLock);
+            }
+            break;
+        default:
+            LOGV("not taking a picture (state %s)",
+                 getCameraStateStr(mCameraState));
+        }
 
-    *(void **)&LINK_camframe_video_callback = ::dlsym(libmmcamera, "mmcamera_camframe_videocallback");
-        *LINK_camframe_video_callback = receive_camframe_video_callback;
+        LOGV("cancelPicture: X");
+        return NO_ERROR;
+    }
 
-    *(void **)&LINK_mmcamera_shutter_callback =
-        ::dlsym(libmmcamera, "mmcamera_shutter_callback");
+    status_t QualcommCameraHardware::setParameters(
+        const CameraParameters& params)
+    {
+        LOGV("setParameters: E params = %p", &params);
+
+        Mutex::Autolock l(&mLock);
+        Mutex::Autolock lock(&mStateLock);
+
+        // FIXME: verify params
+        // yuv422sp is here only for legacy reason. Unfortunately, we release
+        // the code with yuv422sp as the default and enforced setting. The
+        // correct setting is yuv420sp.
+        if ((strcmp(params.getPreviewFormat(), "yuv420sp") != 0) &&
+                (strcmp(params.getPreviewFormat(), "yuv422sp") != 0)) {
+            LOGE("Only yuv420sp preview is supported");
+            return INVALID_OPERATION;
+        }
+
+        // FIXME: will this make a deep copy/do the right thing? String8 i
+        // should handle it
+        
+        mParameters = params;
+        
+        // libqcamera only supports certain size/aspect ratios
+        // find closest match that doesn't exceed app's request
+        int width, height;
+        params.getPreviewSize(&width, &height);
+        LOGV("requested size %d x %d", width, height);
+        preview_size_type* ps = preview_sizes;
+        size_t i;
+        for (i = 0; i < PREVIEW_SIZE_COUNT; ++i, ++ps) {
+            if (width >= ps->width && height >= ps->height) break;
+        }
+        // app requested smaller size than supported, use smallest size
+        if (i == PREVIEW_SIZE_COUNT) ps--;
+        LOGV("actual size %d x %d", ps->width, ps->height);
+        mParameters.setPreviewSize(ps->width, ps->height);
+
+        mParameters.getPreviewSize(&mPreviewWidth, &mPreviewHeight);
+        mParameters.getPictureSize(&mRawWidth, &mRawHeight);
+
+        mPreviewWidth = (mPreviewWidth + 1) & ~1;
+        mPreviewHeight = (mPreviewHeight + 1) & ~1;
+        mRawHeight = (mRawHeight + 1) & ~1;
+        mRawWidth = (mRawWidth + 1) & ~1;
+
+        initCameraParameters();
+
+        LOGV("setParameters: X mCameraState=%d", mCameraState);
+        return mCameraState == QCS_IDLE ?
+            NO_ERROR : UNKNOWN_ERROR;
+    }
+
+    CameraParameters QualcommCameraHardware::getParameters() const
+    {
+        LOGV("getParameters: EX");
+        return mParameters;
+    }
 
-    *LINK_mmcamera_shutter_callback = receive_shutter_callback;
+    static CameraInfo sCameraInfo[] = {
+        {
+            CAMERA_FACING_BACK,
+            90,  /* orientation */
+        }
+    };
 
-    *(void**)&LINK_jpeg_encoder_setMainImageQuality =
-        ::dlsym(libmmcamera, "jpeg_encoder_setMainImageQuality");
+    extern "C" int HAL_getNumberOfCameras()
+    {
+        return sizeof(sCameraInfo) / sizeof(sCameraInfo[0]);
+    }
 
-    *(void**)&LINK_jpeg_encoder_setThumbnailQuality =
-        ::dlsym(libmmcamera, "jpeg_encoder_setThumbnailQuality");
+    extern "C" void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
+    {
+        memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(CameraInfo));
+    }
 
-    *(void**)&LINK_jpeg_encoder_setRotation =
-        ::dlsym(libmmcamera, "jpeg_encoder_setRotation");
+    extern "C" sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
+    {
+        LOGV("openCameraHardware: call createInstance");
+        return QualcommCameraHardware::createInstance();
+    }
 
-/* Disabling until support is available.
-    *(void**)&LINK_jpeg_encoder_setLocation =
-        ::dlsym(libmmcamera, "jpeg_encoder_setLocation");
-*/
-    *(void **)&LINK_cam_conf =
-        ::dlsym(libmmcamera, "cam_conf");
+    wp<QualcommCameraHardware> QualcommCameraHardware::singleton;
 
-/* Disabling until support is available.
-    *(void **)&LINK_default_sensor_get_snapshot_sizes =
-        ::dlsym(libmmcamera, "default_sensor_get_snapshot_sizes");
-*/
-    *(void **)&LINK_launch_cam_conf_thread =
-        ::dlsym(libmmcamera, "launch_cam_conf_thread");
+    // If the hardware already exists, return a strong pointer to the current
+    // object. If not, create a new hardware object, put it in the singleton,
+    // and return it.
+    sp<CameraHardwareInterface> QualcommCameraHardware::createInstance()
+    {
+        LOGV("createInstance: E");
+
+        singleton_lock.lock();
+        if (singleton != 0) {
+            sp<CameraHardwareInterface> hardware = singleton.promote();
+            if (hardware != 0) {
+                LOGV("createInstance: X return existing hardware=%p",
+                     &(*hardware));
+                singleton_lock.unlock();
+                return hardware;
+            }
+        }
 
-    *(void **)&LINK_release_cam_conf_thread =
-        ::dlsym(libmmcamera, "release_cam_conf_thread");
+        {
+            struct stat st;
+            int rc = stat("/dev/oncrpc", &st);
+            if (rc < 0) {
+                LOGV("createInstance: X failed to create hardware: %s",
+                     strerror(errno));
+                singleton_lock.unlock();
+                return NULL;
+            }
+        }
 
-/* Disabling until support is available.
-    *(void **)&LINK_zoom_crop_upscale =
-        ::dlsym(libmmcamera, "zoom_crop_upscale");
-*/
+        QualcommCameraHardware *cam = new QualcommCameraHardware();
+        sp<QualcommCameraHardware> hardware(cam);
+        singleton = hardware;
+        singleton_lock.unlock();
 
-#else
-    mmcamera_camframe_callback = receive_camframe_callback;
-    mmcamera_jpegfragment_callback = receive_jpeg_fragment_callback;
-    mmcamera_jpeg_callback = receive_jpeg_callback;
-    mmcamera_shutter_callback = receive_shutter_callback;
-#endif // DLOPEN_LIBMMCAMERA
-
-    /* The control thread is in libcamera itself. */
-    if (pthread_join(w_thread, NULL) != 0) {
-        LOGE("Camera open thread exit failed");
-        return false;
+        // initDefaultParameters() will cause the camera_cb() to be called.
+        // Since the latter tries to promote the singleton object to make sure
+        // it still exists, we need to call this function after we have set the
+        // singleton.
+        cam->initDefaultParameters();
+        LOGV("createInstance: X created hardware=%p", &(*hardware));
+        return hardware;
     }
-    mCameraControlFd = camerafd;
 
-    if (mCameraControlFd < 0) {
-        LOGE("startCamera X: %s open failed: %s!",
-             MSM_CAMERA_CONTROL,
-             strerror(errno));
-        return false;
+    // For internal use only, hence the strong pointer to the derived type.
+    sp<QualcommCameraHardware> QualcommCameraHardware::getInstance()
+    {
+        Mutex::Autolock singletonLock(&singleton_lock);
+        sp<CameraHardwareInterface> hardware = singleton.promote();
+        return (hardware != 0) ?
+            sp<QualcommCameraHardware>(static_cast<QualcommCameraHardware*>
+                                       (hardware.get())) :
+            NULL;
     }
 
-    if( mCurrentTarget != TARGET_MSM7630 ){
-        fb_fd = open("/dev/graphics/fb0", O_RDWR);
-        if (fb_fd < 0) {
-            LOGE("startCamera: fb0 open failed: %s!", strerror(errno));
-            return FALSE;
+    void* QualcommCameraHardware::get_preview_mem(uint32_t size,
+                                                  uint32_t *phy_addr,
+                                                  uint32_t index)
+    {
+        if (mPreviewHeap != NULL && mPreviewHeap->mHeap != NULL) {
+            uint8_t *base = (uint8_t *)mPreviewHeap->mHeap->base();
+            if (base && size <= mPreviewHeap->mSize.len) {
+                // For preview, associate the memory with the VFE task in the
+                // DSP.  This way, when the DSP gets a command that has a
+                // physical address, it knows which pmem region to patch it
+                // against.
+                uint32_t vaddr = (uint32_t)(base + size*index);
+
+                LOGV("get_preview_mem: base %p MALLOC size %d index %d --> %p",
+                     base, size, index, (void *)vaddr);
+                *phy_addr = vaddr;
+                return (void *)vaddr;
+            }
         }
+        LOGV("get_preview_mem: X NULL");
+        return NULL;
     }
 
-    /* This will block until the control thread is launched. After that, sensor
-     * information becomes available.
-     */
-
-    if (LINK_launch_cam_conf_thread()) {
-        LOGE("failed to launch the camera config thread");
-        return false;
+    void QualcommCameraHardware::free_preview_mem(uint32_t *phy_addr,
+                                                  uint32_t size,
+                                                  uint32_t index)
+    {
+        LOGV("free_preview_mem: EX NOP");
+        return;
     }
 
-    memset(&mSensorInfo, 0, sizeof(mSensorInfo));
-    if (ioctl(mCameraControlFd,
-              MSM_CAM_IOCTL_GET_SENSOR_INFO,
-              &mSensorInfo) < 0)
-        LOGW("%s: cannot retrieve sensor info!", __FUNCTION__);
-    else
-        LOGI("%s: camsensor name %s, flash %d", __FUNCTION__,
-             mSensorInfo.name, mSensorInfo.flash_enabled);
-/* Disabling until support is available.
-    picture_sizes = LINK_default_sensor_get_snapshot_sizes(&PICTURE_SIZE_COUNT);
-    if (!picture_sizes || !PICTURE_SIZE_COUNT) {
-        LOGE("startCamera X: could not get snapshot sizes");
-        return false;
-    }
-*/
-    LOGV("startCamera X");
-    return true;
-}
-
-status_t QualcommCameraHardware::dump(int fd,
-                                      const Vector<String16>& args) const
-{
-    const size_t SIZE = 256;
-    char buffer[SIZE];
-    String8 result;
-
-    // Dump internal primitives.
-    result.append("QualcommCameraHardware::dump");
-    snprintf(buffer, 255, "mMsgEnabled (%d)\n", mMsgEnabled);
-    result.append(buffer);
-    int width, height;
-    mParameters.getPreviewSize(&width, &height);
-    snprintf(buffer, 255, "preview width(%d) x height (%d)\n", width, height);
-    result.append(buffer);
-    mParameters.getPictureSize(&width, &height);
-    snprintf(buffer, 255, "raw width(%d) x height (%d)\n", width, height);
-    result.append(buffer);
-    snprintf(buffer, 255,
-             "preview frame size(%d), raw size (%d), jpeg size (%d) "
-             "and jpeg max size (%d)\n", mPreviewFrameSize, mRawSize,
-             mJpegSize, mJpegMaxSize);
-    result.append(buffer);
-    write(fd, result.string(), result.size());
-
-    // Dump internal objects.
-    if (mPreviewHeap != 0) {
-        mPreviewHeap->dump(fd, args);
-    }
-    if (mRawHeap != 0) {
-        mRawHeap->dump(fd, args);
-    }
-    if (mJpegHeap != 0) {
-        mJpegHeap->dump(fd, args);
+    void* QualcommCameraHardware::get_raw_mem(uint32_t size,
+                                                   uint32_t *phy_addr,
+                                                   uint32_t index)
+    {
+        if (mRawHeap != NULL && mRawHeap->mHeap != NULL) {
+            uint8_t *base = (uint8_t *)mRawHeap->mHeap->base();
+            if (base && size <= mRawHeap->mSize.len) {
+                // For raw snapshot, associate the memory with the VFE and LPM
+                // tasks in the DSP.  This way, when the DSP gets a command
+                // that has a physical address, it knows which pmem region to
+                // patch it against.
+                uint32_t vaddr = (uint32_t)(base + size*index);
+
+                LOGV("get_raw_mem: base %p MALLOC size %d index %d --> %p",
+                     base, size, index, (void *)vaddr);
+                *phy_addr = vaddr;
+                return (void *)vaddr;
+            }
+        }
+        LOGV("get_raw_mem: X NULL");
+        return NULL;
     }
-    mParameters.dump(fd, args);
-    return NO_ERROR;
-}
 
-static bool native_get_maxzoom(int camfd, void *pZm)
-{
-    LOGV("native_get_maxzoom E");
-
-    struct msm_ctrl_cmd ctrlCmd;
-    int32_t *pZoom = (int32_t *)pZm;
-
-    ctrlCmd.type       = CAMERA_GET_PARM_MAXZOOM;
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.length     = sizeof(int32_t);
-    ctrlCmd.value      = pZoom;
-    ctrlCmd.resp_fd    = camfd;
-
-    if (ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd) < 0) {
-        LOGE("native_get_maxzoom: ioctl fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
+    void QualcommCameraHardware::free_raw_mem(uint32_t *phy_addr,
+                                              uint32_t size,
+                                              uint32_t index)
+    {
+        LOGV("free_raw_mem: EX NOP");
+        return;
     }
-    LOGD("ctrlCmd.value = %d", *(int32_t *)ctrlCmd.value);
-    memcpy(pZoom, (int32_t *)ctrlCmd.value, sizeof(int32_t));
-
-    LOGV("native_get_maxzoom X");
-    return true;
-}
-
-static bool native_set_afmode(int camfd, isp3a_af_mode_t af_type)
-{
-    int rc;
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.type = CAMERA_SET_PARM_AUTO_FOCUS;
-    ctrlCmd.length = sizeof(af_type);
-    ctrlCmd.value = &af_type;
-    ctrlCmd.resp_fd = camfd; // FIXME: this will be put in by the kernel
-
-    if ((rc = ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd)) < 0)
-        LOGE("native_set_afmode: ioctl fd %d error %s\n",
-             camfd,
-             strerror(errno));
-
-    LOGV("native_set_afmode: ctrlCmd.status == %d\n", ctrlCmd.status);
-    return rc >= 0 && ctrlCmd.status == CAMERA_EXIT_CB_DONE;
-}
 
-static bool native_cancel_afmode(int camfd, int af_fd)
-{
-    int rc;
-    struct msm_ctrl_cmd ctrlCmd;
+    void QualcommCameraHardware::receivePreviewFrame(camera_frame_type *frame)
+    {
+        Mutex::Autolock cbLock(&mCallbackLock);
 
-    ctrlCmd.timeout_ms = 0;
-    ctrlCmd.type = CAMERA_AUTO_FOCUS_CANCEL;
-    ctrlCmd.length = 0;
-    ctrlCmd.value = NULL;
-    ctrlCmd.resp_fd = -1; // there's no response fd
+        // Ignore the first frame--there is a bug in the VFE pipeline and that
+        // frame may be bad.
+        if (++mPreviewCount == 1) {
+            LINK_camera_release_frame();
+            return;
+        }
 
-    if ((rc = ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND_2, &ctrlCmd)) < 0)
-    {
-        LOGE("native_cancel_afmode: ioctl fd %d error %s\n",
-             camfd,
-             strerror(errno));
-        return false;
+        // Find the offset within the heap of the current buffer.
+        ssize_t offset = (uint32_t)frame->buf_Virt_Addr;
+        offset -= (uint32_t)mPreviewHeap->mHeap->base();
+        ssize_t frame_size = kRawFrameHeaderSize + frame->dx * frame->dy * 2;
+        if (offset + frame_size <=
+                (ssize_t)mPreviewHeap->mHeap->virtualSize()) {
+#if 0
+            // frame->buffer includes the header, frame->buf_Virt_Addr skips it
+            LOGV("PREVIEW FRAME CALLBACK "
+                 "base %p addr %p offset %ld "
+                 "framesz %dx%d=%ld (expect %d) rotation %d "
+                 "(index %ld) size %d header_size 0x%x",
+                 mPreviewHeap->mHeap->base(),
+                 frame->buf_Virt_Addr,
+                 offset,
+                 frame->dx, frame->dy,
+                 frame_size,
+                 mPreviewFrameSize,
+                 frame->rotation,
+                 offset / frame_size,
+                 mPreviewFrameSize, frame->header_size);
+#endif
+            offset /= frame_size;
+            if (mPreviewCallback != NULL)
+                mPreviewCallback(mPreviewHeap->mBuffers[offset],
+                                 mPreviewCallbackCookie);
+            if (mRecordingCallback != NULL)
+                mRecordingCallback(mPreviewHeap->mBuffers[offset],
+                                   mRecordingCallbackCookie);
+            else {
+                // When we are doing preview but not recording, we need to
+                // release every preview frame immediately so that the next
+                // preview frame is delivered.  However, when we are recording
+                // (whether or not we are also streaming the preview frames to
+                // the screen), we have the user explicitly release a preview
+                // frame via method releaseRecordingFrame().  In this way we
+                // allow a video encoder which is potentially slower than the
+                // preview stream to skip frames.  Note that we call
+                // LINK_camera_release_frame() in this method because we first
+                // need to check to see if mPreviewCallback != NULL, which
+                // requires holding mCallbackLock.
+                LINK_camera_release_frame();
+            }
+        }
+        else LOGE("Preview frame virtual address %p is out of range!",
+                  frame->buf_Virt_Addr);
     }
 
-    return true;
-}
+    void
+    QualcommCameraHardware::notifyShutter()
+    {
+        LOGV("notifyShutter: E");
+        print_time();
+        Mutex::Autolock lock(&mStateLock);
+        if (mShutterCallback)
+            mShutterCallback(mPictureCallbackCookie);
+        print_time();
+        LOGV("notifyShutter: X");
+    }
+
+    // Pass the pre-LPM raw picture to raw picture callback.
+    // This method is called by a libqcamera thread, different from the one on
+    // which startPreview() or takePicture() are called.
+    void QualcommCameraHardware::receiveRawPicture(camera_frame_type *frame)
+    {
+        LOGV("receiveRawPicture: E");
+        print_time();
 
-static bool native_start_preview(int camfd)
-{
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.type       = CAMERA_START_PREVIEW;
-    ctrlCmd.length     = 0;
-    ctrlCmd.resp_fd    = camfd; // FIXME: this will be put in by the kernel
-
-    if (ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd) < 0) {
-        LOGE("native_start_preview: MSM_CAM_IOCTL_CTRL_COMMAND fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
-    }
+        Mutex::Autolock cbLock(&mCallbackLock);
 
-    return true;
-}
+        if (mRawPictureCallback != NULL) {
+            // FIXME: WHY IS buf_Virt_Addr ZERO??
+            frame->buf_Virt_Addr = (uint32_t*)frame->buffer;
 
-static bool native_get_picture (int camfd, common_crop_t *crop)
-{
-    struct msm_ctrl_cmd ctrlCmd;
+            // Find the offset within the heap of the current buffer.
+            ssize_t offset = (uint32_t)frame->buf_Virt_Addr;
+            offset -= (uint32_t)mRawHeap->mHeap->base();
+            ssize_t frame_size = kRawFrameHeaderSize +
+                frame->captured_dx * frame->captured_dy * 2;
 
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.length     = sizeof(common_crop_t);
-    ctrlCmd.value      = crop;
+            if (offset + frame_size <=
+                (ssize_t)mRawHeap->mHeap->virtualSize()) {
+#if 0
+                // frame->buffer includes the header, frame->buf_Virt_Addr
+                // skips it.
+                LOGV("receiveRawPicture: RAW CALLBACK (CB %p) "
+                     "base %p addr %p buffer %p offset %ld "
+                     "framesz %dx%d=%ld (expect %d) rotation %d "
+                     "(index %ld) size %d header_size 0x%x",
+                     mRawPictureCallback,
+                     mRawHeap->mHeap->base(),
+                     frame->buf_Virt_Addr,
+                     frame->buffer,
+                     offset,
+                     frame->captured_dx, frame->captured_dy,
+                     frame_size,
+                     mRawSize,
+                     frame->rotation,
+                     offset / frame_size,
+                     mRawSize, frame->header_size);
+#endif
+                offset /= frame_size;
+                mRawPictureCallback(mRawHeap->mBuffers[offset],
+                                    mPictureCallbackCookie);
+            }
+            else LOGE("receiveRawPicture: virtual address %p is out of range!",
+                      frame->buf_Virt_Addr);
+        }
+        else LOGV("Raw-picture callback was canceled--skipping.");
 
-    if(ioctl(camfd, MSM_CAM_IOCTL_GET_PICTURE, &ctrlCmd) < 0) {
-        LOGE("native_get_picture: MSM_CAM_IOCTL_GET_PICTURE fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
+        print_time();
+        LOGV("receiveRawPicture: X");
     }
 
-    LOGV("crop: in1_w %d", crop->in1_w);
-    LOGV("crop: in1_h %d", crop->in1_h);
-    LOGV("crop: out1_w %d", crop->out1_w);
-    LOGV("crop: out1_h %d", crop->out1_h);
+    // Encode the post-LPM raw picture.
+    // This method is called by a libqcamera thread, different from the one on
+    // which startPreview() or takePicture() are called.
 
-    LOGV("crop: in2_w %d", crop->in2_w);
-    LOGV("crop: in2_h %d", crop->in2_h);
-    LOGV("crop: out2_w %d", crop->out2_w);
-    LOGV("crop: out2_h %d", crop->out2_h);
+    void
+    QualcommCameraHardware::receivePostLpmRawPicture(camera_frame_type *frame)
+    {
+        LOGV("receivePostLpmRawPicture: E");
+        print_time();
+        qualcomm_camera_state new_state = QCS_ERROR;
+
+        Mutex::Autolock cbLock(&mCallbackLock);
+
+        if (mJpegPictureCallback != NULL) {
+
+            bool encode_location = true;
+
+#define PARSE_LOCATION(what,type,fmt,desc) do {                                           \
+                pt.what = 0;                                                              \
+                const char *what##_str = mParameters.get("gps-"#what);                    \
+                LOGV("receiveRawPicture: GPS PARM %s --> [%s]", "gps-"#what, what##_str); \
+                if (what##_str) {                                                         \
+                    type what = 0;                                                        \
+                    if (sscanf(what##_str, fmt, &what) == 1)                              \
+                        pt.what = what;                                                   \
+                    else {                                                                \
+                        LOGE("GPS " #what " %s could not"                                 \
+                              " be parsed as a " #desc,                                   \
+                              what##_str);                                                \
+                        encode_location = false;                                          \
+                    }                                                                     \
+                }                                                                         \
+                else {                                                                    \
+                    LOGW("receiveRawPicture: GPS " #what " not specified: "               \
+                          "defaulting to zero in EXIF header.");                          \
+                    encode_location = false;                                              \
+               }                                                                          \
+            } while(0)
+
+            PARSE_LOCATION(timestamp, long, "%ld", "long");
+            if (!pt.timestamp) pt.timestamp = time(NULL);
+            PARSE_LOCATION(altitude, short, "%hd", "short");
+            PARSE_LOCATION(latitude, double, "%lf", "double float");
+            PARSE_LOCATION(longitude, double, "%lf", "double float");
 
-    LOGV("crop: update %d", crop->update_flag);
+#undef PARSE_LOCATION
 
-    return true;
-}
+            if (encode_location) {
+                LOGV("receiveRawPicture: setting image location ALT %d LAT %lf LON %lf",
+                     pt.altitude, pt.latitude, pt.longitude);
+                if (LINK_camera_set_position(&pt, NULL, NULL) != CAMERA_SUCCESS) {
+                    LOGE("receiveRawPicture: camera_set_position: error");
+                    /* return; */ // not a big deal
+                }
+            }
+            else LOGV("receiveRawPicture: not setting image location");
 
-static bool native_stop_preview(int camfd)
-{
-    struct msm_ctrl_cmd ctrlCmd;
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.type       = CAMERA_STOP_PREVIEW;
-    ctrlCmd.length     = 0;
-    ctrlCmd.resp_fd    = camfd; // FIXME: this will be put in by the kernel
-
-    if(ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd) < 0) {
-        LOGE("native_stop_preview: ioctl fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
-    }
+            mJpegSize = 0;
+            camera_handle.device = CAMERA_DEVICE_MEM;
+            camera_handle.mem.encBuf_num =  MAX_JPEG_ENCODE_BUF_NUM;
 
-    return true;
-}
+            for (int cnt = 0; cnt < MAX_JPEG_ENCODE_BUF_NUM; cnt++) {
+                camera_handle.mem.encBuf[cnt].buffer = (uint8_t *)
+                    malloc(MAX_JPEG_ENCODE_BUF_LEN);
+                camera_handle.mem.encBuf[cnt].buf_len =
+                    MAX_JPEG_ENCODE_BUF_LEN;
+                camera_handle.mem.encBuf[cnt].used_len = 0;
+            } /* for */
 
-static bool native_prepare_snapshot(int camfd)
-{
-    int ioctlRetVal = true;
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 1000;
-    ctrlCmd.type       = CAMERA_PREPARE_SNAPSHOT;
-    ctrlCmd.length     = 0;
-    ctrlCmd.value      = NULL;
-    ctrlCmd.resp_fd = camfd;
-
-    if (ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd) < 0) {
-        LOGE("native_prepare_snapshot: ioctl fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
-    }
-    return true;
-}
+            LINK_camera_encode_picture(frame, &camera_handle, camera_cb, this);
+        }
+        else {
+            LOGV("JPEG callback was cancelled--not encoding image.");
+            // We need to keep the raw heap around until the JPEG is fully
+            // encoded, because the JPEG encode uses the raw image contained in
+            // that heap.
+            mRawHeap = NULL;
+        }                    
+        print_time();
+        LOGV("receivePostLpmRawPicture: X");
+    }
+
+    void
+    QualcommCameraHardware::receiveJpegPictureFragment(
+        JPEGENC_CBrtnType *encInfo)
+    {
+        camera_encode_mem_type *enc =
+            (camera_encode_mem_type *)encInfo->outPtr;
+        int index = enc - camera_handle.mem.encBuf;
+        uint8_t *base = (uint8_t *)mJpegHeap->mHeap->base();
+        uint32_t size = encInfo->size;
+        uint32_t remaining = mJpegHeap->mHeap->virtualSize();
+        remaining -= mJpegSize;
 
-static bool native_start_snapshot(int camfd)
-{
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.type       = CAMERA_START_SNAPSHOT;
-    ctrlCmd.length     = 0;
-    ctrlCmd.resp_fd    = camfd; // FIXME: this will be put in by the kernel
-
-    if(ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd) < 0) {
-        LOGE("native_start_snapshot: ioctl fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
-    }
+        LOGV("receiveJpegPictureFragment: (index %d status %d size %d)",
+             index,
+             encInfo->status,
+             size);
 
-    return true;
-}
+        if (size > remaining) {
+            LOGE("receiveJpegPictureFragment: size %d exceeds what "
+                 "remains in JPEG heap (%d), truncating",
+                 size,
+                 remaining);
+            size = remaining;
+        }
 
-static bool native_start_raw_snapshot(int camfd)
-{
-    int ret;
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 1000;
-    ctrlCmd.type = CAMERA_START_RAW_SNAPSHOT;
-    ctrlCmd.length = 0;
-    ctrlCmd.value = NULL;
-    ctrlCmd.resp_fd = camfd;
-
-    if ((ret = ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd)) < 0) {
-        LOGE("native_start_raw_snapshot: ioctl failed. ioctl return value "\
-             "is %d \n", ret);
-        return false;
+        camera_handle.mem.encBuf[index].used_len = 0;
+        memcpy(base + mJpegSize, enc->buffer, size);
+        mJpegSize += size;
     }
-    return true;
-}
 
+    // This method is called by a libqcamera thread, different from the one on
+    // which startPreview() or takePicture() are called.
 
-static bool native_stop_snapshot (int camfd)
-{
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 0;
-    ctrlCmd.type       = CAMERA_STOP_SNAPSHOT;
-    ctrlCmd.length     = 0;
-    ctrlCmd.resp_fd    = -1;
-
-    if (ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND_2, &ctrlCmd) < 0) {
-        LOGE("native_stop_snapshot: ioctl fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
-    }
-
-    return true;
-}
-/*===========================================================================
- * FUNCTION    - native_start_recording -
- *
- * DESCRIPTION:
- *==========================================================================*/
-static bool native_start_recording(int camfd)
-{
-    int ret;
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 1000;
-    ctrlCmd.type = CAMERA_START_RECORDING;
-    ctrlCmd.length = 0;
-    ctrlCmd.value = NULL;
-    ctrlCmd.resp_fd = camfd;
-
-    if ((ret = ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd)) < 0) {
-        LOGE("native_start_recording: ioctl failed. ioctl return value "\
-            "is %d \n", ret);
-        return false;
+    void
+    QualcommCameraHardware::receiveJpegPicture(void)
+    {
+        LOGV("receiveJpegPicture: E image (%d bytes out of %d)",
+             mJpegSize, mJpegHeap->mBufferSize);
+        print_time();
+        Mutex::Autolock cbLock(&mCallbackLock);
+
+        int index = 0;
+
+        if (mJpegPictureCallback) {
+            // The reason we do not allocate into mJpegHeap->mBuffers[offset] is
+            // that the JPEG image's size will probably change from one snapshot
+            // to the next, so we cannot reuse the MemoryBase object.
+            sp<MemoryBase> buffer = new
+                MemoryBase(mJpegHeap->mHeap,
+                           index * mJpegHeap->mBufferSize +
+                           mJpegHeap->mFrameOffset,
+                           mJpegSize);
+            
+            mJpegPictureCallback(buffer, mPictureCallbackCookie);
+            buffer = NULL;
+        }
+        else LOGV("JPEG callback was cancelled--not delivering image.");
+
+        // NOTE: the JPEG encoder uses the raw image contained in mRawHeap, so we need
+        // to keep the heap around until the encoding is complete.
+        mJpegHeap = NULL;
+        mRawHeap = NULL;        
+        
+        for (int cnt = 0; cnt < MAX_JPEG_ENCODE_BUF_NUM; cnt++) {
+            if (camera_handle.mem.encBuf[cnt].buffer != NULL) {
+                free(camera_handle.mem.encBuf[cnt].buffer);
+                memset(camera_handle.mem.encBuf + cnt, 0,
+                       sizeof(camera_encode_mem_type));
+            }
+        } /* for */
+
+        print_time();
+        LOGV("receiveJpegPicture: X callback done.");
+    }
+
+    struct str_map {
+        const char *const desc;
+        int val;
+    };
+
+    static const struct str_map wb_map[] = {
+        { "auto", CAMERA_WB_AUTO },
+        { "custom", CAMERA_WB_CUSTOM },
+        { "incandescent", CAMERA_WB_INCANDESCENT },
+        { "fluorescent", CAMERA_WB_FLUORESCENT },
+        { "daylight", CAMERA_WB_DAYLIGHT },
+        { "cloudy", CAMERA_WB_CLOUDY_DAYLIGHT },
+        { "twilight", CAMERA_WB_TWILIGHT },
+        { "shade", CAMERA_WB_SHADE },
+        { NULL, 0 }
+    };
+
+    static const struct str_map effect_map[] = {
+        { "off", CAMERA_EFFECT_OFF },
+        { "mono", CAMERA_EFFECT_MONO },
+        { "negative", CAMERA_EFFECT_NEGATIVE },
+        { "solarize", CAMERA_EFFECT_SOLARIZE },
+        { "pastel", CAMERA_EFFECT_PASTEL },
+        { "mosaic", CAMERA_EFFECT_MOSAIC },
+        { "resize", CAMERA_EFFECT_RESIZE },
+        { "sepia", CAMERA_EFFECT_SEPIA },
+        { "posterize", CAMERA_EFFECT_POSTERIZE },
+        { "whiteboard", CAMERA_EFFECT_WHITEBOARD },
+        { "blackboard", CAMERA_EFFECT_BLACKBOARD },
+        { "aqua", CAMERA_EFFECT_AQUA },
+        { NULL, 0 }
+    };
+
+    static const struct str_map brightness_map[] = {
+        { "0", CAMERA_BRIGHTNESS_0 },
+        { "1", CAMERA_BRIGHTNESS_1 },
+        { "2", CAMERA_BRIGHTNESS_2 },
+        { "3", CAMERA_BRIGHTNESS_3 },
+        { "4", CAMERA_BRIGHTNESS_4 },
+        { "5", CAMERA_BRIGHTNESS_5 },
+        { "6", CAMERA_BRIGHTNESS_6 },
+        { "7", CAMERA_BRIGHTNESS_7 },
+        { "8", CAMERA_BRIGHTNESS_8 },
+        { "9", CAMERA_BRIGHTNESS_9 },
+        { "10", CAMERA_BRIGHTNESS_10 },
+        { NULL, 0 }
+    };
+
+    static const struct str_map antibanding_map[] = {
+        { "off", CAMERA_ANTIBANDING_OFF },
+        { "50hz", CAMERA_ANTIBANDING_50HZ },
+        { "60hz", CAMERA_ANTIBANDING_60HZ },
+        { "auto", CAMERA_ANTIBANDING_AUTO },
+        { NULL, 0 }
+    };
+
+    static const struct str_map iso_map[] = {
+        { "auto", CAMERA_ISO_AUTO },
+        { "high", CAMERA_ISO_HIGH },
+        { NULL, 0 }
+    };
+
+    static int lookup(const struct str_map *const arr, const char *name, int def)
+    {
+        if (name) {
+            const struct str_map * trav = arr;
+            while (trav->desc) {
+                if (!strcmp(trav->desc, name))
+                    return trav->val;
+                trav++;
+            }
+        }
+        return def;
     }
-    LOGV("native_start_recording: ioctl good. ioctl return value is %d \n",ret);
 
-  /* TODO: Check status of postprocessing if there is any,
-   *       PP status should be in  ctrlCmd */
-
-    return true;
-}
+    void QualcommCameraHardware::initCameraParameters()
+    {
+        LOGV("initCameraParameters: E");
 
-/*===========================================================================
- * FUNCTION    - native_stop_recording -
- *
- * DESCRIPTION:
- *==========================================================================*/
-static bool native_stop_recording(int camfd)
-{
-    int ret;
-    struct msm_ctrl_cmd ctrlCmd;
-    LOGV("in native_stop_recording ");
-    ctrlCmd.timeout_ms = 1000;
-    ctrlCmd.type = CAMERA_STOP_RECORDING;
-    ctrlCmd.length = 0;
-    ctrlCmd.value = NULL;
-    ctrlCmd.resp_fd = camfd;
-
-    if ((ret = ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd)) < 0) {
-        LOGE("native_stop_video: ioctl failed. ioctl return value is %d \n",
-        ret);
-        return false;
-    }
-    LOGV("in native_stop_recording returned %d", ret);
-    return true;
-}
-/*===========================================================================
- * FUNCTION    - native_start_video -
- *
- * DESCRIPTION:
- *==========================================================================*/
-static bool native_start_video(int camfd)
-{
-    int ret;
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 1000;
-    ctrlCmd.type = CAMERA_START_VIDEO;
-    ctrlCmd.length = 0;
-    ctrlCmd.value = NULL;
-    ctrlCmd.resp_fd = camfd;
-
-    if ((ret = ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd)) < 0) {
-        LOGE("native_start_video: ioctl failed. ioctl return value is %d \n",
-        ret);
-        return false;
-    }
+        // Because libqcamera is broken, for the camera_set_parm() calls
+        // QualcommCameraHardware camera_cb() is called synchronously,
+        // so we cannot wait on a state change.  Also, we have to unlock
+        // the mStateLock, because camera_cb() acquires it.
 
-  /* TODO: Check status of postprocessing if there is any,
-   *       PP status should be in  ctrlCmd */
+        startCameraIfNecessary();
 
-    return true;
-}
+#define SET_PARM(x,y) do {                                             \
+        LOGV("initCameraParameters: set parm: %s, %d", #x, y);         \
+        LINK_camera_set_parm (x, y, NULL, NULL);                       \
+    } while(0)
 
-/*===========================================================================
- * FUNCTION    - native_stop_video -
- *
- * DESCRIPTION:
- *==========================================================================*/
-static bool native_stop_video(int camfd)
-{
-    int ret;
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 1000;
-    ctrlCmd.type = CAMERA_STOP_VIDEO;
-    ctrlCmd.length = 0;
-    ctrlCmd.value = NULL;
-    ctrlCmd.resp_fd = camfd;
-
-    if ((ret = ioctl(camfd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd)) < 0) {
-        LOGE("native_stop_video: ioctl failed. ioctl return value is %d \n",
-        ret);
-        return false;
-    }
+        /* Preview Mode: snapshot or movie */
+        SET_PARM(CAMERA_PARM_PREVIEW_MODE, CAMERA_PREVIEW_MODE_SNAPSHOT);
 
-    return true;
-}
-/*==========================================================================*/
+        /* Default Rotation - none */
+        int rotation = mParameters.getInt("rotation");
 
-static cam_frame_start_parms frame_parms;
-static int recordingState = 0;
+        // Rotation may be negative, but may not be -1, because it has to be a
+        // multiple of 90.  That's why we can still interpret -1 as an error,
+        if (rotation == -1) {
+            LOGV("rotation not specified or is invalid, defaulting to 0");
+            rotation = 0;
+        }
+        else if (rotation % 90) {
+            LOGE("rotation %d is not a multiple of 90 degrees!  Defaulting to zero.",
+                 rotation);
+            rotation = 0;
+        }
+        else {
+            // normalize to [0 - 270] degrees
+            rotation %= 360;
+            if (rotation < 0) rotation += 360;
+        }
 
-static rat_t latitude[3];
-static rat_t longitude[3];
-static char lonref[2];
-static char latref[2];
-static char dateTime[20];
-static rat_t altitude;
+        SET_PARM(CAMERA_PARM_ENCODE_ROTATION, rotation);
 
-static void addExifTag(exif_tag_id_t tagid, exif_tag_type_t type,
-                        uint32_t count, uint8_t copy, void *data) {
+        SET_PARM(CAMERA_PARM_WB,
+                 lookup(wb_map,
+                        mParameters.get("whitebalance"),
+                        CAMERA_WB_AUTO));
 
-    if(exif_table_numEntries == MAX_EXIF_TABLE_ENTRIES) {
-        LOGE("Number of entries exceeded limit");
-        return;
-    }
+        SET_PARM(CAMERA_PARM_EFFECT,
+                 lookup(effect_map,
+                        mParameters.get("effect"),
+                        CAMERA_EFFECT_OFF));
 
-    int index = exif_table_numEntries;
-    exif_data[index].tag_id = tagid;
-	exif_data[index].tag_entry.type = type;
-	exif_data[index].tag_entry.count = count;
-	exif_data[index].tag_entry.copy = copy;
-    if((type == EXIF_RATIONAL) && (count > 1))
-        exif_data[index].tag_entry.data._rats = (rat_t *)data;
-    if((type == EXIF_RATIONAL) && (count == 1))
-		exif_data[index].tag_entry.data._rat = *(rat_t *)data;
-    else if(type == EXIF_ASCII)
-        exif_data[index].tag_entry.data._ascii = (char *)data;
-    else if(type == EXIF_BYTE)
-		exif_data[index].tag_entry.data._byte = *(uint8_t *)data;
-
-    // Increase number of entries
-    exif_table_numEntries++;
-    return;
-}
+        SET_PARM(CAMERA_PARM_BRIGHTNESS,
+                 lookup(brightness_map,
+                        mParameters.get("exposure-offset"),
+                        CAMERA_BRIGHTNESS_DEFAULT));
 
-static void parseLatLong(const char *latlonString, int *pDegrees,
-                           int *pMinutes, int *pSeconds ) {
+        SET_PARM(CAMERA_PARM_ISO,
+                 lookup(iso_map,
+                        mParameters.get("iso"),
+                        CAMERA_ISO_AUTO));
 
-    double value = atof(latlonString);
-    value = fabs(value);
-    int degrees = (int) value;
+        SET_PARM(CAMERA_PARM_ANTIBANDING,
+                 lookup(antibanding_map,
+                        mParameters.get("antibanding"),
+                        CAMERA_ANTIBANDING_AUTO));
 
-    double remainder = value - degrees;
-    int minutes = (int) (remainder * 60);
-    int seconds = (int) (((remainder * 60) - minutes) * 60 * 1000);
+        int ns_mode = mParameters.getInt("nightshot-mode");
+        if (ns_mode < 0) ns_mode = 0;
+        SET_PARM(CAMERA_PARM_NIGHTSHOT_MODE, ns_mode);
 
-    *pDegrees = degrees;
-    *pMinutes = minutes;
-    *pSeconds = seconds;
-}
+        int luma_adaptation = mParameters.getInt("luma-adaptation");
+        if (luma_adaptation < 0) luma_adaptation = 0;
+        SET_PARM(CAMERA_PARM_LUMA_ADAPTATION, luma_adaptation);
 
-static void setLatLon(exif_tag_id_t tag, const char *latlonString) {
+#undef SET_PARM
 
-    int degrees, minutes, seconds;
+#if 0
+        /* Default Auto FPS: 30 (maximum) */
+        LINK_camera_set_parm_2 (CAMERA_PARM_PREVIEW_FPS,
+                                (1<<16|20), // max frame rate 30
+                                (4<<16|20), // min frame rate 5
+                                NULL,
+                                NULL);
+#endif
 
-    parseLatLong(latlonString, &degrees, &minutes, &seconds);
+        int th_w, th_h, th_q;
+        th_w = mParameters.getInt("jpeg-thumbnail-width");
+        if (th_w < 0) LOGW("property jpeg-thumbnail-width not specified");
 
-    rat_t value[3] = { {degrees, 1},
-                       {minutes, 1},
-                       {seconds, 1000} };
+        th_h = mParameters.getInt("jpeg-thumbnail-height");
+        if (th_h < 0) LOGW("property jpeg-thumbnail-height not specified");
 
-    if(tag == EXIFTAGID_GPS_LATITUDE) {
-        memcpy(latitude, value, sizeof(latitude));
-        addExifTag(EXIFTAGID_GPS_LATITUDE, EXIF_RATIONAL, 3,
-                    1, (void *)latitude);
-    } else {
-        memcpy(longitude, value, sizeof(longitude));
-        addExifTag(EXIFTAGID_GPS_LONGITUDE, EXIF_RATIONAL, 3,
-                    1, (void *)longitude);
-    }
-}
+        th_q = mParameters.getInt("jpeg-thumbnail-quality");
+        if (th_q < 0) LOGW("property jpeg-thumbnail-quality not specified");
 
-void QualcommCameraHardware::setGpsParameters() {
-    const char *str = NULL;
-
-    //Set Latitude
-    str = mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
-    if(str != NULL) {
-        setLatLon(EXIFTAGID_GPS_LATITUDE, str);
-        //set Latitude Ref
-        str = NULL;
-        str = mParameters.get(CameraParameters::KEY_GPS_LATITUDE_REF);
-        if(str != NULL) {
-            strncpy(latref, str, 1);
-            latref[1] = '\0';
-            addExifTag(EXIFTAGID_GPS_LATITUDE_REF, EXIF_ASCII, 2,
-                        1, (void *)latref);
+        if (th_w > 0 && th_h > 0 && th_q > 0) {
+            LOGI("setting thumbnail dimensions to %dx%d, quality %d",
+                 th_w, th_h, th_q);
+            int ret = LINK_camera_set_thumbnail_properties(th_w, th_h, th_q);
+            if (ret != CAMERA_SUCCESS) {
+                LOGE("LINK_camera_set_thumbnail_properties returned %d", ret);
+            }
         }
-    } else
-		return;
-
-    //set Longitude
-    str = NULL;
-    str = mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
-    if(str != NULL) {
-        setLatLon(EXIFTAGID_GPS_LONGITUDE, str);
-        //set Longitude Ref
-        str = NULL;
-        str = mParameters.get(CameraParameters::KEY_GPS_LONGITUDE_REF);
-        if(str != NULL) {
-            strncpy(lonref, str, 1);
-            lonref[1] = '\0';
-            addExifTag(EXIFTAGID_GPS_LONGITUDE_REF, EXIF_ASCII, 2,
-                        1, (void *)lonref);
-	}
-    }
-
-    //set Altitude
-    str = NULL;
-    str = mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
-    if(str != NULL) {
-        double value = atoi(str);
-        uint32_t value_meter = value * 1000;
-        rat_t alt_value = {value_meter, 1000};
-        memcpy(&altitude, &alt_value, sizeof(altitude));
-        addExifTag(EXIFTAGID_GPS_ALTITUDE, EXIF_RATIONAL, 1,
-                    1, (void *)&altitude);
-        //set AltitudeRef
-        int ref = mParameters.getInt(CameraParameters::KEY_GPS_ALTITUDE_REF);
-        if( !(ref < 0 || ref > 1) )
-            addExifTag(EXIFTAGID_GPS_ALTITUDE_REF, EXIF_BYTE, 1,
-                        1, (void *)&ref);
-    }
-
 
-}
+#if defined FEATURE_CAMERA_ENCODE_PROPERTIES
+        /* Set Default JPEG encoding--this does not cause a callback */
+        encode_properties.quality   = mParameters.getInt("jpeg-quality");
+        if (encode_properties.quality < 0) {
+            LOGW("JPEG-image quality is not specified "
+                 "or is negative, defaulting to %d",
+                 encode_properties.quality);
+            encode_properties.quality = 100;
+        }
+        else LOGV("Setting JPEG-image quality to %d",
+                  encode_properties.quality);
+        encode_properties.format    = CAMERA_JPEG;
+        encode_properties.file_size = 0x0;
+        LINK_camera_set_encode_properties(&encode_properties);
+#else
+#warning 'FEATURE_CAMERA_ENCODE_PROPERTIES should be enabled!'
+#endif
 
-bool QualcommCameraHardware::native_jpeg_encode(void)
-{
-    int jpeg_quality = mParameters.getInt("jpeg-quality");
-    if (jpeg_quality >= 0) {
-        LOGV("native_jpeg_encode, current jpeg main img quality =%d",
-             jpeg_quality);
-        if(!LINK_jpeg_encoder_setMainImageQuality(jpeg_quality)) {
-            LOGE("native_jpeg_encode set jpeg-quality failed");
-            return false;
-        }
-    }
 
-    int thumbnail_quality = mParameters.getInt("jpeg-thumbnail-quality");
-    if (thumbnail_quality >= 0) {
-        LOGV("native_jpeg_encode, current jpeg thumbnail quality =%d",
-             thumbnail_quality);
-        if(!LINK_jpeg_encoder_setThumbnailQuality(thumbnail_quality)) {
-            LOGE("native_jpeg_encode set thumbnail-quality failed");
-            return false;
-        }
+        LOGV("initCameraParameters: X");
     }
 
-    int rotation = mParameters.getInt("rotation");
-    if (rotation >= 0) {
-        LOGV("native_jpeg_encode, rotation = %d", rotation);
-        if(!LINK_jpeg_encoder_setRotation(rotation)) {
-            LOGE("native_jpeg_encode set rotation failed");
-            return false;
+    // Called with mStateLock held!
+    void QualcommCameraHardware::setCameraDimensions()
+    {
+        if (mCameraState != QCS_IDLE) {
+            LOGE("set camera dimensions: expecting state QCS_IDLE, not %s",
+                 getCameraStateStr(mCameraState));
+            return;
         }
-    }
-
-    setGpsParameters();
-
-    //set TimeStamp
-	time_t now;
-	struct tm * curtime;
-
-	time(&now);
-    curtime = localtime(&now);
-    strftime(dateTime,20,"%Y:%m:%d %H:%M:%S",curtime);
-    dateTime[19] = '\0';
-    addExifTag(EXIFTAGID_EXIF_DATE_TIME_ORIGINAL, EXIF_ASCII,
-                  20, 1, (void *)dateTime);
-    addExifTag(EXIFTAGID_EXIF_DATE_TIME, EXIF_ASCII,
-                  20, 1, (void *)dateTime);
-
-   /* Set maker and model. Read the NOTICE before changing this */
-   char model[PROP_VALUE_MAX];
-   char maker[12];
-   int modelLen = 0;
-
-   strncpy(maker,"CyanogenMod",11);
-   maker[11] = '\0';
-   __system_property_get("ro.product.device", model);
-   modelLen=strlen(model);
-   model[modelLen] = '\0';
-
-    addExifTag(EXIFTAGID_EXIF_CAMERA_MAKER, EXIF_ASCII,
-                  12, 1, (void *)maker);
-    addExifTag(EXIFTAGID_EXIF_CAMERA_MODEL, EXIF_ASCII,
-                  modelLen, 1, (void *)model);
-
-    if (!LINK_jpeg_encoder_encode(&mDimension,
-                                  (uint8_t *)mThumbnailHeap->mHeap->base(),
-                                  mThumbnailHeap->mHeap->getHeapID(),
-                                  (uint8_t *)mRawHeap->mHeap->base(),
-                                  mRawHeap->mHeap->getHeapID(),
-                                  &mCrop, exif_data, exif_table_numEntries,
-                                  jpegPadding/2)) {
-        LOGE("native_jpeg_encode: jpeg_encoder_encode failed.");
-        return false;
-    }
-    return true;
-}
 
-bool QualcommCameraHardware::native_set_parm(
-    cam_ctrl_type type, uint16_t length, void *value)
-{
-    struct msm_ctrl_cmd ctrlCmd;
-
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.type       = (uint16_t)type;
-    ctrlCmd.length     = length;
-    // FIXME: this will be put in by the kernel
-    ctrlCmd.resp_fd    = mCameraControlFd;
-    ctrlCmd.value = value;
-
-    LOGV("%s: fd %d, type %d, length %d", __FUNCTION__,
-         mCameraControlFd, type, length);
-    if (ioctl(mCameraControlFd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd) < 0 ||
-                ctrlCmd.status != CAM_CTRL_SUCCESS) {
-        LOGE("%s: error (%s): fd %d, type %d, length %d, status %d",
-             __FUNCTION__, strerror(errno),
-             mCameraControlFd, type, length, ctrlCmd.status);
-        return false;
+        LINK_camera_set_dimensions(mRawWidth,
+                                   mRawHeight,
+                                   mPreviewWidth,
+                                   mPreviewHeight,
+                                   NULL,
+                                   NULL);
     }
-    return true;
-}
-
-void QualcommCameraHardware::jpeg_set_location()
-{
-    bool encode_location = true;
-    camera_position_type pt;
-
-#define PARSE_LOCATION(what,type,fmt,desc) do {                                \
-        pt.what = 0;                                                           \
-        const char *what##_str = mParameters.get("gps-"#what);                 \
-        LOGV("GPS PARM %s --> [%s]", "gps-"#what, what##_str);                 \
-        if (what##_str) {                                                      \
-            type what = 0;                                                     \
-            if (sscanf(what##_str, fmt, &what) == 1)                           \
-                pt.what = what;                                                \
-            else {                                                             \
-                LOGE("GPS " #what " %s could not"                              \
-                     " be parsed as a " #desc, what##_str);                    \
-                encode_location = false;                                       \
-            }                                                                  \
-        }                                                                      \
-        else {                                                                 \
-            LOGV("GPS " #what " not specified: "                               \
-                 "defaulting to zero in EXIF header.");                        \
-            encode_location = false;                                           \
-       }                                                                       \
-    } while(0)
-
-    PARSE_LOCATION(timestamp, long, "%ld", "long");
-    if (!pt.timestamp) pt.timestamp = time(NULL);
-    PARSE_LOCATION(altitude, short, "%hd", "short");
-    PARSE_LOCATION(latitude, double, "%lf", "double float");
-    PARSE_LOCATION(longitude, double, "%lf", "double float");
-
-#undef PARSE_LOCATION
 
-    if (encode_location) {
-        LOGD("setting image location ALT %d LAT %lf LON %lf",
-             pt.altitude, pt.latitude, pt.longitude);
-/* Disabling until support is available.
-        if (!LINK_jpeg_encoder_setLocation(&pt)) {
-            LOGE("jpeg_set_location: LINK_jpeg_encoder_setLocation failed.");
+    QualcommCameraHardware::qualcomm_camera_state
+    QualcommCameraHardware::change_state(qualcomm_camera_state new_state,
+        bool lock)
+    {
+        if (lock) mStateLock.lock();
+        if (new_state != mCameraState) {
+            // Due to the fact that we allow only one thread at a time to call
+            // startPreview(), stopPreview(), or takePicture(), we know that
+            // only one thread at a time may be blocked waiting for a state
+            // transition on mStateWait.  That's why we signal(), not
+            // broadcast().
+
+            LOGV("state transition %s --> %s",
+                 getCameraStateStr(mCameraState),
+                 getCameraStateStr(new_state));
+
+            mCameraState = new_state;
+            mStateWait.signal();
+        }
+        if (lock) mStateLock.unlock();
+        return new_state;
+    }
+
+#define CAMERA_STATE(n) case n: if(n != CAMERA_FUNC_START_PREVIEW || cb != CAMERA_EVT_CB_FRAME) LOGV("STATE %s // STATUS %d", #n, cb);
+#define TRANSITION(e,s) do { \
+            obj->change_state(obj->mCameraState == e ? s : QCS_ERROR); \
+        } while(0)
+#define TRANSITION_LOCKED(e,s) do { \
+            obj->change_state((obj->mCameraState == e ? s : QCS_ERROR), false); \
+        } while(0)
+#define TRANSITION_ALWAYS(s) obj->change_state(s)
+
+
+    // This callback is called from the destructor.
+    void QualcommCameraHardware::stop_camera_cb(camera_cb_type cb,
+                                                const void *client_data,
+                                                camera_func_type func,
+                                                int32_t parm4)
+    {
+        QualcommCameraHardware *obj =
+            (QualcommCameraHardware *)client_data;
+        switch(func) {
+            CAMERA_STATE(CAMERA_FUNC_STOP)
+                TRANSITION(QCS_INTERNAL_STOPPING, QCS_INIT);
+            break;
+        default:
+            break;
         }
-*/
     }
-    else LOGV("not setting image location");
-}
 
-void QualcommCameraHardware::runFrameThread(void *data)
-{
-    LOGV("runFrameThread E");
-
-    int cnt;
-
-#if DLOPEN_LIBMMCAMERA
-    // We need to maintain a reference to libqcamera.so for the duration of the
-    // frame thread, because we do not know when it will exit relative to the
-    // lifetime of this object.  We do not want to dlclose() libqcamera while
-    // LINK_cam_frame is still running.
-    void *libhandle = ::dlopen("liboemcamera.so", RTLD_NOW);
-    LOGV("FRAME: loading libqcamera at %p", libhandle);
-    if (!libhandle) {
-        LOGE("FATAL ERROR: could not dlopen liboemcamera.so: %s", dlerror());
-    }
-    if (libhandle)
-#endif
+    void QualcommCameraHardware::camera_cb(camera_cb_type cb,
+                                           const void *client_data,
+                                           camera_func_type func,
+                                           int32_t parm4)
     {
-        LINK_cam_frame(data);
-    }
-
-    mPreviewHeap.clear();
-    if(( mCurrentTarget == TARGET_MSM7630 ) || (mCurrentTarget == TARGET_QSD8250))
-        mRecordHeap.clear();
+        QualcommCameraHardware *obj =
+            (QualcommCameraHardware *)client_data;
 
-#if DLOPEN_LIBMMCAMERA
-    if (libhandle) {
-        ::dlclose(libhandle);
-        LOGV("FRAME: dlclose(libqcamera)");
-    }
-#endif
-
-    mFrameThreadWaitLock.lock();
-    mFrameThreadRunning = false;
-    mFrameThreadWait.signal();
-    mFrameThreadWaitLock.unlock();
-
-    LOGV("runFrameThread X");
-}
-
-void QualcommCameraHardware::runVideoThread(void *data)
-{
-    LOGD("runVideoThread E");
-    msm_frame* vframe = NULL;
-
-    while(true) {
-        pthread_mutex_lock(&(g_busy_frame_queue.mut));
-
-        // Exit the thread , in case of stop recording..
-        mVideoThreadWaitLock.lock();
-        if(mVideoThreadExit){
-            LOGV("Exiting video thread..");
-            mVideoThreadWaitLock.unlock();
-            pthread_mutex_unlock(&(g_busy_frame_queue.mut));
-            break;
-        }
-        mVideoThreadWaitLock.unlock();
-
-        LOGV("in video_thread : wait for video frame ");
-        // check if any frames are available in busyQ and give callback to
-        // services/video encoder
-        cam_frame_wait_video();
-        LOGV("video_thread, wait over..");
-
-        // Exit the thread , in case of stop recording..
-        mVideoThreadWaitLock.lock();
-        if(mVideoThreadExit){
-            LOGV("Exiting video thread..");
-            mVideoThreadWaitLock.unlock();
-            pthread_mutex_unlock(&(g_busy_frame_queue.mut));
-            break;
+        // Promote the singleton to make sure that we do not get destroyed
+        // while this callback is executing.
+        if (UNLIKELY(getInstance() == NULL)) {
+            LOGE("camera object has been destroyed--returning immediately");
+            return;
         }
-        mVideoThreadWaitLock.unlock();
-
-        // Get the video frame to be encoded
-        vframe = cam_frame_get_video ();
-        pthread_mutex_unlock(&(g_busy_frame_queue.mut));
-        LOGV("in video_thread : got video frame ");
 
-        if (UNLIKELY(mDebugFps)) {
-            debugShowVideoFPS();
+        if (cb == CAMERA_EXIT_CB_ABORT ||     /* Function aborted             */
+            cb == CAMERA_EXIT_CB_DSP_ABORT || /* Abort due to DSP failure     */
+            cb == CAMERA_EXIT_CB_ERROR ||     /* Failed due to resource       */
+            cb == CAMERA_EXIT_CB_FAILED)      /* Execution failed or rejected */
+        {
+            // Autofocus failures occur relatively often and are not fatal, so
+            // we do not transition to QCS_ERROR for them.
+            if (func != CAMERA_FUNC_START_FOCUS) {
+                LOGE("QualcommCameraHardware::camera_cb: @CAMERA_EXIT_CB_FAILURE(%d) in state %s.",
+                     parm4,
+                     obj->getCameraStateStr(obj->mCameraState));
+                TRANSITION_ALWAYS(QCS_ERROR);
+            }
         }
 
-        if(vframe != NULL) {
-            // Find the offset within the heap of the current buffer.
-            LOGV("Got video frame :  buffer %d base %d ", vframe->buffer, mRecordHeap->mHeap->base());
-            ssize_t offset =
-                (ssize_t)vframe->buffer - (ssize_t)mRecordHeap->mHeap->base();
-            LOGV("offset = %d , alignsize = %d , offset later = %d", offset, mRecordHeap->mAlignedBufferSize, (offset / mRecordHeap->mAlignedBufferSize));
-
-            offset /= mRecordHeap->mAlignedBufferSize;
-
-            // dump frames for test purpose
-#ifdef DUMP_VIDEO_FRAMES
-            static int frameCnt = 0;
-            if (frameCnt >= 11 && frameCnt <= 13 ) {
-                char buf[128];
-                sprintf(buf, "/data/%d_v.yuv", frameCnt);
-                int file_fd = open(buf, O_RDWR | O_CREAT, 0777);
-                LOGV("dumping video frame %d", frameCnt);
-                if (file_fd < 0) {
-                    LOGE("cannot open file\n");
+        switch(func) {
+            // This is the commonest case.
+            CAMERA_STATE(CAMERA_FUNC_START_PREVIEW)
+                switch(cb) {
+                case CAMERA_RSP_CB_SUCCESS:
+                    TRANSITION(QCS_INTERNAL_PREVIEW_REQUESTED,
+                               QCS_PREVIEW_IN_PROGRESS);
+                    break;
+                case CAMERA_EVT_CB_FRAME:
+                    switch (obj->mCameraState) {
+                    case QCS_PREVIEW_IN_PROGRESS:
+                        if (parm4)
+                            obj->receivePreviewFrame((camera_frame_type *)parm4);
+                        break;
+                    case QCS_INTERNAL_PREVIEW_STOPPING:
+                        LOGE("camera cb: discarding preview frame "
+                             "while stopping preview");
+                        break;
+                    default:
+                        // transition to QCS_ERROR
+                        LOGE("camera cb: invalid state %s for preview!",
+                             obj->getCameraStateStr(obj->mCameraState));
+                        break;
+                    }
+/* -- this function is called now inside of receivePreviewFrame.
+                    LINK_camera_release_frame();
+*/
+                    break;
+                default:
+                    // transition to QCS_ERROR
+                    LOGE("unexpected cb %d for CAMERA_FUNC_START_PREVIEW.",
+                         cb);
                 }
-                else
-                {
-                    write(file_fd, (const void *)vframe->buffer,
-                        vframe->cbcr_off * 3 / 2);
+                break;
+            CAMERA_STATE(CAMERA_FUNC_START)
+                TRANSITION(QCS_INIT, QCS_IDLE);
+                break;
+/* -- this case handled in stop_camera_cb() now.
+            CAMERA_STATE(CAMERA_FUNC_STOP)
+                TRANSITION(QCS_INTERNAL_STOPPING, QCS_INIT);
+                break;
+*/
+            CAMERA_STATE(CAMERA_FUNC_STOP_PREVIEW)
+                TRANSITION(QCS_INTERNAL_PREVIEW_STOPPING,
+                           QCS_IDLE);
+                break;
+            CAMERA_STATE(CAMERA_FUNC_TAKE_PICTURE)
+                if (cb == CAMERA_RSP_CB_SUCCESS) {
+                    TRANSITION(QCS_INTERNAL_RAW_REQUESTED,
+                               QCS_WAITING_RAW);
                 }
-                close(file_fd);
-          }
-          frameCnt++;
-#endif
-            // Enable IF block to give frames to encoder , ELSE block for just simulation
-#if 1
-            LOGV("in video_thread : got video frame, before if check giving frame to services/encoder");
-            mCallbackLock.lock();
-            int msgEnabled = mMsgEnabled;
-            data_callback_timestamp rcb = mDataCallbackTimestamp;
-            void *rdata = mCallbackCookie;
-            mCallbackLock.unlock();
-
-            if(rcb != NULL && (msgEnabled & CAMERA_MSG_VIDEO_FRAME) ) {
-                LOGV("in video_thread : got video frame, giving frame to services/encoder");
-                rcb(systemTime(), CAMERA_MSG_VIDEO_FRAME, mRecordHeap->mBuffers[offset], rdata);
-            }
-#else
-            // 720p output2  : simulate release frame here:
-            LOGE("in video_thread simulation , releasing the video frame");
-            LINK_camframe_free_video(vframe);
-#endif
-
-        } else LOGE("in video_thread get frame returned null");
-
-
-    } // end of while loop
-
-    mVideoThreadWaitLock.lock();
-    mVideoThreadRunning = false;
-    mVideoThreadWait.signal();
-    mVideoThreadWaitLock.unlock();
-
-    LOGV("runVideoThread X");
-}
-
-void *video_thread(void *user)
-{
-    LOGV("video_thread E");
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-        obj->runVideoThread(user);
-    }
-    else LOGE("not starting video thread: the object went away!");
-    LOGV("video_thread X");
-    return NULL;
-}
-
-void *frame_thread(void *user)
-{
-    LOGD("frame_thread E");
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-        obj->runFrameThread(user);
+                else if (cb == CAMERA_EVT_CB_SNAPSHOT_DONE) {
+                    obj->notifyShutter();
+                    // Received pre-LPM raw picture. Notify callback now.
+                    obj->receiveRawPicture((camera_frame_type *)parm4);
+                }
+                else if (cb == CAMERA_EXIT_CB_DONE) {
+                    // It's important that we call receiveRawPicture() before
+                    // we transition the state because another thread may be
+                    // waiting in cancelPicture(), and then delete this object.
+                    // If the order were reversed, we might call
+                    // receiveRawPicture on a dead object.
+                    LOGV("Receiving post LPM raw picture.");
+                    obj->receivePostLpmRawPicture((camera_frame_type *)parm4);
+                    {
+                        Mutex::Autolock lock(&obj->mStateLock);
+                        TRANSITION_LOCKED(QCS_WAITING_RAW,
+                                          obj->mJpegPictureCallback != NULL ?
+                                          QCS_WAITING_JPEG :
+                                          QCS_IDLE);
+                    }
+                } else {  // transition to QCS_ERROR
+                    if (obj->mCameraState == QCS_ERROR) {
+                        LOGE("camera cb: invalid state %s for taking a picture!",
+                             obj->getCameraStateStr(obj->mCameraState));
+                        obj->mRawPictureCallback(NULL, obj->mPictureCallbackCookie);
+                        obj->mJpegPictureCallback(NULL, obj->mPictureCallbackCookie);
+                        TRANSITION_ALWAYS(QCS_IDLE);
+                    }
+                }
+                break;
+            CAMERA_STATE(CAMERA_FUNC_ENCODE_PICTURE)
+                switch (cb) {
+                case CAMERA_RSP_CB_SUCCESS:
+                    // We already transitioned the camera state to
+                    // QCS_WAITING_JPEG when we called
+                    // camera_encode_picture().
+                    break;
+                case CAMERA_EXIT_CB_BUFFER:
+                    if (obj->mCameraState == QCS_WAITING_JPEG) {
+                        obj->receiveJpegPictureFragment(
+                            (JPEGENC_CBrtnType *)parm4);
+                    }
+                    else LOGE("camera cb: invalid state %s for receiving "
+                              "JPEG fragment!",
+                              obj->getCameraStateStr(obj->mCameraState));
+                    break;
+                case CAMERA_EXIT_CB_DONE:
+                    if (obj->mCameraState == QCS_WAITING_JPEG) {
+                        // Receive the last fragment of the image.
+                        obj->receiveJpegPictureFragment(
+                            (JPEGENC_CBrtnType *)parm4);
+
+                        // The size of the complete JPEG image is in 
+                        // mJpegSize.
+
+                        // It's important that we call receiveJpegPicture()
+                        // before we transition the state because another
+                        // thread may be waiting in cancelPicture(), and then
+                        // delete this object.  If the order were reversed, we
+                        // might call receiveRawPicture on a dead object.
+
+                        obj->receiveJpegPicture();
+
+                        TRANSITION(QCS_WAITING_JPEG, QCS_IDLE);
+                    }
+                    // transition to QCS_ERROR
+                    else LOGE("camera cb: invalid state %s for "
+                              "receiving JPEG!",
+                              obj->getCameraStateStr(obj->mCameraState));
+                    break;
+                default:
+                    // transition to QCS_ERROR
+                    LOGE("camera cb: unknown cb %d for JPEG!", cb);
+                }
+            break;
+            CAMERA_STATE(CAMERA_FUNC_START_FOCUS) {
+                // NO TRANSITION HERE.  We acquire mStateLock here because it is
+                // possible for ::autoFocus to be called after the call to
+                // mAutoFocusCallback() but before we set mAutoFocusCallback
+                // to NULL.
+                if (obj->mAutoFocusCallback) {
+                    switch (cb) {
+                    case CAMERA_RSP_CB_SUCCESS:
+                        LOGV("camera cb: autofocus has started.");
+                        break;
+                    case CAMERA_EXIT_CB_DONE: {
+                        LOGV("camera cb: autofocus succeeded.");
+                        Mutex::Autolock lock(&obj->mStateLock);
+                        if (obj->mAutoFocusCallback) {
+                            obj->mAutoFocusCallback(true,
+                                    obj->mAutoFocusCallbackCookie);
+                            obj->mAutoFocusCallback = NULL;
+                        }
+                    }
+                        break;
+                    case CAMERA_EXIT_CB_ABORT:
+                        LOGE("camera cb: autofocus aborted");
+                        break;
+                    case CAMERA_EXIT_CB_FAILED: {
+                        LOGE("camera cb: autofocus failed");
+                        Mutex::Autolock lock(&obj->mStateLock);
+                        if (obj->mAutoFocusCallback) {
+                            obj->mAutoFocusCallback(false,
+                                    obj->mAutoFocusCallbackCookie);
+                            obj->mAutoFocusCallback = NULL;
+                        }
+                    }
+                        break;
+                    default:
+                        LOGE("camera cb: unknown cb %d for "
+                             "CAMERA_FUNC_START_FOCUS!", cb);
+                    }
+                }
+            } break;
+        default:
+            // transition to QCS_ERROR
+            LOGE("Unknown camera-callback status %d", cb);
+        }
+    }
+
+#undef TRANSITION
+#undef TRANSITION_LOCKED
+#undef TRANSITION_ALWAYS
+#undef CAMERA_STATE
+
+    static unsigned clp2(unsigned x) {
+        x = x - 1;
+        x = x | (x >> 1);
+        x = x | (x >> 2);
+        x = x | (x >> 4);
+        x = x | (x >> 8);
+        x = x | (x >>16);
+        return x + 1;
+    }
+
+    QualcommCameraHardware::MemPool::MemPool(int buffer_size, int num_buffers,
+                                             int frame_size,
+                                             int frame_offset,
+                                             const char *name) :
+        mBufferSize(buffer_size),
+        mNumBuffers(num_buffers),
+        mFrameSize(frame_size),
+        mFrameOffset(frame_offset),
+        mBuffers(NULL), mName(name)
+    {
+        // empty
     }
-    else LOGW("not starting frame thread: the object went away!");
-    LOGD("frame_thread X");
-    return NULL;
-}
 
-bool QualcommCameraHardware::initPreview()
-{
-    // See comments in deinitPreview() for why we have to wait for the frame
-    // thread here, and why we can't use pthread_join().
-    int videoWidth, videoHeight;
-    mParameters.getPreviewSize(&previewWidth, &previewHeight);
-
-    videoWidth = previewWidth;  // temporary , should be configurable later
-    videoHeight = previewHeight;
-    LOGV("initPreview E: preview size=%dx%d videosize = %d x %d", previewWidth, previewHeight, videoWidth, videoHeight );
-
-    if( ( mCurrentTarget == TARGET_MSM7630 ) || (mCurrentTarget == TARGET_QSD8250)) {
-        mDimension.video_width = videoWidth;
-        mDimension.video_width = CEILING16(mDimension.video_width);
-        mDimension.video_height = videoHeight;
-        // for 720p , preview can be 768X432
-        previewWidth = mDimension.display_width;
-        previewHeight= mDimension.display_height;
-        LOGV("initPreview : preview size=%dx%d videosize = %d x %d", previewWidth, previewHeight, mDimension.video_width, mDimension.video_height );
+    void QualcommCameraHardware::MemPool::completeInitialization()
+    {
+        // If we do not know how big the frame will be, we wait to allocate
+        // the buffers describing the individual frames until we do know their
+        // size.
+
+        if (mFrameSize > 0) {
+            mBuffers = new sp<MemoryBase>[mNumBuffers];
+            for (int i = 0; i < mNumBuffers; i++) {
+                mBuffers[i] = new
+                    MemoryBase(mHeap,
+                               i * mBufferSize + mFrameOffset,
+                               mFrameSize);
+            }
+        }
     }
 
+    QualcommCameraHardware::AshmemPool::AshmemPool(int buffer_size, int num_buffers,
+                                                   int frame_size,
+                                                   int frame_offset,
+                                                   const char *name) :
+        QualcommCameraHardware::MemPool(buffer_size,
+                                        num_buffers,
+                                        frame_size,
+                                        frame_offset,
+                                        name)
+    {
+            LOGV("constructing MemPool %s backed by ashmem: "
+                 "%d frames @ %d bytes, offset %d, "
+                 "buffer size %d",
+                 mName,
+                 num_buffers, frame_size, frame_offset, buffer_size);
 
-    mFrameThreadWaitLock.lock();
-    while (mFrameThreadRunning) {
-        LOGV("initPreview: waiting for old frame thread to complete.");
-        mFrameThreadWait.wait(mFrameThreadWaitLock);
-        LOGV("initPreview: old frame thread completed.");
-    }
-    mFrameThreadWaitLock.unlock();
+            int page_mask = getpagesize() - 1;
+            int ashmem_size = buffer_size * num_buffers;
+            ashmem_size += page_mask;
+            ashmem_size &= ~page_mask;
 
-    mInSnapshotModeWaitLock.lock();
-    while (mInSnapshotMode) {
-        LOGV("initPreview: waiting for snapshot mode to complete.");
-        mInSnapshotModeWait.wait(mInSnapshotModeWaitLock);
-        LOGV("initPreview: snapshot mode completed.");
-    }
-    mInSnapshotModeWaitLock.unlock();
-
-    int cnt = 0;
-    mPreviewFrameSize = previewWidth * previewHeight * 3/2;
-    dstOffset = 0;
-    mPreviewHeap = new PmemPool("/dev/pmem_adsp",
-                                MemoryHeapBase::READ_ONLY | MemoryHeapBase::NO_CACHING,
-                                mCameraControlFd,
-                                MSM_PMEM_PREVIEW, //MSM_PMEM_OUTPUT2,
-                                mPreviewFrameSize,
-                                kPreviewBufferCountActual,
-                                mPreviewFrameSize,
-                                "preview");
+            mHeap = new MemoryHeapBase(ashmem_size);
 
-    if (!mPreviewHeap->initialized()) {
-        mPreviewHeap.clear();
-        LOGE("initPreview X: could not initialize Camera preview heap.");
-        return false;
+            completeInitialization();
     }
-    if( mCurrentTarget == TARGET_MSM7630 ) {
-        mPostViewHeap.clear();
-	if(mPostViewHeap == NULL) {
-	    LOGV(" Allocating Postview heap ");
-	    /* mPostViewHeap should be declared only for 7630 target */
-	    mPostViewHeap =
-		new PmemPool("/dev/pmem_adsp",
-			MemoryHeapBase::READ_ONLY | MemoryHeapBase::NO_CACHING,
-			mCameraControlFd,
-			MSM_PMEM_PREVIEW, //MSM_PMEM_OUTPUT2,
-			mPreviewFrameSize,
-			1,
-			mPreviewFrameSize,
-			"postview");
-
-	    if (!mPostViewHeap->initialized()) {
-		mPostViewHeap.clear();
-		LOGE(" Failed to initialize Postview Heap");
-		return false;
-	    }
-	}
-    }
-
-    if( ( mCurrentTarget == TARGET_MSM7630 ) || (mCurrentTarget == TARGET_QSD8250) ) {
 
-        // Allocate video buffers after allocating preview buffers.
-        initRecord();
+    QualcommCameraHardware::PmemPool::PmemPool(const char *pmem_pool,
+                                               int buffer_size, int num_buffers,
+                                               int frame_size,
+                                               int frame_offset,
+                                               const char *name) :
+        QualcommCameraHardware::MemPool(buffer_size,
+                                        num_buffers,
+                                        frame_size,
+                                        frame_offset,
+                                        name)
+    {
+        LOGV("constructing MemPool %s backed by pmem pool %s: "
+             "%d frames @ %d bytes, offset %d, buffer size %d",
+             mName,
+             pmem_pool, num_buffers, frame_size, frame_offset,
+             buffer_size);
+        
+        // Make a new mmap'ed heap that can be shared across processes.
+        
+        mAlignedSize = clp2(buffer_size * num_buffers);
+        
+        sp<MemoryHeapBase> masterHeap = 
+            new MemoryHeapBase(pmem_pool, mAlignedSize, 0);
+        sp<MemoryHeapPmem> pmemHeap = new MemoryHeapPmem(masterHeap, 0);
+        if (pmemHeap->getHeapID() >= 0) {
+            pmemHeap->slap();
+            masterHeap.clear();
+            mHeap = pmemHeap;
+            pmemHeap.clear();
+            
+            mFd = mHeap->getHeapID();
+            if (::ioctl(mFd, PMEM_GET_SIZE, &mSize)) {
+                LOGE("pmem pool %s ioctl(PMEM_GET_SIZE) error %s (%d)",
+                     pmem_pool,
+                     ::strerror(errno), errno);
+                mHeap.clear();
+                return;
+            }
+            
+            LOGV("pmem pool %s ioctl(PMEM_GET_SIZE) is %ld",
+                 pmem_pool,
+                 mSize.len);
+            
+            completeInitialization();
+        }
+        else LOGE("pmem pool %s error: could not create master heap!",
+                  pmem_pool);
+    }
+
+    QualcommCameraHardware::PreviewPmemPool::PreviewPmemPool(
+            int buffer_size, int num_buffers,
+            int frame_size,
+            int frame_offset,
+            const char *name) :
+        QualcommCameraHardware::PmemPool("/dev/pmem_adsp",
+                                         buffer_size,
+                                         num_buffers,
+                                         frame_size,
+                                         frame_offset,
+                                         name)
+    {
+        LOGV("constructing PreviewPmemPool");
+        if (initialized()) {
+            LINK_camera_assoc_pmem(QDSP_MODULE_VFETASK,
+                                   mFd,
+                                   mHeap->base(),
+                                   mAlignedSize,
+                                   0); // external
+        }
     }
 
-    // mDimension will be filled with thumbnail_width, thumbnail_height,
-    // orig_picture_dx, and orig_picture_dy after this function call. We need to
-    // keep it for jpeg_encoder_encode.
-    bool ret = native_set_parm(CAMERA_SET_PARM_DIMENSION,
-                               sizeof(cam_ctrl_dimension_t), &mDimension);
-
-    if (ret) {
-        for (cnt = 0; cnt < kPreviewBufferCount; cnt++) {
-            frames[cnt].fd = mPreviewHeap->mHeap->getHeapID();
-            frames[cnt].buffer =
-                (uint32_t)mPreviewHeap->mHeap->base() + mPreviewHeap->mAlignedBufferSize * cnt;
-            frames[cnt].y_off = 0;
-            frames[cnt].cbcr_off = previewWidth * previewHeight;
-            frames[cnt].path = OUTPUT_TYPE_P; // MSM_FRAME_ENC;
+    QualcommCameraHardware::PreviewPmemPool::~PreviewPmemPool()
+    {
+        LOGV("destroying PreviewPmemPool");
+        if(initialized()) {
+            void *base = mHeap->base();
+            LOGV("releasing PreviewPmemPool memory %p from module %d",
+                 base, QDSP_MODULE_VFETASK);
+            LINK_camera_release_pmem(QDSP_MODULE_VFETASK, base,
+                                     mAlignedSize,
+                                     true);
+        }
+    }
+
+    QualcommCameraHardware::RawPmemPool::RawPmemPool(
+            const char *pmem_pool,
+            int buffer_size, int num_buffers,
+            int frame_size,
+            int frame_offset,
+            const char *name) :
+        QualcommCameraHardware::PmemPool(pmem_pool,
+                                         buffer_size,
+                                         num_buffers,
+                                         frame_size,
+                                         frame_offset,
+                                         name)
+    {
+        LOGV("constructing RawPmemPool");
+
+        if (initialized()) {
+            LINK_camera_assoc_pmem(QDSP_MODULE_VFETASK,
+                                   mFd,
+                                   mHeap->base(),
+                                   mAlignedSize,
+                                   0); // do not free, main module
+            LINK_camera_assoc_pmem(QDSP_MODULE_LPMTASK,
+                                   mFd,
+                                   mHeap->base(),
+                                   mAlignedSize,
+                                   2); // do not free, dependent module
+            LINK_camera_assoc_pmem(QDSP_MODULE_JPEGTASK,
+                                   mFd,
+                                   mHeap->base(),
+                                   mAlignedSize,
+                                   2); // do not free, dependent module
+        }
+    }
+
+    QualcommCameraHardware::RawPmemPool::~RawPmemPool()
+    {
+        LOGV("destroying RawPmemPool");
+        if(initialized()) {
+            void *base = mHeap->base();
+            LOGV("releasing RawPmemPool memory %p from modules %d, %d, and %d",
+                 base, QDSP_MODULE_VFETASK, QDSP_MODULE_LPMTASK,
+                 QDSP_MODULE_JPEGTASK);
+            LINK_camera_release_pmem(QDSP_MODULE_VFETASK,
+                                     base, mAlignedSize, true);
+            LINK_camera_release_pmem(QDSP_MODULE_LPMTASK, 
+                                     base, mAlignedSize, true);
+            LINK_camera_release_pmem(QDSP_MODULE_JPEGTASK,
+                                     base, mAlignedSize, true);
         }
-
-        mFrameThreadWaitLock.lock();
-        pthread_attr_t attr;
-        pthread_attr_init(&attr);
-        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-        frame_parms.frame = frames[kPreviewBufferCount - 1];
-
-        if( mCurrentTarget == TARGET_MSM7630 || mCurrentTarget == TARGET_QSD8250 )
-            frame_parms.video_frame =  recordframes[kPreviewBufferCount - 1];
-        else
-            frame_parms.video_frame =  frames[kPreviewBufferCount - 1];
-
-        LOGV ("initpreview before cam_frame thread carete , video frame  buffer=%lu fd=%d y_off=%d cbcr_off=%d \n",
-          (unsigned long)frame_parms.video_frame.buffer, frame_parms.video_frame.fd, frame_parms.video_frame.y_off,
-          frame_parms.video_frame.cbcr_off);
-        mFrameThreadRunning = !pthread_create(&mFrameThread,
-                                              &attr,
-                                              frame_thread,
-                                              (void*)&(frame_parms));
-        ret = mFrameThreadRunning;
-        mFrameThreadWaitLock.unlock();
     }
-
-    LOGV("initPreview X: %d", ret);
-    return ret;
-}
-
-void QualcommCameraHardware::deinitPreview(void)
-{
-    LOGI("deinitPreview E");
-
-    // When we call deinitPreview(), we signal to the frame thread that it
-    // needs to exit, but we DO NOT WAIT for it to complete here.  The problem
-    // is that deinitPreview is sometimes called from the frame-thread's
-    // callback, when the refcount on the Camera client reaches zero.  If we
-    // called pthread_join(), we would deadlock.  So, we just call
-    // LINK_camframe_terminate() in deinitPreview(), which makes sure that
-    // after the preview callback returns, the camframe thread will exit.  We
-    // could call pthread_join() in initPreview() to join the last frame
-    // thread.  However, we would also have to call pthread_join() in release
-    // as well, shortly before we destroy the object; this would cause the same
-    // deadlock, since release(), like deinitPreview(), may also be called from
-    // the frame-thread's callback.  This we have to make the frame thread
-    // detached, and use a separate mechanism to wait for it to complete.
-
-    LINK_camframe_terminate();
-    LOGI("deinitPreview X");
-}
-
-bool QualcommCameraHardware::initRawSnapshot()
-{
-    LOGV("initRawSnapshot E");
-
-    //get width and height from Dimension Object
-    bool ret = native_set_parm(CAMERA_SET_PARM_DIMENSION,
-                               sizeof(cam_ctrl_dimension_t), &mDimension);
-
-    if(!ret){
-        LOGE("initRawSnapshot X: failed to set dimension");
-        return false;
+    
+    QualcommCameraHardware::MemPool::~MemPool()
+    {
+        LOGV("destroying MemPool %s", mName);
+        if (mFrameSize > 0)
+            delete [] mBuffers;
+        mHeap.clear();
+        LOGV("destroying MemPool %s completed", mName);        
     }
-    int rawSnapshotSize = mDimension.raw_picture_height *
-                           mDimension.raw_picture_width;
-
-    LOGV("raw_snapshot_buffer_size = %d, raw_picture_height = %d, "\
-         "raw_picture_width = %d",
-          rawSnapshotSize, mDimension.raw_picture_height,
-          mDimension.raw_picture_width);
-
-    if (mRawSnapShotPmemHeap != NULL) {
-        LOGV("initRawSnapshot: clearing old mRawSnapShotPmemHeap.");
-        mRawSnapShotPmemHeap.clear();
+    
+    status_t QualcommCameraHardware::MemPool::dump(int fd, const Vector<String16>& args) const
+    {
+        const size_t SIZE = 256;
+        char buffer[SIZE];
+        String8 result;
+        snprintf(buffer, 255, "QualcommCameraHardware::AshmemPool::dump\n");
+        result.append(buffer);
+        if (mName) {
+            snprintf(buffer, 255, "mem pool name (%s)\n", mName);
+            result.append(buffer);
+        }
+        if (mHeap != 0) {
+            snprintf(buffer, 255, "heap base(%p), size(%d), flags(%d), device(%s)\n",
+                     mHeap->getBase(), mHeap->getSize(),
+                     mHeap->getFlags(), mHeap->getDevice());
+            result.append(buffer);
+        }
+        snprintf(buffer, 255, "buffer size (%d), number of buffers (%d),"
+                 " frame size(%d), and frame offset(%d)\n",
+                 mBufferSize, mNumBuffers, mFrameSize, mFrameOffset);
+        result.append(buffer);
+        write(fd, result.string(), result.size());
+        return NO_ERROR;
     }
-
-    //Pmem based pool for Camera Driver
-    mRawSnapShotPmemHeap = new PmemPool("/dev/pmem_adsp",
-                                    MemoryHeapBase::READ_ONLY | MemoryHeapBase::NO_CACHING,
-                                    mCameraControlFd,
-                                    MSM_PMEM_RAW_MAINIMG,
-                                    rawSnapshotSize,
-                                    1,
-                                    rawSnapshotSize,
-                                    "raw pmem snapshot camera");
-
-    if (!mRawSnapShotPmemHeap->initialized()) {
-        mRawSnapShotPmemHeap.clear();
-        LOGE("initRawSnapshot X: error initializing mRawSnapshotHeap");
-        return false;
+    
+    static uint8_t* malloc_preview(uint32_t size,
+            uint32_t *phy_addr, uint32_t index)
+    {
+        sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
+        if (obj != 0) {
+            return (uint8_t *)obj->get_preview_mem(size, phy_addr, index);
+        }
+        return NULL;
     }
-    LOGV("initRawSnapshot X");
-    return true;
-
-}
 
-bool QualcommCameraHardware::initRaw(bool initJpegHeap)
-{
-    int rawWidth, rawHeight;
-
-    mParameters.getPictureSize(&rawWidth, &rawHeight);
-    LOGV("initRaw E: picture size=%dx%d", rawWidth, rawHeight);
-
-    int thumbnailBufferSize;
-    //Thumbnail height should be smaller than Picture height
-    if (rawHeight > (int)thumbnail_sizes[DEFAULT_THUMBNAIL_SETTING].height){
-        mDimension.ui_thumbnail_width =
-                thumbnail_sizes[DEFAULT_THUMBNAIL_SETTING].width;
-        mDimension.ui_thumbnail_height =
-                thumbnail_sizes[DEFAULT_THUMBNAIL_SETTING].height;
-        uint32_t pictureAspectRatio = (uint32_t)((rawWidth * Q12) / rawHeight);
-        uint32_t i;
-        for(i = 0; i < THUMBNAIL_SIZE_COUNT; i++ )
-        {
-            if(thumbnail_sizes[i].aspect_ratio == pictureAspectRatio)
-            {
-                mDimension.ui_thumbnail_width = thumbnail_sizes[i].width;
-                mDimension.ui_thumbnail_height = thumbnail_sizes[i].height;
-                break;
-            }
+    static int free_preview(uint32_t *phy_addr, uint32_t size,
+                            uint32_t index)
+    {
+        sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
+        if (obj != 0) {
+            obj->free_preview_mem(phy_addr, size, index);
         }
-    }
-    else{
-        mDimension.ui_thumbnail_height = THUMBNAIL_SMALL_HEIGHT;
-        mDimension.ui_thumbnail_width =
-                (THUMBNAIL_SMALL_HEIGHT * rawWidth)/ rawHeight;
+        return 0;
     }
 
-    LOGV("Thumbnail Size Width %d Height %d",
-            mDimension.ui_thumbnail_width,
-            mDimension.ui_thumbnail_height);
-
-    thumbnailBufferSize = mDimension.ui_thumbnail_width *
-                          mDimension.ui_thumbnail_height * 3 / 2;
-
-    // mDimension will be filled with thumbnail_width, thumbnail_height,
-    // orig_picture_dx, and orig_picture_dy after this function call. We need to
-    // keep it for jpeg_encoder_encode.
-    bool ret = native_set_parm(CAMERA_SET_PARM_DIMENSION,
-                               sizeof(cam_ctrl_dimension_t), &mDimension);
-    if(!ret) {
-        LOGE("initRaw X: failed to set dimension");
-        return false;
+    static uint8_t* malloc_raw(uint32_t size,
+                                  uint32_t *phy_addr,
+                                  uint32_t index)
+    {
+        sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
+        if (obj != 0) {
+            return (uint8_t *)obj->get_raw_mem(size, phy_addr, index);
+        }
+        return NULL;
     }
 
-    if (mJpegHeap != NULL) {
-        LOGV("initRaw: clearing old mJpegHeap.");
-        mJpegHeap.clear();
+    static int free_raw(uint32_t *phy_addr,
+                        uint32_t size,
+                        uint32_t index)
+    {
+        sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
+        if (obj != 0) {
+            obj->free_raw_mem(phy_addr, size, index);
+        }
+        return 0;
     }
 
-    // Snapshot
-    mRawSize = rawWidth * rawHeight * 3 / 2;
-
-    if( mCurrentTarget == TARGET_MSM7627 )
-             mJpegMaxSize = CEILING16(rawWidth) * CEILING16(rawHeight) * 3 / 2;
-    else
-             mJpegMaxSize = rawWidth * rawHeight * 3 / 2;
-
-    LOGV("initRaw: initializing mRawHeap.");
-    mRawHeap =
-        new PmemPool("/dev/pmem_adsp",
-                     MemoryHeapBase::READ_ONLY | MemoryHeapBase::NO_CACHING,
-                     mCameraControlFd,
-                     MSM_PMEM_MAINIMG,
-                     mJpegMaxSize,
-                     kRawBufferCount,
-                     mRawSize,
-                     "snapshot camera");
-
-    if (!mRawHeap->initialized()) {
-	LOGE("initRaw X failed ");
-	mRawHeap.clear();
-	LOGE("initRaw X: error initializing mRawHeap");
-	return false;
+    static void cb_rex_signal_ready(void)
+    {
+        LOGV("Received REX-ready signal.");
+        rex_init_lock.lock();
+        rex_init_wait.broadcast();
+        rex_init_lock.unlock();
     }
 
-    LOGV("do_mmap snapshot pbuf = %p, pmem_fd = %d",
-         (uint8_t *)mRawHeap->mHeap->base(), mRawHeap->mHeap->getHeapID());
-
-    // Jpeg
-
-    if (initJpegHeap) {
-        LOGV("initRaw: initializing mJpegHeap.");
-        mJpegHeap =
-            new AshmemPool(mJpegMaxSize,
-                           kJpegBufferCount,
-                           0, // we do not know how big the picture will be
-                           "jpeg");
-
-        if (!mJpegHeap->initialized()) {
-            mJpegHeap.clear();
-            mRawHeap.clear();
-            LOGE("initRaw X failed: error initializing mJpegHeap.");
-            return false;
-        }
-
-        // Thumbnails
-
-        mThumbnailHeap =
-            new PmemPool("/dev/pmem_adsp",
-                         MemoryHeapBase::READ_ONLY | MemoryHeapBase::NO_CACHING,
-                         mCameraControlFd,
-                         MSM_PMEM_THUMBNAIL,
-                         thumbnailBufferSize,
-                         1,
-                         thumbnailBufferSize,
-                         "thumbnail");
-
-        if (!mThumbnailHeap->initialized()) {
-            mThumbnailHeap.clear();
-            mJpegHeap.clear();
-            mRawHeap.clear();
-            LOGE("initRaw X failed: error initializing mThumbnailHeap.");
-            return false;
-        }
-    }
-
-    LOGV("initRaw X");
-    return true;
-}
-
-
-void QualcommCameraHardware::deinitRawSnapshot()
-{
-    LOGV("deinitRawSnapshot E");
-    mRawSnapShotPmemHeap.clear();
-    LOGV("deinitRawSnapshot X");
-}
-
-void QualcommCameraHardware::deinitRaw()
-{
-    LOGV("deinitRaw E");
-
-    mThumbnailHeap.clear();
-    mJpegHeap.clear();
-    mRawHeap.clear();
-    mDisplayHeap.clear();
-
-    LOGV("deinitRaw X");
-}
-
-void QualcommCameraHardware::release()
-{
-    LOGD("release E");
-    Mutex::Autolock l(&mLock);
-
-#if DLOPEN_LIBMMCAMERA
-    if (libmmcamera == NULL) {
-        LOGE("ERROR: multiple release!");
-        return;
-    }
-#else
-#warning "Cannot detect multiple release when not dlopen()ing libqcamera!"
-#endif
-
-    int cnt, rc;
-    struct msm_ctrl_cmd ctrlCmd;
-    if (mCameraRunning) {
-        if(mDataCallbackTimestamp && (mMsgEnabled & CAMERA_MSG_VIDEO_FRAME)) {
-            mRecordFrameLock.lock();
-            mReleasedRecordingFrame = true;
-            mRecordWait.signal();
-            mRecordFrameLock.unlock();
-        }
-        stopPreviewInternal();
-    }
-
-    if( mCurrentTarget == TARGET_MSM7630 ) {
-	mPostViewHeap.clear();
-        mPostViewHeap = NULL;
-    }
-    LINK_jpeg_encoder_join();
-    {
-        deinitRaw();
-    }
-    //Signal the snapshot thread
-    mJpegThreadWaitLock.lock();
-    mJpegThreadRunning = false;
-    mJpegThreadWait.signal();
-    mJpegThreadWaitLock.unlock();
-
-    deinitRawSnapshot();
-    
-    ctrlCmd.timeout_ms = 5000;
-    ctrlCmd.length = 0;
-    ctrlCmd.type = (uint16_t)CAMERA_EXIT;
-    ctrlCmd.resp_fd = mCameraControlFd; // FIXME: this will be put in by the kernel
-    if (ioctl(mCameraControlFd, MSM_CAM_IOCTL_CTRL_COMMAND, &ctrlCmd) < 0)
-          LOGE("ioctl CAMERA_EXIT fd %d error %s",
-              mCameraControlFd, strerror(errno));
-
-    LINK_release_cam_conf_thread();
-    close(mCameraControlFd);
-    mCameraControlFd = -1;
-    if(fb_fd >= 0) {
-        close(fb_fd);
-        fb_fd = -1;
-    }
-#if DLOPEN_LIBMMCAMERA
-    if (libmmcamera) {
-        ::dlclose(libmmcamera);
-        LOGV("dlclose(libqcamera)");
-        libmmcamera = NULL;
-    }
-#endif
-
-    singleton_lock.lock();
-    singleton_releasing = true;
-    singleton_releasing_start_time = systemTime();
-    singleton_lock.unlock();
-
-    LOGD("release X");
-}
-
-QualcommCameraHardware::~QualcommCameraHardware()
-{
-    LOGD("~QualcommCameraHardware E");
-    singleton_lock.lock();
-
-    if( mCurrentTarget == TARGET_MSM7630 || mCurrentTarget == TARGET_QSD8250 ) {
-        delete [] recordframes;
-        recordframes = NULL;
-    }
-    singleton.clear();
-    singleton_releasing = false;
-    singleton_releasing_start_time = 0;
-    singleton_wait.signal();
-    singleton_lock.unlock();
-    LOGD("~QualcommCameraHardware X");
-}
-
-sp<IMemoryHeap> QualcommCameraHardware::getRawHeap() const
-{
-    LOGV("getRawHeap");
-    return mDisplayHeap != NULL ? mDisplayHeap->mHeap : NULL;
-}
-
-sp<IMemoryHeap> QualcommCameraHardware::getPreviewHeap() const
-{
-    LOGV("getPreviewHeap");
-    return mPreviewHeap != NULL ? mPreviewHeap->mHeap : NULL;
-}
-
-status_t QualcommCameraHardware::startPreviewInternal()
-{
-    LOGV("in startPreviewInternal : E");
-    if(mCameraRunning) {
-        LOGV("startPreview X: preview already running.");
-        return NO_ERROR;
-    }
-
-    if (!mPreviewInitialized) {
-        mLastQueuedFrame = NULL;
-        mPreviewInitialized = initPreview();
-        if (!mPreviewInitialized) {
-            LOGE("startPreview X initPreview failed.  Not starting preview.");
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    {
-        Mutex::Autolock cameraRunningLock(&mCameraRunningLock);
-        if(( mCurrentTarget != TARGET_MSM7630 ) &&
-                (mCurrentTarget != TARGET_QSD8250))
-            mCameraRunning = native_start_preview(mCameraControlFd);
-        else
-            mCameraRunning = native_start_video(mCameraControlFd);
-    }
-
-    if(!mCameraRunning) {
-        deinitPreview();
-        mPreviewInitialized = false;
-        mOverlay = NULL;
-        LOGE("startPreview X: native_start_preview failed!");
-        return UNKNOWN_ERROR;
-    }
-
-    //Reset the Gps Information
-    exif_table_numEntries = 0;
-
-    if(native_get_maxzoom(mCameraControlFd, (void *)&mMaxZoom) == true){
-        LOGD("Maximum zoom value is %d", mMaxZoom);
-        mParameters.set("zoom-supported", "true");
-    } else {
-        LOGE("Failed to get maximum zoom value...setting max zoom to zero");
-        mParameters.set("zoom-supported", "false");
-        mMaxZoom = 0;
-    }
-    mParameters.set("max-zoom",mMaxZoom);
-
-    LOGV("startPreviewInternal X");
-    return NO_ERROR;
-}
-
-status_t QualcommCameraHardware::startPreview()
-{
-    LOGV("startPreview E");
-    Mutex::Autolock l(&mLock);
-    return startPreviewInternal();
-}
-
-void QualcommCameraHardware::stopPreviewInternal()
-{
-    LOGV("stopPreviewInternal E: %d", mCameraRunning);
-    if (mCameraRunning) {
-        // Cancel auto focus.
-        {
-            if (mNotifyCallback && (mMsgEnabled & CAMERA_MSG_FOCUS)) {
-                cancelAutoFocusInternal();
-            }
-        }
-
-        Mutex::Autolock l(&mCamframeTimeoutLock);
-        {
-            Mutex::Autolock cameraRunningLock(&mCameraRunningLock);
-            if(!camframe_timeout_flag) {
-                if (( mCurrentTarget != TARGET_MSM7630 ) &&
-                        (mCurrentTarget != TARGET_QSD8250))
-                    mCameraRunning = !native_stop_preview(mCameraControlFd);
-                else
-                    mCameraRunning = !native_stop_video(mCameraControlFd);
-            } else {
-                /* This means that the camframetimeout was issued.
-                 * But we did not issue native_stop_preview(), so we
-                 * need to update mCameraRunning to indicate that
-                 * Camera is no longer running. */
-                mCameraRunning = 0;
-            }
-        }
-
-	if (!mCameraRunning && mPreviewInitialized) {
-	    deinitPreview();
-	    if( ( mCurrentTarget == TARGET_MSM7630 ) || (mCurrentTarget == TARGET_QSD8250)) {
-		mVideoThreadWaitLock.lock();
-		LOGV("in stopPreviewInternal: making mVideoThreadExit 1");
-		mVideoThreadExit = 1;
-		mVideoThreadWaitLock.unlock();
-		//  720p : signal the video thread , and check in video thread if stop is called, if so exit video thread.
-		pthread_mutex_lock(&(g_busy_frame_queue.mut));
-		pthread_cond_signal(&(g_busy_frame_queue.wait));
-		pthread_mutex_unlock(&(g_busy_frame_queue.mut));
-                /* Flush the Busy Q */
-                cam_frame_flush_video();
-                /* Flush the Free Q */
-                LINK_cam_frame_flush_free_video();
-	    }
-	    mPreviewInitialized = false;
-	}
-	else LOGE("stopPreviewInternal: failed to stop preview");
-    }
-    LOGV("stopPreviewInternal X: %d", mCameraRunning);
-}
-
-void QualcommCameraHardware::stopPreview()
-{
-    LOGV("stopPreview: E");
-    Mutex::Autolock l(&mLock);
-    {
-        if (mDataCallbackTimestamp && (mMsgEnabled & CAMERA_MSG_VIDEO_FRAME))
-            return;
-    }
-    stopPreviewInternal();
-    LOGV("stopPreview: X");
-}
-
-void QualcommCameraHardware::runAutoFocus()
-{
-    bool status = true;
-    void *libhandle = NULL;
-    isp3a_af_mode_t afMode;
-
-    mAutoFocusThreadLock.lock();
-
-    if(!sensorType->hasAutoFocusSupport){
-        bool status = false;
-        mCallbackLock.lock();
-        bool autoFocusEnabled = mNotifyCallback && (mMsgEnabled & CAMERA_MSG_FOCUS);
-        notify_callback cb = mNotifyCallback;
-        void *data = mCallbackCookie;
-        mCallbackLock.unlock();
-        if (autoFocusEnabled)
-            cb(CAMERA_MSG_FOCUS, true, 0, data);
-        goto done;
-    }
-
-    // Skip autofocus if focus mode is infinity.
-    if ((mParameters.get(CameraParameters::KEY_FOCUS_MODE) == 0)
-           || (strcmp(mParameters.get(CameraParameters::KEY_FOCUS_MODE),
-               CameraParameters::FOCUS_MODE_INFINITY) == 0)) {
-        goto done;
-    }
-
-    mAutoFocusFd = open(MSM_CAMERA_CONTROL, O_RDWR);
-    if (mAutoFocusFd < 0) {
-        LOGE("autofocus: cannot open %s: %s",
-             MSM_CAMERA_CONTROL,
-             strerror(errno));
-        mAutoFocusThreadRunning = false;
-        mAutoFocusThreadLock.unlock();
-        return;
-    }
-
-#if DLOPEN_LIBMMCAMERA
-    // We need to maintain a reference to libqcamera.so for the duration of the
-    // AF thread, because we do not know when it will exit relative to the
-    // lifetime of this object.  We do not want to dlclose() libqcamera while
-    // LINK_cam_frame is still running.
-    libhandle = ::dlopen("liboemcamera.so", RTLD_NOW);
-    LOGV("AF: loading libqcamera at %p", libhandle);
-    if (!libhandle) {
-        LOGE("FATAL ERROR: could not dlopen liboemcamera.so: %s", dlerror());
-        close(mAutoFocusFd);
-        mAutoFocusFd = -1;
-        mAutoFocusThreadRunning = false;
-        mAutoFocusThreadLock.unlock();
-        return;
-    }
-#endif
-
-    afMode = (isp3a_af_mode_t)attr_lookup(focus_modes,
-                                sizeof(focus_modes) / sizeof(str_map),
-                                mParameters.get(CameraParameters::KEY_FOCUS_MODE));
-
-    /* This will block until either AF completes or is cancelled. */
-    LOGV("af start (fd %d mode %d)", mAutoFocusFd, afMode);
-    status_t err;
-    err = mAfLock.tryLock();
-    if(err == NO_ERROR) {
-        {
-            Mutex::Autolock cameraRunningLock(&mCameraRunningLock);
-            if(mCameraRunning){
-                LOGV("Start AF");
-                status = native_set_afmode(mAutoFocusFd, afMode);
-            }else{
-                LOGV("As Camera preview is not running, AF not issued");
-                status = false;
-            }
-        }
-        mAfLock.unlock();
-    }
-    else{
-        //AF Cancel would have acquired the lock,
-        //so, no need to perform any AF
-        LOGV("As Cancel auto focus is in progress, auto focus request "
-                "is ignored");
-        status = FALSE;
-    }
-
-    LOGV("af done: %d", (int)status);
-    close(mAutoFocusFd);
-    mAutoFocusFd = -1;
-
-done:
-    mAutoFocusThreadRunning = false;
-    mAutoFocusThreadLock.unlock();
-
-    mCallbackLock.lock();
-    bool autoFocusEnabled = mNotifyCallback && (mMsgEnabled & CAMERA_MSG_FOCUS);
-    notify_callback cb = mNotifyCallback;
-    void *data = mCallbackCookie;
-    mCallbackLock.unlock();
-    if (autoFocusEnabled)
-        cb(CAMERA_MSG_FOCUS, status, 0, data);
-
-#if DLOPEN_LIBMMCAMERA
-    if (libhandle) {
-        ::dlclose(libhandle);
-        LOGV("AF: dlclose(libqcamera)");
-    }
-#endif
-}
-
-status_t QualcommCameraHardware::cancelAutoFocusInternal()
-{
-    LOGV("cancelAutoFocusInternal E");
-
-    if(!sensorType->hasAutoFocusSupport){
-        LOGV("cancelAutoFocusInternal X");
-        return NO_ERROR;
-    }
-
-#if 0
-    if (mAutoFocusFd < 0) {
-        LOGV("cancelAutoFocusInternal X: not in progress");
-        return NO_ERROR;
-    }
-#endif
-
-    status_t rc = NO_ERROR;
-    status_t err;
-    err = mAfLock.tryLock();
-    if(err == NO_ERROR) {
-        //Got Lock, means either AF hasn't started or
-        // AF is done. So no need to cancel it, just change the state
-        LOGV("As Auto Focus is not in progress, Cancel Auto Focus "
-                "is ignored");
-        mAfLock.unlock();
-    }
-    else {
-        //AF is in Progess, So cancel it
-        LOGV("Lock busy...cancel AF");
-        rc = native_cancel_afmode(mCameraControlFd, mAutoFocusFd) ?
-                NO_ERROR :
-                UNKNOWN_ERROR;
-    }
-
-
-
-    LOGV("cancelAutoFocusInternal X: %d", rc);
-    return rc;
-}
-
-void *auto_focus_thread(void *user)
-{
-    LOGV("auto_focus_thread E");
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-        obj->runAutoFocus();
-    }
-    else LOGW("not starting autofocus: the object went away!");
-    LOGV("auto_focus_thread X");
-    return NULL;
-}
-
-status_t QualcommCameraHardware::autoFocus()
-{
-    LOGV("autoFocus E");
-    Mutex::Autolock l(&mLock);
-
-    if (mCameraControlFd < 0) {
-        LOGE("not starting autofocus: main control fd %d", mCameraControlFd);
-        return UNKNOWN_ERROR;
-    }
-
-    {
-        mAutoFocusThreadLock.lock();
-        if (!mAutoFocusThreadRunning) {
-            if (native_prepare_snapshot(mCameraControlFd) == FALSE) {
-               LOGE("native_prepare_snapshot failed!\n");
-               mAutoFocusThreadLock.unlock();
-               return UNKNOWN_ERROR;
-            }
-
-            // Create a detached thread here so that we don't have to wait
-            // for it when we cancel AF.
-            pthread_t thr;
-            pthread_attr_t attr;
-            pthread_attr_init(&attr);
-            pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-            mAutoFocusThreadRunning =
-                !pthread_create(&thr, &attr,
-                                auto_focus_thread, NULL);
-            if (!mAutoFocusThreadRunning) {
-                LOGE("failed to start autofocus thread");
-                mAutoFocusThreadLock.unlock();
-                return UNKNOWN_ERROR;
-            }
-        }
-        mAutoFocusThreadLock.unlock();
-    }
-
-    LOGV("autoFocus X");
-    return NO_ERROR;
-}
-
-status_t QualcommCameraHardware::cancelAutoFocus()
-{
-    LOGV("cancelAutoFocus E");
-    Mutex::Autolock l(&mLock);
-
-    int rc = NO_ERROR;
-    if (mCameraRunning && mNotifyCallback && (mMsgEnabled & CAMERA_MSG_FOCUS)) {
-        rc = cancelAutoFocusInternal();
-    }
-
-    LOGV("cancelAutoFocus X");
-    return rc;
-}
-
-void QualcommCameraHardware::runSnapshotThread(void *data)
-{
-    LOGV("runSnapshotThread E");
-    if(mSnapshotFormat == PICTURE_FORMAT_JPEG){
-        if (native_start_snapshot(mCameraControlFd))
-            receiveRawPicture();
-        else
-            LOGE("main: native_start_snapshot failed!");
-    } else if(mSnapshotFormat == PICTURE_FORMAT_RAW){
-        if(native_start_raw_snapshot(mCameraControlFd)){
-           receiveRawSnapshot();
-        } else {
-           LOGE("main: native_start_raw_snapshot failed!");
-        }
-    }
-    mInSnapshotModeWaitLock.lock();
-    mInSnapshotMode = false;
-    mInSnapshotModeWait.signal();
-    mInSnapshotModeWaitLock.unlock();
-
-    mSnapshotFormat = 0;
-
-    mJpegThreadWaitLock.lock();
-    while (mJpegThreadRunning) {
-        LOGV("runSnapshotThread: waiting for jpeg thread to complete.");
-        mJpegThreadWait.wait(mJpegThreadWaitLock);
-        LOGV("runSnapshotThread: jpeg thread completed.");
-    }
-    mJpegThreadWaitLock.unlock();
-    //clear the resources
-    LINK_jpeg_encoder_join();
-    deinitRaw();
-
-    mSnapshotThreadWaitLock.lock();
-    mSnapshotThreadRunning = false;
-    mSnapshotThreadWait.signal();
-    mSnapshotThreadWaitLock.unlock();
-
-    LOGV("runSnapshotThread X");
-}
-
-void *snapshot_thread(void *user)
-{
-    LOGD("snapshot_thread E");
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-        obj->runSnapshotThread(user);
-    }
-    else LOGW("not starting snapshot thread: the object went away!");
-    LOGD("snapshot_thread X");
-    return NULL;
-}
-
-status_t QualcommCameraHardware::takePicture()
-{
-    LOGV("takePicture(%d)", mMsgEnabled);
-    Mutex::Autolock l(&mLock);
-
-    // Wait for old snapshot thread to complete.
-    mSnapshotThreadWaitLock.lock();
-    while (mSnapshotThreadRunning) {
-        LOGV("takePicture: waiting for old snapshot thread to complete.");
-        mSnapshotThreadWait.wait(mSnapshotThreadWaitLock);
-        LOGV("takePicture: old snapshot thread completed.");
-    }
-
-    if( mCurrentTarget == TARGET_MSM7630 ) {
-	/* Store the last frame queued for preview. This
-	 * shall be used as postview */
-	storePreviewFrameForPostview();
-    }
-
-    //mSnapshotFormat is protected by mSnapshotThreadWaitLock
-    if(mParameters.getPictureFormat() != 0 &&
-            !strcmp(mParameters.getPictureFormat(),
-                    CameraParameters::PIXEL_FORMAT_RAW))
-        mSnapshotFormat = PICTURE_FORMAT_RAW;
-    else
-        mSnapshotFormat = PICTURE_FORMAT_JPEG;
-
-    if(mSnapshotFormat == PICTURE_FORMAT_JPEG){
-        if(!native_prepare_snapshot(mCameraControlFd)) {
-            mSnapshotThreadWaitLock.unlock();
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    stopPreviewInternal();
-
-    if(mSnapshotFormat == PICTURE_FORMAT_JPEG){
-        if (!initRaw(mDataCallback && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE))) {
-            LOGE("initRaw failed.  Not taking picture.");
-            mSnapshotThreadWaitLock.unlock();
-            return UNKNOWN_ERROR;
-        }
-    } else if(mSnapshotFormat == PICTURE_FORMAT_RAW ){
-        if(!initRawSnapshot()){
-            LOGE("initRawSnapshot failed. Not taking picture.");
-            mSnapshotThreadWaitLock.unlock();
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    mShutterLock.lock();
-    mShutterPending = true;
-    mShutterLock.unlock();
-
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    mSnapshotThreadRunning = !pthread_create(&mSnapshotThread,
-                                             &attr,
-                                             snapshot_thread,
-                                             NULL);
-    mSnapshotThreadWaitLock.unlock();
-
-    mInSnapshotModeWaitLock.lock();
-    mInSnapshotMode = true;
-    mInSnapshotModeWaitLock.unlock();
-
-    LOGV("takePicture: X");
-    return mSnapshotThreadRunning ? NO_ERROR : UNKNOWN_ERROR;
-}
-
-status_t QualcommCameraHardware::cancelPicture()
-{
-    status_t rc;
-    LOGV("cancelPicture: E");
-    rc = native_stop_snapshot(mCameraControlFd) ? NO_ERROR : UNKNOWN_ERROR;
-    LOGV("cancelPicture: X: %d", rc);
-    return rc;
-}
-
-status_t QualcommCameraHardware::setParameters(const CameraParameters& params)
-{
-    LOGV("setParameters: E params = %p", &params);
-
-    Mutex::Autolock l(&mLock);
-    status_t rc, final_rc = NO_ERROR;
-
-    if ((rc = setPreviewSize(params))) final_rc = rc;
-    if ((rc = setPreviewFrameRate(params))) final_rc = rc;
-    if ((rc = setPictureSize(params)))  final_rc = rc;
-    if ((rc = setJpegQuality(params)))  final_rc = rc;
-    if ((rc = setAntibanding(params)))  final_rc = rc;
-    //if ((rc = setAutoExposure(params))) final_rc = rc;
-    if ((rc = setWhiteBalance(params))) final_rc = rc;
-    if ((rc = setEffect(params)))       final_rc = rc;
-    if ((rc = setFlash(params)))        final_rc = rc;
-    if ((rc = setGpsLocation(params)))  final_rc = rc;
-    if ((rc = setRotation(params)))     final_rc = rc;
-    if ((rc = setZoom(params)))         final_rc = rc;
-    if ((rc = setFocusMode(params)))    final_rc = rc;
-    if ((rc = setOrientation(params)))  final_rc = rc;
-    if ((rc = setBrightness(params)))   final_rc = rc;
-    if ((rc = setExposureCompensation(params)))   final_rc = rc;
-    if ((rc = setLensshadeValue(params)))  final_rc = rc;
-    if ((rc = setISOValue(params)))  final_rc = rc;
-    if ((rc = setPictureFormat(params))) final_rc = rc;
-    if ((rc = setSharpness(params)))    final_rc = rc;
-    if ((rc = setContrast(params)))     final_rc = rc;
-    if ((rc = setSaturation(params)))   final_rc = rc;
-
-    LOGV("setParameters: X");
-    //return final_rc;
-    /* Just let whatever passed go through */
-    return NO_ERROR;
-}
-
-CameraParameters QualcommCameraHardware::getParameters() const
-{
-    LOGV("getParameters: EX");
-    return mParameters;
-}
-
-status_t QualcommCameraHardware::sendCommand(int32_t command, int32_t arg1,
-                                             int32_t arg2)
-{
-    LOGV("sendCommand: EX");
-    return BAD_VALUE;
-}
-
-extern "C" sp<CameraHardwareInterface> openCameraHardware()
-{
-    LOGV("openCameraHardware: call createInstance");
-    return QualcommCameraHardware::createInstance();
-}
-
-static CameraInfo sCameraInfo[] = {
-	{
-		CAMERA_FACING_BACK,
-		90,  /* orientation */
-	}
-};
-
-extern "C" int HAL_getNumberOfCameras()
-{
-	return sizeof(sCameraInfo) / sizeof(sCameraInfo[0]);
-}
-
-extern "C" void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
-{
-	memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(CameraInfo));
-}
-
-extern "C" sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
-{
-	LOGV("openCameraHardware: call createInstance");
-	return QualcommCameraHardware::createInstance();
-}
-
-wp<QualcommCameraHardware> QualcommCameraHardware::singleton;
-
-// If the hardware already exists, return a strong pointer to the current
-// object. If not, create a new hardware object, put it in the singleton,
-// and return it.
-sp<CameraHardwareInterface> QualcommCameraHardware::createInstance()
-{
-    LOGD("createInstance: E");
-
-    singleton_lock.lock();
-
-    // Wait until the previous release is done.
-    while (singleton_releasing) {
-        if((singleton_releasing_start_time != 0) &&
-                (systemTime() - singleton_releasing_start_time) > SINGLETON_RELEASING_WAIT_TIME){
-            LOGV("in createinstance system time is %lld %lld %lld ",
-                    systemTime(), singleton_releasing_start_time, SINGLETON_RELEASING_WAIT_TIME);
-            singleton_lock.unlock();
-            LOGE("Previous singleton is busy and time out exceeded. Returning null");
-            return NULL;
-        }
-        LOGI("Wait for previous release.");
-        singleton_wait.waitRelative(singleton_lock, SINGLETON_RELEASING_RECHECK_TIMEOUT);
-        LOGI("out of Wait for previous release.");
-    }
-
-    if (singleton != 0) {
-        sp<CameraHardwareInterface> hardware = singleton.promote();
-        if (hardware != 0) {
-            LOGD("createInstance: X return existing hardware=%p", &(*hardware));
-            singleton_lock.unlock();
-            return hardware;
-        }
-    }
-
-    {
-        struct stat st;
-        int rc = stat("/dev/oncrpc", &st);
-        if (rc < 0) {
-            LOGD("createInstance: X failed to create hardware: %s", strerror(errno));
-            singleton_lock.unlock();
-            return NULL;
-        }
-    }
-
-    QualcommCameraHardware *cam = new QualcommCameraHardware();
-    sp<QualcommCameraHardware> hardware(cam);
-    singleton = hardware;
-
-    if (!cam->startCamera()) {
-        LOGE("%s: startCamera failed!", __FUNCTION__);
-        singleton_lock.unlock();
-        return NULL;
-    }
-
-    cam->initDefaultParameters();
-    LOGD("createInstance: X created hardware=%p", &(*hardware));
-    singleton_lock.unlock();
-    return hardware;
-}
-
-// For internal use only, hence the strong pointer to the derived type.
-sp<QualcommCameraHardware> QualcommCameraHardware::getInstance()
-{
-    sp<CameraHardwareInterface> hardware = singleton.promote();
-    if (hardware != 0) {
-        //    LOGV("getInstance: X old instance of hardware");
-        return sp<QualcommCameraHardware>(static_cast<QualcommCameraHardware*>(hardware.get()));
-    } else {
-        LOGV("getInstance: X new instance of hardware");
-        return sp<QualcommCameraHardware>();
-    }
-}
-void QualcommCameraHardware::receiveRecordingFrame(struct msm_frame *frame)
-{
-    LOGV("receiveRecordingFrame E");
-    // post busy frame
-    if (frame)
-    {
-        cam_frame_post_video (frame);
-    }
-    else LOGE("in  receiveRecordingFrame frame is NULL");
-    LOGV("receiveRecordingFrame X");
-}
-
-
-bool QualcommCameraHardware::native_zoom_image(int fd, int srcOffset, int dstOffSet, common_crop_t *crop)
-{
-    int result = 0;
-    struct mdp_blit_req *e;
-    struct timeval td1, td2;
-
-    /* Initialize yuv structure */
-    zoomImage.list.count = 1;
-
-    e = &zoomImage.list.req[0];
-
-    e->src.width = previewWidth;
-    e->src.height = previewHeight;
-    e->src.format = MDP_Y_CBCR_H2V2;
-    e->src.offset = srcOffset;
-    e->src.memory_id = fd;
-
-    e->dst.width = previewWidth;
-    e->dst.height = previewHeight;
-    e->dst.format = MDP_Y_CBCR_H2V2;
-    e->dst.offset = dstOffSet;
-    e->dst.memory_id = fd;
-
-    e->transp_mask = 0xffffffff;
-    e->flags = 0;
-    e->alpha = 0xff;
-    if (crop->in2_w != 0 || crop->in2_h != 0) {
-        e->src_rect.x = (crop->out2_w - crop->in2_w + 1) / 2 - 1;
-        e->src_rect.y = (crop->out2_h - crop->in2_h + 1) / 2 - 1;
-        e->src_rect.w = crop->in2_w;
-        e->src_rect.h = crop->in2_h;
-    } else {
-        e->src_rect.x = 0;
-        e->src_rect.y = 0;
-        e->src_rect.w = previewWidth;
-        e->src_rect.h = previewHeight;
-    }
-    //LOGV(" native_zoom : SRC_RECT : x,y = %d,%d \t w,h = %d, %d",
-    //        e->src_rect.x, e->src_rect.y, e->src_rect.w, e->src_rect.h);
-
-    e->dst_rect.x = 0;
-    e->dst_rect.y = 0;
-    e->dst_rect.w = previewWidth;
-    e->dst_rect.h = previewHeight;
-
-    result = ioctl(fb_fd, MSMFB_BLIT, &zoomImage.list);
-    if (result < 0) {
-        LOGE("MSM_FBIOBLT failed! line=%d\n", __LINE__);
-        return FALSE;
-    }
-    return TRUE;
-}
-
-void QualcommCameraHardware::debugShowPreviewFPS() const
-{
-    static int mFrameCount;
-    static int mLastFrameCount = 0;
-    static nsecs_t mLastFpsTime = 0;
-    static float mFps = 0;
-    mFrameCount++;
-    nsecs_t now = systemTime();
-    nsecs_t diff = now - mLastFpsTime;
-    if (diff > ms2ns(250)) {
-        mFps =  ((mFrameCount - mLastFrameCount) * float(s2ns(1))) / diff;
-        LOGI("Preview Frames Per Second: %.4f", mFps);
-        mLastFpsTime = now;
-        mLastFrameCount = mFrameCount;
-    }
-}
-
-void QualcommCameraHardware::debugShowVideoFPS() const
-{
-    static int mFrameCount;
-    static int mLastFrameCount = 0;
-    static nsecs_t mLastFpsTime = 0;
-    static float mFps = 0;
-    mFrameCount++;
-    nsecs_t now = systemTime();
-    nsecs_t diff = now - mLastFpsTime;
-    if (diff > ms2ns(250)) {
-        mFps =  ((mFrameCount - mLastFrameCount) * float(s2ns(1))) / diff;
-        LOGI("Video Frames Per Second: %.4f", mFps);
-        mLastFpsTime = now;
-        mLastFrameCount = mFrameCount;
-    }
-}
-void QualcommCameraHardware::receivePreviewFrame(struct msm_frame *frame)
-{
-//    LOGV("receivePreviewFrame E");
-
-    if (!mCameraRunning) {
-        LOGE("ignoring preview callback--camera has been stopped");
-        return;
-    }
-
-    if (UNLIKELY(mDebugFps)) {
-        debugShowPreviewFPS();
-    }
-
-    mCallbackLock.lock();
-    int msgEnabled = mMsgEnabled;
-    data_callback pcb = mDataCallback;
-    void *pdata = mCallbackCookie;
-    data_callback_timestamp rcb = mDataCallbackTimestamp;
-    void *rdata = mCallbackCookie;
-    mCallbackLock.unlock();
-
-    // Find the offset within the heap of the current buffer.
-    ssize_t offset_addr =
-        (ssize_t)frame->buffer - (ssize_t)mPreviewHeap->mHeap->base();
-    ssize_t offset = offset_addr / mPreviewHeap->mAlignedBufferSize;
-
-    common_crop_t *crop = (common_crop_t *) (frame->cropinfo);
-
-    mInPreviewCallback = true;
-	if (crop->in2_w != 0 || crop->in2_h != 0) {
-	    dstOffset = (dstOffset + 1) % NUM_MORE_BUFS;
-	    offset = kPreviewBufferCount + dstOffset;
-	    ssize_t dstOffset_addr = offset * mPreviewHeap->mAlignedBufferSize;
-	    if( !native_zoom_image(mPreviewHeap->mHeap->getHeapID(),
-			offset_addr, dstOffset_addr, crop)) {
-		LOGE(" Error while doing MDP zoom ");
-                offset = offset_addr / mPreviewHeap->mAlignedBufferSize;
-	    }
-	}
-    if (pcb != NULL && (msgEnabled & CAMERA_MSG_PREVIEW_FRAME))
-        pcb(CAMERA_MSG_PREVIEW_FRAME, mPreviewHeap->mBuffers[offset],
-            pdata);
-
-    // If output  is NOT enabled (targets otherthan 7x30 currently..)
-    if( (mCurrentTarget != TARGET_MSM7630 ) &&  (mCurrentTarget != TARGET_QSD8250)) {
-        if(rcb != NULL && (msgEnabled & CAMERA_MSG_VIDEO_FRAME)) {
-            rcb(systemTime(), CAMERA_MSG_VIDEO_FRAME, mPreviewHeap->mBuffers[offset], rdata);
-            Mutex::Autolock rLock(&mRecordFrameLock);
-            if (mReleasedRecordingFrame != true) {
-                LOGV("block waiting for frame release");
-                mRecordWait.wait(mRecordFrameLock);
-                LOGV("frame released, continuing");
-            }
-            mReleasedRecordingFrame = false;
-        }
-    }
-    mInPreviewCallback = false;
-
-//    LOGV("receivePreviewFrame X");
-}
-
-
-bool QualcommCameraHardware::initRecord()
-{
-    char *pmem_region;
-
-    LOGV("initREcord E");
-
-    mRecordFrameSize = (mDimension.video_width  * mDimension.video_height *3)/2;
-
-    if( mCurrentTarget == TARGET_QSD8250 )
-        pmem_region = "/dev/pmem_smipool";
-    else
-        pmem_region = "/dev/pmem_adsp";
-
-    mRecordHeap = new PmemPool(pmem_region,
-                               MemoryHeapBase::READ_ONLY | MemoryHeapBase::NO_CACHING,
-                                mCameraControlFd,
-                                MSM_PMEM_VIDEO,
-                                mRecordFrameSize,
-                                kRecordBufferCount,
-                                mRecordFrameSize,
-                                "record");
-
-    if (!mRecordHeap->initialized()) {
-        mRecordHeap.clear();
-        LOGE("initRecord X: could not initialize record heap.");
-        return false;
-    }
-    for (int cnt = 0; cnt < kRecordBufferCount; cnt++) {
-        recordframes[cnt].fd = mRecordHeap->mHeap->getHeapID();
-        recordframes[cnt].buffer =
-            (uint32_t)mRecordHeap->mHeap->base() + mRecordHeap->mAlignedBufferSize * cnt;
-        recordframes[cnt].y_off = 0;
-        recordframes[cnt].cbcr_off = mDimension.video_width  * mDimension.video_height;
-        recordframes[cnt].path = OUTPUT_TYPE_V;
-
-        LOGV ("initRecord :  record heap , video buffers  buffer=%lu fd=%d y_off=%d cbcr_off=%d \n",
-          (unsigned long)recordframes[cnt].buffer, recordframes[cnt].fd, recordframes[cnt].y_off,
-          recordframes[cnt].cbcr_off);
-    }
-
-    // initial setup : buffers 1,2,3 with kernel , 4 with camframe , 5,6,7,8 in free Q
-    // flush the busy Q
-    cam_frame_flush_video();
-
-    mVideoThreadWaitLock.lock();
-    while (mVideoThreadRunning) {
-        LOGV("initRecord: waiting for old video thread to complete.");
-        mVideoThreadWait.wait(mVideoThreadWaitLock);
-        LOGV("initRecord : old video thread completed.");
-    }
-    mVideoThreadWaitLock.unlock();
-
-    // flush free queue and add 5,6,7,8 buffers.
-    LINK_cam_frame_flush_free_video();
-    for(int i=ACTIVE_VIDEO_BUFFERS+1;i <kRecordBufferCount; i++)
-        LINK_camframe_free_video(&recordframes[i]);
-    LOGV("initREcord X");
-
-    return true;
-}
-
-status_t QualcommCameraHardware::startRecording()
-{
-    LOGV("startRecording E");
-    int ret;
-    Mutex::Autolock l(&mLock);
-    mReleasedRecordingFrame = false;
-    if( (ret=startPreviewInternal())== NO_ERROR){
-        if( ( mCurrentTarget == TARGET_MSM7630 ) || (mCurrentTarget == TARGET_QSD8250))  {
-            LOGV(" in startREcording : calling native_start_recording");
-            native_start_recording(mCameraControlFd);
-            recordingState = 1;
-            // Remove the left out frames in busy Q and them in free Q.
-            // this should be done before starting video_thread so that,
-            // frames in previous recording are flushed out.
-            LOGV("frames in busy Q = %d", g_busy_frame_queue.num_of_frames);
-            while((g_busy_frame_queue.num_of_frames) >0){
-                msm_frame* vframe = cam_frame_get_video ();
-                LINK_camframe_free_video(vframe);
-            }
-            LOGV("frames in busy Q = %d after deQueing", g_busy_frame_queue.num_of_frames);
-
-            // Start video thread and wait for busy frames to be encoded, this thread
-            // should be closed in stopRecording
-            mVideoThreadWaitLock.lock();
-            mVideoThreadExit = 0;
-            pthread_attr_t attr;
-            pthread_attr_init(&attr);
-            pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-            mVideoThreadRunning = pthread_create(&mVideoThread,
-                                              &attr,
-                                              video_thread,
-                                              NULL);
-            mVideoThreadWaitLock.unlock();
-            // Remove the left out frames in busy Q and them in free Q.
-        }
-    }
-    return ret;
-}
-
-void QualcommCameraHardware::stopRecording()
-{
-    LOGV("stopRecording: E");
-    Mutex::Autolock l(&mLock);
-    {
-        mRecordFrameLock.lock();
-        mReleasedRecordingFrame = true;
-        mRecordWait.signal();
-        mRecordFrameLock.unlock();
-
-        if(mDataCallback && !(mCurrentTarget == TARGET_QSD8250) &&
-                         (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME)) {
-            LOGV("stopRecording: X, preview still in progress");
-            return;
-        }
-    }
-    // If output2 enabled, exit video thread, invoke stop recording ioctl
-    if( ( mCurrentTarget == TARGET_MSM7630 ) || (mCurrentTarget == TARGET_QSD8250))  {
-        mVideoThreadWaitLock.lock();
-        mVideoThreadExit = 1;
-        mVideoThreadWaitLock.unlock();
-        native_stop_recording(mCameraControlFd);
-
-        pthread_mutex_lock(&(g_busy_frame_queue.mut));
-        pthread_cond_signal(&(g_busy_frame_queue.wait));
-        pthread_mutex_unlock(&(g_busy_frame_queue.mut));
-    }
-    else  // for other targets where output2 is not enabled
-        stopPreviewInternal();
-
-    recordingState = 0; // recording not started
-    LOGV("stopRecording: X");
-}
-
-void QualcommCameraHardware::releaseRecordingFrame(
-       const sp<IMemory>& mem __attribute__((unused)))
-{
-    LOGV("releaseRecordingFrame E");
-    Mutex::Autolock rLock(&mRecordFrameLock);
-    mReleasedRecordingFrame = true;
-    mRecordWait.signal();
-
-    // Ff 7x30 : add the frame to the free camframe queue
-    if( (mCurrentTarget == TARGET_MSM7630 )  || (mCurrentTarget == TARGET_QSD8250)) {
-        ssize_t offset;
-        size_t size;
-        sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);
-        msm_frame* releaseframe = NULL;
-        LOGV(" in release recording frame :  heap base %d offset %d buffer %d ", heap->base(), offset, heap->base() + offset );
-        int cnt;
-        for (cnt = 0; cnt < kRecordBufferCount; cnt++) {
-            if((unsigned int)recordframes[cnt].buffer == (unsigned int)(heap->base()+ offset)){
-                LOGV("in release recording frame found match , releasing buffer %d", (unsigned int)recordframes[cnt].buffer);
-                releaseframe = &recordframes[cnt];
-                break;
-            }
-        }
-        if(cnt < kRecordBufferCount) {
-            // do this only if frame thread is running
-            mFrameThreadWaitLock.lock();
-            if(mFrameThreadRunning )
-                LINK_camframe_free_video(releaseframe);
-
-            mFrameThreadWaitLock.unlock();
-        } else {
-            LOGE("in release recordingframe XXXXX error , buffer not found");
-            for (int i=0; i< kRecordBufferCount; i++) {
-                 LOGE(" recordframes[%d].buffer = %d", i, (unsigned int)recordframes[i].buffer);
-            }
-        }
-    }
-
-    LOGV("releaseRecordingFrame X");
-}
-
-bool QualcommCameraHardware::recordingEnabled()
-{
-    return mCameraRunning && mDataCallbackTimestamp && (mMsgEnabled & CAMERA_MSG_VIDEO_FRAME);
-}
-
-void QualcommCameraHardware::notifyShutter(common_crop_t *crop)
-{
-    mShutterLock.lock();
-    image_rect_type size;
-
-    if (mShutterPending && mNotifyCallback && (mMsgEnabled & CAMERA_MSG_SHUTTER)) {
-        LOGV("out2_w=%d, out2_h=%d, in2_w=%d, in2_h=%d",
-             crop->out2_w, crop->out2_h, crop->in2_w, crop->in2_h);
-        LOGV("out1_w=%d, out1_h=%d, in1_w=%d, in1_h=%d",
-             crop->out1_w, crop->out1_h, crop->in1_w, crop->in1_h);
-
-        // To workaround a bug in MDP which happens if either
-        // dimension > 2048, we display the thumbnail instead.
-        mDisplayHeap = mRawHeap;
-        if (crop->in1_w == 0 || crop->in1_h == 0) {
-            // Full size
-            size.width = mDimension.picture_width;
-            size.height = mDimension.picture_height;
-            if (size.width > 2048 || size.height > 2048) {
-                size.width = mDimension.ui_thumbnail_width;
-                size.height = mDimension.ui_thumbnail_height;
-                mDisplayHeap = mThumbnailHeap;
-            }
-        } else {
-            // Cropped
-            size.width = (crop->in2_w + jpegPadding) & ~1;
-            size.height = (crop->in2_h + jpegPadding) & ~1;
-            if (size.width > 2048 || size.height > 2048) {
-                size.width = (crop->in1_w + jpegPadding) & ~1;
-                size.height = (crop->in1_h + jpegPadding) & ~1;
-                mDisplayHeap = mThumbnailHeap;
-            }
-        }
-        /* Now, invoke Notify Callback to unregister preview buffer
-         * and register postview buffer with surface flinger. */
-        mNotifyCallback(CAMERA_MSG_SHUTTER, (int32_t)&size, 0,
-                        mCallbackCookie);
-        mShutterPending = false;
-    }
-    mShutterLock.unlock();
-}
-
-static void receive_shutter_callback(common_crop_t *crop)
-{
-    LOGV("receive_shutter_callback: E");
-    LOGV("receive_shutter_callback: X");
-}
-
-// Crop the picture in place.
-static void crop_yuv420(uint32_t width, uint32_t height,
-                 uint32_t cropped_width, uint32_t cropped_height,
-                 uint8_t *image)
-{
-    uint32_t i, x, y;
-    uint8_t* chroma_src, *chroma_dst;
-
-    // Calculate the start position of the cropped area.
-    x = (width - cropped_width) / 2;
-    y = (height - cropped_height) / 2;
-    x &= ~1;
-    y &= ~1;
-
-    // Copy luma component.
-    for(i = 0; i < cropped_height; i++)
-        memcpy(image + i * cropped_width,
-               image + width * (y + i) + x,
-               cropped_width);
-
-    chroma_src = image + width * height;
-    chroma_dst = image + cropped_width * cropped_height;
-
-    // Copy chroma components.
-    cropped_height /= 2;
-    y /= 2;
-    for(i = 0; i < cropped_height; i++)
-        memcpy(chroma_dst + i * cropped_width,
-               chroma_src + width * (y + i) + x,
-               cropped_width);
-}
-
-
-void QualcommCameraHardware::receiveRawSnapshot(){
-    LOGV("receiveRawSnapshot E");
-
-    Mutex::Autolock cbLock(&mCallbackLock);
-
-    if (mDataCallback && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
-
-        if(native_get_picture(mCameraControlFd, &mCrop) == false) {
-            LOGE("receiveRawSnapshot X: native_get_picture failed!");
-            return;
-        }
-        /* Its necessary to issue another notifyShutter here with
-         * mPlayShutterSoundOnly as FALSE, since that is when the
-         * preview buffers are unregistered with the surface flinger.
-         * That is necessary otherwise the preview memory wont be
-         * deallocated.
-         */
-        notifyShutter(&mCrop);
-
-       if (mDataCallback && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE))
-           mDataCallback(CAMERA_MSG_COMPRESSED_IMAGE, mRawSnapShotPmemHeap->mBuffers[0],
-                mCallbackCookie);
-
-    }
-
-    //cleanup
-    deinitRawSnapshot();
-
-    LOGV("receiveRawSnapshot X");
-}
-
-void QualcommCameraHardware::receiveRawPicture()
-{
-    LOGV("receiveRawPicture: E");
-
-    Mutex::Autolock cbLock(&mCallbackLock);
-    if (mDataCallback && (mMsgEnabled & CAMERA_MSG_RAW_IMAGE)) {
-        if(native_get_picture(mCameraControlFd, &mCrop) == false) {
-            LOGE("getPicture failed!");
-            return;
-        }
-        mCrop.in1_w &= ~1;
-        mCrop.in1_h &= ~1;
-        mCrop.in2_w &= ~1;
-        mCrop.in2_h &= ~1;
-
-
-        // Crop the image if zoomed.
-        if (mCrop.in2_w != 0 && mCrop.in2_h != 0 &&
-                ((mCrop.in2_w + jpegPadding) < mCrop.out2_w) &&
-                ((mCrop.in2_h + jpegPadding) < mCrop.out2_h) &&
-                ((mCrop.in1_w + jpegPadding) < mCrop.out1_w)  &&
-                ((mCrop.in1_h + jpegPadding) < mCrop.out1_h) ) {
-
-            // By the time native_get_picture returns, picture is taken. Call
-            // shutter callback if cam config thread has not done that.
-            notifyShutter(&mCrop);
-                    crop_yuv420(mCrop.out2_w, mCrop.out2_h, (mCrop.in2_w + jpegPadding), (mCrop.in2_h + jpegPadding),
-                            (uint8_t *)mRawHeap->mHeap->base());
-                    crop_yuv420(mCrop.out1_w, mCrop.out1_h, (mCrop.in1_w + jpegPadding), (mCrop.in1_h + jpegPadding),
-                            (uint8_t *)mThumbnailHeap->mHeap->base());
-
-            // We do not need jpeg encoder to upscale the image. Set the new
-            // dimension for encoder.
-            mDimension.orig_picture_dx = mCrop.in2_w + jpegPadding;
-            mDimension.orig_picture_dy = mCrop.in2_h + jpegPadding;
-            mDimension.thumbnail_width = mCrop.in1_w + jpegPadding;
-            mDimension.thumbnail_height = mCrop.in1_h + jpegPadding;
-        }else {
-            memset(&mCrop, 0 ,sizeof(mCrop));
-            // By the time native_get_picture returns, picture is taken. Call
-            // shutter callback if cam config thread has not done that.
-            notifyShutter(&mCrop);
-        }
-
-   if (mDataCallback && (mMsgEnabled & CAMERA_MSG_RAW_IMAGE))
-       mDataCallback(CAMERA_MSG_RAW_IMAGE, mDisplayHeap->mBuffers[0],
-                            mCallbackCookie);
-    }
-    else LOGV("Raw-picture callback was canceled--skipping.");
-
-    if (mDataCallback && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
-        mJpegSize = 0;
-        mJpegThreadWaitLock.lock();
-        if (LINK_jpeg_encoder_init()) {
-            mJpegThreadRunning = true;
-            mJpegThreadWaitLock.unlock();
-            if(native_jpeg_encode()) {
-                LOGV("receiveRawPicture: X (success)");
-                return;
-            }
-            LOGE("jpeg encoding failed");
-        }
-        else {
-            LOGE("receiveRawPicture X: jpeg_encoder_init failed.");
-            mJpegThreadWaitLock.unlock();
-        }
-    }
-    else LOGV("JPEG callback is NULL, not encoding image.");
-    deinitRaw();
-    LOGV("receiveRawPicture: X");
-}
-
-void QualcommCameraHardware::receiveJpegPictureFragment(
-    uint8_t *buff_ptr, uint32_t buff_size)
-{
-    uint32_t remaining = mJpegHeap->mHeap->virtualSize();
-    remaining -= mJpegSize;
-    uint8_t *base = (uint8_t *)mJpegHeap->mHeap->base();
-
-    LOGV("receiveJpegPictureFragment size %d", buff_size);
-    if (buff_size > remaining) {
-        LOGE("receiveJpegPictureFragment: size %d exceeds what "
-             "remains in JPEG heap (%d), truncating",
-             buff_size,
-             remaining);
-        buff_size = remaining;
-    }
-    memcpy(base + mJpegSize, buff_ptr, buff_size);
-    mJpegSize += buff_size;
-}
-
-void QualcommCameraHardware::receiveJpegPicture(void)
-{
-    LOGV("receiveJpegPicture: E image (%d uint8_ts out of %d)",
-         mJpegSize, mJpegHeap->mBufferSize);
-    Mutex::Autolock cbLock(&mCallbackLock);
-
-    int index = 0, rc;
-
-    if (mDataCallback && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
-        // The reason we do not allocate into mJpegHeap->mBuffers[offset] is
-        // that the JPEG image's size will probably change from one snapshot
-        // to the next, so we cannot reuse the MemoryBase object.
-        sp<MemoryBase> buffer = new
-            MemoryBase(mJpegHeap->mHeap,
-                       index * mJpegHeap->mBufferSize +
-                       0,
-                       mJpegSize);
-        mDataCallback(CAMERA_MSG_COMPRESSED_IMAGE, buffer, mCallbackCookie);
-        buffer = NULL;
-    }
-    else LOGV("JPEG callback was cancelled--not delivering image.");
-
-    mJpegThreadWaitLock.lock();
-    mJpegThreadRunning = false;
-    mJpegThreadWait.signal();
-    mJpegThreadWaitLock.unlock();
-
-    LOGV("receiveJpegPicture: X callback done.");
-}
-
-bool QualcommCameraHardware::previewEnabled()
-{
-    return mCameraRunning && mDataCallback && (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME);
-}
-
-status_t QualcommCameraHardware::setPreviewSize(const CameraParameters& params)
-{
-    int width, height;
-    params.getPreviewSize(&width, &height);
-    LOGV("requested preview size %d x %d", width, height);
-
-    // Validate the preview size
-    for (size_t i = 0; i < previewSizeCount; ++i) {
-        if (width == supportedPreviewSizes[i].width
-           && height == supportedPreviewSizes[i].height) {
-            // 720p , preview can be 768X432 (currently for 7x30 and 8k
-            // targets)
-            if(width == 1280 && height == 720 &&
-             ((mCurrentTarget == TARGET_MSM7630) || (mCurrentTarget == TARGET_QSD8250))){
-                LOGD("change preview resolution to 768X432 since recording is in 720p");
-                mDimension.display_width = preview_sizes[2].width;
-                mDimension.display_height= preview_sizes[2].height;
-            }else {
-                mDimension.display_width = width;
-                mDimension.display_height= height;
-            }
-            mParameters.setPreviewSize(width, height);
-            return NO_ERROR;
-        }
-    }
-    LOGE("Invalid preview size requested: %dx%d", width, height);
-    return BAD_VALUE;
-}
-
-status_t QualcommCameraHardware::setPreviewFrameRate(const CameraParameters& params)
-{
-    if((!strcmp(mSensorInfo.name, "vx6953")) ||
-        (!strcmp(mSensorInfo.name, "VX6953")) ||
-        (!strcmp(sensorType->name, "2mp"))){
-        LOGI("set fps is not supported for this sensor");
-        return NO_ERROR;
-    }
-    uint16_t previousFps = (uint16_t)mParameters.getPreviewFrameRate();
-    uint16_t fps = (uint16_t)params.getPreviewFrameRate();
-    LOGV("requested preview frame rate  is %u", fps);
-
-    if(mInitialized && (fps == previousFps)){
-        LOGV("fps same as previous fps");
-        return NO_ERROR;
-    }
-
-    if(MINIMUM_FPS <= fps && fps <=MAXIMUM_FPS){
-        mParameters.setPreviewFrameRate(fps);
-        bool ret = native_set_parm(CAMERA_SET_PARM_FPS,
-                sizeof(fps), (void *)&fps);
-        return ret ? NO_ERROR : UNKNOWN_ERROR;
-    }
-    return BAD_VALUE;
-
-}
-
-status_t QualcommCameraHardware::setPictureSize(const CameraParameters& params)
-{
-    int width, height;
-    params.getPictureSize(&width, &height);
-    LOGV("requested picture size %d x %d", width, height);
-
-    // Validate the picture size
-    for (int i = 0; i < supportedPictureSizesCount; ++i) {
-        if (width == picture_sizes_ptr[i].width
-                && height == picture_sizes_ptr[i].height) {
-            if (!strcmp(mSensorInfo.name, "ov5642") 
-					&& width == 2592) {
-				/* WTF... The max this "5MPx" sensor supports is 4.75 */
-                width = 2560 ; height = 1920;
-            }
-            mParameters.setPictureSize(width, height);
-            mDimension.picture_width = width;
-            mDimension.picture_height = height;
-            return NO_ERROR;
-        }
-    }
-    /* Dimension not among the ones in the list. Check if
-     * its a valid dimension, if it is, then configure the
-     * camera accordingly. else reject it.
-     */
-    if( isValidDimension(width, height) ) {
-        mParameters.setPictureSize(width, height);
-        mDimension.picture_width = width;
-        mDimension.picture_height = height;
-        return NO_ERROR;
-    } else
-        LOGE("Invalid picture size requested: %dx%d", width, height);
-    return BAD_VALUE;
-}
-
-status_t QualcommCameraHardware::setJpegQuality(const CameraParameters& params) {
-    status_t rc = NO_ERROR;
-    int quality = params.getInt(CameraParameters::KEY_JPEG_QUALITY);
-    if (quality > 0 && quality <= 100) {
-        mParameters.set(CameraParameters::KEY_JPEG_QUALITY, quality);
-    } else {
-        LOGE("Invalid jpeg quality=%d", quality);
-        rc = BAD_VALUE;
-    }
-
-    quality = params.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY);
-    if (quality > 0 && quality <= 100) {
-        mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, quality);
-    } else {
-        LOGE("Invalid jpeg thumbnail quality=%d", quality);
-        rc = BAD_VALUE;
-    }
-    return rc;
-}
-
-status_t QualcommCameraHardware::setEffect(const CameraParameters& params)
-{
-
-    const char *str_wb = mParameters.get(CameraParameters::KEY_WHITE_BALANCE);
-    int32_t value_wb = attr_lookup(whitebalance, sizeof(whitebalance) / sizeof(str_map), str_wb);
-    const char *str = params.get(CameraParameters::KEY_EFFECT);
-
-    if (str != NULL) {
-        int32_t value = attr_lookup(effects, sizeof(effects) / sizeof(str_map), str);
-        if (value != NOT_FOUND) {
-            if(!strcmp(sensorType->name, "2mp") && (value != CAMERA_EFFECT_OFF)
-               &&(value != CAMERA_EFFECT_MONO) && (value != CAMERA_EFFECT_NEGATIVE)
-               &&(value != CAMERA_EFFECT_SOLARIZE) && (value != CAMERA_EFFECT_SEPIA)) {
-                LOGE("Special effect parameter is not supported for this sensor");
-                return NO_ERROR;
-            }
-
-           if(((value == CAMERA_EFFECT_MONO) || (value == CAMERA_EFFECT_NEGATIVE)
-           || (value == CAMERA_EFFECT_AQUA) || (value == CAMERA_EFFECT_SEPIA))
-               && (value_wb != CAMERA_WB_AUTO)) {
-               LOGE("Color Effect value will not be set " \
-               "when the whitebalance selected is %s", str_wb);
-               return NO_ERROR;
-           }
-           else {
-               mParameters.set(CameraParameters::KEY_EFFECT, str);
-               bool ret = native_set_parm(CAMERA_SET_PARM_EFFECT, sizeof(value),
-                                           (void *)&value);
-               return ret ? NO_ERROR : UNKNOWN_ERROR;
-          }
-        }
-    }
-    LOGE("Invalid effect value: %s", (str == NULL) ? "NULL" : str);
-    return BAD_VALUE;
-}
-
-status_t QualcommCameraHardware::setAutoExposure(const CameraParameters& params)
-{
-    if(!strcmp(sensorType->name, "2mp")) {
-        LOGE("Auto Exposure not supported for this sensor");
-        return NO_ERROR;
-    }
-    const char *str = params.get(CameraParameters::KEY_AUTO_EXPOSURE);
-    if (str != NULL) {
-        int32_t value = attr_lookup(autoexposure, sizeof(autoexposure) / sizeof(str_map), str);
-        if (value != NOT_FOUND) {
-            mParameters.set(CameraParameters::KEY_AUTO_EXPOSURE, str);
-            bool ret = native_set_parm(CAMERA_SET_PARM_EXPOSURE, sizeof(value),
-                                       (void *)&value);
-            return ret ? NO_ERROR : UNKNOWN_ERROR;
-        }
-    }
-    LOGE("Invalid auto exposure value: %s", (str == NULL) ? "NULL" : str);
-    return BAD_VALUE;
-}
-
-status_t QualcommCameraHardware::setSharpness(const CameraParameters& params)
-{
-    if(!strcmp(sensorType->name, "2mp")) {
-        LOGE("Sharpness not supported for this sensor");
-        return NO_ERROR;
-    }
-    int sharpness = params.getInt(CameraParameters::KEY_SHARPNESS);
-    if((sharpness < CAMERA_MIN_SHARPNESS
-            || sharpness > CAMERA_MAX_SHARPNESS))
-        return UNKNOWN_ERROR;
-
-    LOGV("setting sharpness %d", sharpness);
-    mParameters.set(CameraParameters::KEY_SHARPNESS, sharpness);
-    bool ret = native_set_parm(CAMERA_SET_PARM_SHARPNESS, sizeof(sharpness),
-                               (void *)&sharpness);
-    return ret ? NO_ERROR : UNKNOWN_ERROR;
-}
-
-status_t QualcommCameraHardware::setContrast(const CameraParameters& params)
-{
-    if(!strcmp(sensorType->name, "2mp")) {
-        LOGE("Contrast not supported for this sensor");
-        return NO_ERROR;
-    }
-    int contrast = params.getInt(CameraParameters::KEY_CONTRAST);
-    if((contrast < CAMERA_MIN_CONTRAST)
-            || (contrast > CAMERA_MAX_CONTRAST))
-        return UNKNOWN_ERROR;
-
-    LOGV("setting contrast %d", contrast);
-    mParameters.set(CameraParameters::KEY_CONTRAST, contrast);
-    bool ret = native_set_parm(CAMERA_SET_PARM_CONTRAST, sizeof(contrast),
-                               (void *)&contrast);
-    return ret ? NO_ERROR : UNKNOWN_ERROR;
-}
-
-status_t QualcommCameraHardware::setSaturation(const CameraParameters& params)
-{
-    if(!strcmp(sensorType->name, "2mp")) {
-        LOGE("Saturation not supported for this sensor");
-        return NO_ERROR;
-    }
-
-    const char *str = params.get(CameraParameters::KEY_EFFECT);
-    int32_t value = attr_lookup(effects, sizeof(effects) / sizeof(str_map), str);
-
-    if( (value != CAMERA_EFFECT_MONO) && (value != CAMERA_EFFECT_NEGATIVE)
-	    && (value != CAMERA_EFFECT_AQUA) && (value != CAMERA_EFFECT_SEPIA)) {
-
-	int saturation = params.getInt(CameraParameters::KEY_SATURATION);
-	if((saturation < CAMERA_MIN_SATURATION)
-		|| (saturation > CAMERA_MAX_SATURATION))
-	    return UNKNOWN_ERROR;
-
-	LOGV("setting saturation %d", saturation);
-	mParameters.set(CameraParameters::KEY_SATURATION, saturation);
-	bool ret = native_set_parm(CAMERA_SET_PARM_SATURATION, sizeof(saturation),
-		(void *)&saturation);
-	return ret ? NO_ERROR : UNKNOWN_ERROR;
-    } else {
-	LOGE(" Saturation value will not be set " \
-		"when the effect selected is %s", str);
-	return NO_ERROR;
-    }
-}
-
-status_t QualcommCameraHardware::setBrightness(const CameraParameters& params) {
-        int brightness = params.getInt("luma-adaptation");
-        if (mBrightness !=  brightness) {
-            LOGV(" new brightness value : %d ", brightness);
-            mBrightness =  brightness;
-
-            bool ret = native_set_parm(CAMERA_SET_PARM_BRIGHTNESS, sizeof(mBrightness),
-                                       (void *)&mBrightness);
-            return ret ? NO_ERROR : UNKNOWN_ERROR;
-        } else {
-            return NO_ERROR;
-        }
-}
-
-status_t QualcommCameraHardware::setExposureCompensation(const CameraParameters& params) {
-        int expcomp = params.getInt("exposure-compensation");
-
-	mParameters.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, expcomp);
-
-	if(!strcmp(sensorType->name, "3mp"))
-	  expcomp+=4;
-	else
-	  expcomp+=2;
-
-        bool ret = native_set_parm(CAMERA_SET_PARM_EXPOSURE_COMPENSATION, sizeof(expcomp),
-                                       (void *)&expcomp);
-
-        return ret ? NO_ERROR : UNKNOWN_ERROR;
-}
-
-status_t QualcommCameraHardware::setWhiteBalance(const CameraParameters& params)
-{
-
-    const char *str_effect = mParameters.get(CameraParameters::KEY_EFFECT);
-    int32_t value_effect = attr_lookup(effects, sizeof(effects) / sizeof(str_map), str_effect);
-
-    if( (value_effect != CAMERA_EFFECT_MONO) && (value_effect != CAMERA_EFFECT_NEGATIVE)
-    && (value_effect != CAMERA_EFFECT_AQUA) && (value_effect != CAMERA_EFFECT_SEPIA)) {
-        const char *str = params.get(CameraParameters::KEY_WHITE_BALANCE);
-
-        if (str != NULL) {
-            int32_t value = attr_lookup(whitebalance, sizeof(whitebalance) / sizeof(str_map), str);
-            if (value != NOT_FOUND) {
-                mParameters.set(CameraParameters::KEY_WHITE_BALANCE, str);
-                bool ret = native_set_parm(CAMERA_SET_PARM_WB, sizeof(value),
-                                           (void *)&value);
-                return ret ? NO_ERROR : UNKNOWN_ERROR;
-            }
-        }
-        LOGE("Invalid whitebalance value: %s", (str == NULL) ? "NULL" : str);
-        return BAD_VALUE;
-    } else {
-            LOGE("Whitebalance value will not be set " \
-            "when the effect selected is %s", str_effect);
-            return NO_ERROR;
-    }
-}
-
-status_t QualcommCameraHardware::setFlash(const CameraParameters& params)
-{
-    if (!mSensorInfo.flash_enabled) {
-        LOGV("%s: flash not supported", __FUNCTION__);
-        return NO_ERROR;
-    }
-
-    const char *str = params.get(CameraParameters::KEY_FLASH_MODE);
-    if (str != NULL) {
-        int32_t value = attr_lookup(flash, sizeof(flash) / sizeof(str_map), str);
-        if (value != NOT_FOUND) {
-            mParameters.set(CameraParameters::KEY_FLASH_MODE, str);
-            bool ret = native_set_parm(CAMERA_SET_PARM_LED_MODE,
-                                       sizeof(value), (void *)&value);
-            return ret ? NO_ERROR : UNKNOWN_ERROR;
-        }
-    }
-    LOGE("Invalid flash mode value: %s", (str == NULL) ? "NULL" : str);
-    return BAD_VALUE;
-}
-
-status_t QualcommCameraHardware::setAntibanding(const CameraParameters& params)
-{
-    if(!strcmp(sensorType->name, "2mp") || !strcmp(mSensorInfo.name, "ov5642")) {
-        LOGE("Parameter AntiBanding is not supported for this sensor");
-        return NO_ERROR;
-    }
-    return NO_ERROR;
-    const char *str = params.get(CameraParameters::KEY_ANTIBANDING);
-    if (str != NULL) {
-        int value = (camera_antibanding_type)attr_lookup(
-          antibanding, sizeof(antibanding) / sizeof(str_map), str);
-        if (value != NOT_FOUND) {
-            camera_antibanding_type temp = (camera_antibanding_type) value;
-            mParameters.set(CameraParameters::KEY_ANTIBANDING, str);
-            bool ret;
-            if (temp == CAMERA_ANTIBANDING_AUTO) {
-                ret = native_set_parm(CAMERA_ENABLE_AFD,
-                            0, NULL);
-            } else {
-                ret = native_set_parm(CAMERA_SET_PARM_ANTIBANDING,
-                            sizeof(camera_antibanding_type), (void *)&temp);
-            }
-            return ret ? NO_ERROR : UNKNOWN_ERROR;
-        }
-    }
-    LOGE("Invalid antibanding value: %s", (str == NULL) ? "NULL" : str);
-    return BAD_VALUE;
-}
-
-status_t QualcommCameraHardware::setLensshadeValue(const CameraParameters& params)
-{
-    if( (!strcmp(sensorType->name, "2mp")) ||
-        (!strcmp(mSensorInfo.name, "vx6953")) ||
-		(!strcmp(mSensorInfo.name, "ov5642")) ||
-	(!strcmp(mSensorInfo.name, "VX6953")) ) {
-        LOGI("Parameter Rolloff is not supported for this sensor");
-        return NO_ERROR;
-    }
-    const char *str = params.get(CameraParameters::KEY_LENSSHADE);
-    if (str != NULL) {
-        int value = attr_lookup(lensshade,
-                                    sizeof(lensshade) / sizeof(str_map), str);
-        if (value != NOT_FOUND) {
-            int8_t temp = (int8_t)value;
-            mParameters.set(CameraParameters::KEY_LENSSHADE, str);
-            native_set_parm(CAMERA_SET_PARM_ROLLOFF, sizeof(int8_t), (void *)&temp);
-            return NO_ERROR;
-        }
-    }
-    LOGE("Invalid lensShade value: %s", (str == NULL) ? "NULL" : str);
-    return BAD_VALUE;
-}
-
-status_t  QualcommCameraHardware::setISOValue(const CameraParameters& params) {
-    int8_t temp_hjr;
-    const char *str = params.get(CameraParameters::KEY_ISO_MODE);
-    if (str != NULL) {
-        int value = (camera_iso_mode_type)attr_lookup(
-          iso, sizeof(iso) / sizeof(str_map), str);
-        if (value != NOT_FOUND) {
-            camera_iso_mode_type temp = (camera_iso_mode_type) value;
-            if (value == CAMERA_ISO_DEBLUR) {
-               temp_hjr = true;
-               native_set_parm(CAMERA_SET_PARM_HJR, sizeof(int8_t), (void*)&temp_hjr);
-               mHJR = value;
-            }
-            else {
-               if (mHJR == CAMERA_ISO_DEBLUR) {
-                   temp_hjr = false;
-                   native_set_parm(CAMERA_SET_PARM_HJR, sizeof(int8_t), (void*)&temp_hjr);
-                   mHJR = value;
-               }
-            }
-
-            mParameters.set(CameraParameters::KEY_ISO_MODE, str);
-            native_set_parm(CAMERA_SET_PARM_ISO, sizeof(camera_iso_mode_type), (void *)&temp);
-            return NO_ERROR;
-        }
-    }
-    LOGE("Invalid Iso value: %s", (str == NULL) ? "NULL" : str);
-    return BAD_VALUE;
-}
-
-
-status_t QualcommCameraHardware::setGpsLocation(const CameraParameters& params)
-{
-    const char *latitude = params.get(CameraParameters::KEY_GPS_LATITUDE);
-    if (latitude) {
-        mParameters.set(CameraParameters::KEY_GPS_LATITUDE, latitude);
-    }
-
-    const char *latitudeRef = params.get(CameraParameters::KEY_GPS_LATITUDE_REF);
-    if (latitudeRef) {
-        mParameters.set(CameraParameters::KEY_GPS_LATITUDE_REF, latitudeRef);
-    }
-
-    const char *longitude = params.get(CameraParameters::KEY_GPS_LONGITUDE);
-    if (longitude) {
-        mParameters.set(CameraParameters::KEY_GPS_LONGITUDE, longitude);
-    }
-
-    const char *longitudeRef = params.get(CameraParameters::KEY_GPS_LONGITUDE_REF);
-    if (longitudeRef) {
-        mParameters.set(CameraParameters::KEY_GPS_LONGITUDE_REF, longitudeRef);
-    }
-
-    const char *altitudeRef = params.get(CameraParameters::KEY_GPS_ALTITUDE_REF);
-    if (altitudeRef) {
-        mParameters.set(CameraParameters::KEY_GPS_ALTITUDE_REF, altitudeRef);
-    }
-
-    const char *altitude = params.get(CameraParameters::KEY_GPS_ALTITUDE);
-    if (altitude) {
-        mParameters.set(CameraParameters::KEY_GPS_ALTITUDE, altitude);
-    }
-
-    const char *status = params.get(CameraParameters::KEY_GPS_STATUS);
-    if (status) {
-        mParameters.set(CameraParameters::KEY_GPS_STATUS, status);
-    }
-
-    const char *dateTime = params.get(CameraParameters::KEY_EXIF_DATETIME);
-    if (dateTime) {
-        mParameters.set(CameraParameters::KEY_EXIF_DATETIME, dateTime);
-    }
-
-    const char *timestamp = params.get(CameraParameters::KEY_GPS_TIMESTAMP);
-    if (timestamp) {
-        mParameters.set(CameraParameters::KEY_GPS_TIMESTAMP, timestamp);
-    }
-    return NO_ERROR;
-}
-
-status_t QualcommCameraHardware::setRotation(const CameraParameters& params)
-{
-    status_t rc = NO_ERROR;
-    int rotation = params.getInt(CameraParameters::KEY_ROTATION);
-    if (rotation != NOT_FOUND) {
-        if (rotation == 0 || rotation == 90 || rotation == 180
-            || rotation == 270) {
-          mParameters.set(CameraParameters::KEY_ROTATION, rotation);
-        } else {
-            LOGE("Invalid rotation value: %d", rotation);
-            rc = BAD_VALUE;
-        }
-    }
-    return rc;
-}
-
-status_t QualcommCameraHardware::setZoom(const CameraParameters& params)
-{
-    status_t rc = NO_ERROR;
-    // No matter how many different zoom values the driver can provide, HAL
-    // provides applictations the same number of zoom levels. The maximum driver
-    // zoom value depends on sensor output (VFE input) and preview size (VFE
-    // output) because VFE can only crop and cannot upscale. If the preview size
-    // is bigger, the maximum zoom ratio is smaller. However, we want the
-    // zoom ratio of each zoom level is always the same whatever the preview
-    // size is. Ex: zoom level 1 is always 1.2x, zoom level 2 is 1.44x, etc. So,
-    // we need to have a fixed maximum zoom value and do read it from the
-    // driver.
-    static const int ZOOM_STEP = 1;
-    int32_t zoom_level = params.getInt("zoom");
-
-    LOGV("Set zoom=%d", zoom_level);
-    if(zoom_level >= 0 && zoom_level <= mMaxZoom) {
-        mParameters.set("zoom", zoom_level);
-        int32_t zoom_value = ZOOM_STEP * zoom_level;
-        bool ret = native_set_parm(CAMERA_SET_PARM_ZOOM,
-            sizeof(zoom_value), (void *)&zoom_value);
-        rc = ret ? NO_ERROR : UNKNOWN_ERROR;
-    } else {
-        rc = BAD_VALUE;
-    }
-
-    return rc;
-}
-
-status_t QualcommCameraHardware::setFocusMode(const CameraParameters& params)
-{
-    const char *str = params.get(CameraParameters::KEY_FOCUS_MODE);
-    if (str != NULL) {
-        int32_t value = attr_lookup(focus_modes,
-                                    sizeof(focus_modes) / sizeof(str_map), str);
-        if (value != NOT_FOUND) {
-            mParameters.set(CameraParameters::KEY_FOCUS_MODE, str);
-            // Focus step is reset to infinity when preview is started. We do
-            // not need to do anything now.
-            return NO_ERROR;
-        }
-    }
-    LOGE("Invalid focus mode value: %s", (str == NULL) ? "NULL" : str);
-    return BAD_VALUE;
-}
-
-status_t QualcommCameraHardware::setOrientation(const CameraParameters& params)
-{
-    const char *str = params.get("orientation");
-
-    if (str != NULL) {
-        if (strcmp(str, "portrait") == 0 || strcmp(str, "landscape") == 0) {
-            // Camera service needs this to decide if the preview frames and raw
-            // pictures should be rotated.
-            mParameters.set("orientation", str);
-        } else {
-            LOGE("Invalid orientation value: %s", str);
-            return BAD_VALUE;
-        }
-    }
-    return NO_ERROR;
-}
-
-status_t QualcommCameraHardware::setPictureFormat(const CameraParameters& params)
-{
-    const char * str = params.get(CameraParameters::KEY_PICTURE_FORMAT);
-
-    if(str != NULL){
-        int32_t value = attr_lookup(picture_formats,
-                                    sizeof(picture_formats) / sizeof(str_map), str);
-        if(value != NOT_FOUND){
-            mParameters.set(CameraParameters::KEY_PICTURE_FORMAT, str);
-        } else {
-            LOGE("Invalid Picture Format value: %s", str);
-            return BAD_VALUE;
-        }
-    }
-    return NO_ERROR;
-}
-
-QualcommCameraHardware::MemPool::MemPool(int buffer_size, int num_buffers,
-                                         int frame_size,
-                                         const char *name) :
-    mBufferSize(buffer_size),
-    mNumBuffers(num_buffers),
-    mFrameSize(frame_size),
-    mBuffers(NULL), mName(name)
-{
-    int page_size_minus_1 = getpagesize() - 1;
-    mAlignedBufferSize = (buffer_size + page_size_minus_1) & (~page_size_minus_1);
-}
-
-void QualcommCameraHardware::MemPool::completeInitialization()
-{
-    // If we do not know how big the frame will be, we wait to allocate
-    // the buffers describing the individual frames until we do know their
-    // size.
-
-    if (mFrameSize > 0) {
-        mBuffers = new sp<MemoryBase>[mNumBuffers];
-        for (int i = 0; i < mNumBuffers; i++) {
-            mBuffers[i] = new
-                MemoryBase(mHeap,
-                           i * mAlignedBufferSize,
-                           mFrameSize);
-        }
-    }
-}
-
-QualcommCameraHardware::AshmemPool::AshmemPool(int buffer_size, int num_buffers,
-                                               int frame_size,
-                                               const char *name) :
-    QualcommCameraHardware::MemPool(buffer_size,
-                                    num_buffers,
-                                    frame_size,
-                                    name)
-{
-    LOGV("constructing MemPool %s backed by ashmem: "
-         "%d frames @ %d uint8_ts, "
-         "buffer size %d",
-         mName,
-         num_buffers, frame_size, buffer_size);
-
-    int page_mask = getpagesize() - 1;
-    int ashmem_size = buffer_size * num_buffers;
-    ashmem_size += page_mask;
-    ashmem_size &= ~page_mask;
-
-    mHeap = new MemoryHeapBase(ashmem_size);
-
-    completeInitialization();
-}
-
-static bool register_buf(int camfd,
-                         int size,
-                         int frame_size,
-                         int pmempreviewfd,
-                         uint32_t offset,
-                         uint8_t *buf,
-                         int pmem_type,
-                         bool vfe_can_write,
-                         bool register_buffer = true);
-
-QualcommCameraHardware::PmemPool::PmemPool(const char *pmem_pool,
-                                           int flags,
-                                           int camera_control_fd,
-                                           int pmem_type,
-                                           int buffer_size, int num_buffers,
-                                           int frame_size,
-                                           const char *name) :
-    QualcommCameraHardware::MemPool(buffer_size,
-                                    num_buffers,
-                                    frame_size,
-                                    name),
-    mPmemType(pmem_type),
-    mCameraControlFd(dup(camera_control_fd))
-{
-    LOGV("constructing MemPool %s backed by pmem pool %s: "
-         "%d frames @ %d bytes, buffer size %d",
-         mName,
-         pmem_pool, num_buffers, frame_size,
-         buffer_size);
-
-    LOGV("%s: duplicating control fd %d --> %d",
-         __FUNCTION__,
-         camera_control_fd, mCameraControlFd);
-
-    // Make a new mmap'ed heap that can be shared across processes.
-    // mAlignedBufferSize is already in 4k aligned. (do we need total size necessary to be in power of 2??)
-    mAlignedSize = mAlignedBufferSize * num_buffers;
-
-    sp<MemoryHeapBase> masterHeap =
-        new MemoryHeapBase(pmem_pool, mAlignedSize, flags);
-
-    if (masterHeap->getHeapID() < 0) {
-        LOGE("failed to construct master heap for pmem pool %s", pmem_pool);
-        masterHeap.clear();
-        return;
-    }
-
-    sp<MemoryHeapPmem> pmemHeap = new MemoryHeapPmem(masterHeap, flags);
-    if (pmemHeap->getHeapID() >= 0) {
-        pmemHeap->slap();
-        masterHeap.clear();
-        mHeap = pmemHeap;
-        pmemHeap.clear();
-
-        mFd = mHeap->getHeapID();
-        if (::ioctl(mFd, PMEM_GET_SIZE, &mSize)) {
-            LOGE("pmem pool %s ioctl(PMEM_GET_SIZE) error %s (%d)",
-                 pmem_pool,
-                 ::strerror(errno), errno);
-            mHeap.clear();
-            return;
-        }
-
-        LOGV("pmem pool %s ioctl(fd = %d, PMEM_GET_SIZE) is %ld",
-             pmem_pool,
-             mFd,
-             mSize.len);
-        LOGD("mBufferSize=%d, mAlignedBufferSize=%d\n", mBufferSize, mAlignedBufferSize);
-        // Unregister preview buffers with the camera drivers.  Allow the VFE to write
-        // to all preview buffers except for the last one.
-        // Only Register the preview, snapshot and thumbnail buffers with the kernel.
-        if( (strcmp("postview", mName) != 0) ){
-            int num_buf = num_buffers;
-            if(!strcmp("preview", mName)) num_buf = kPreviewBufferCount;
-            LOGD("num_buffers = %d", num_buf);
-            for (int cnt = 0; cnt < num_buf; ++cnt) {
-                int active = 1;
-                if(pmem_type == MSM_PMEM_VIDEO){
-                     active = (cnt<ACTIVE_VIDEO_BUFFERS);
-                     LOGV(" pmempool creating video buffers : active %d ", active);
-                }
-                else if (pmem_type == MSM_PMEM_PREVIEW){
-                     active = (cnt < (num_buf-1));
-                }
-                register_buf(mCameraControlFd,
-                         mBufferSize,
-                         mFrameSize,
-                         mHeap->getHeapID(),
-                         mAlignedBufferSize * cnt,
-                         (uint8_t *)mHeap->base() + mAlignedBufferSize * cnt,
-                         pmem_type,
-                         active);
-            }
-        }
-
-        completeInitialization();
-    }
-    else LOGE("pmem pool %s error: could not create master heap!",
-              pmem_pool);
-}
-
-QualcommCameraHardware::PmemPool::~PmemPool()
-{
-    LOGV("%s: %s E", __FUNCTION__, mName);
-    if (mHeap != NULL) {
-        // Unregister preview buffers with the camera drivers.
-        //  Only Unregister the preview, snapshot and thumbnail
-        //  buffers with the kernel.
-        if( (strcmp("postview", mName) != 0) ){
-            int num_buffers = mNumBuffers;
-            if(!strcmp("preview", mName)) num_buffers = kPreviewBufferCount;
-            for (int cnt = 0; cnt < num_buffers; ++cnt) {
-                register_buf(mCameraControlFd,
-                         mBufferSize,
-                         mFrameSize,
-                         mHeap->getHeapID(),
-                         mAlignedBufferSize * cnt,
-                         (uint8_t *)mHeap->base() + mAlignedBufferSize * cnt,
-                         mPmemType,
-                         false,
-                         false /* unregister */);
-            }
-        }
-    }
-    LOGV("destroying PmemPool %s: closing control fd %d",
-         mName,
-         mCameraControlFd);
-    close(mCameraControlFd);
-    LOGV("%s: %s X", __FUNCTION__, mName);
-}
-
-QualcommCameraHardware::MemPool::~MemPool()
-{
-    LOGV("destroying MemPool %s", mName);
-    if (mFrameSize > 0)
-        delete [] mBuffers;
-    mHeap.clear();
-    LOGV("destroying MemPool %s completed", mName);
-}
-
-static bool register_buf(int camfd,
-                         int size,
-                         int frame_size,
-                         int pmempreviewfd,
-                         uint32_t offset,
-                         uint8_t *buf,
-                         int pmem_type,
-                         bool vfe_can_write,
-                         bool register_buffer)
-{
-    struct msm_pmem_info pmemBuf;
-
-    pmemBuf.type     = pmem_type;
-    pmemBuf.fd       = pmempreviewfd;
-    pmemBuf.offset   = offset;
-    pmemBuf.len      = size;
-    pmemBuf.vaddr    = buf;
-    pmemBuf.y_off    = 0;
-
-    if(pmem_type == MSM_PMEM_RAW_MAINIMG)
-        pmemBuf.cbcr_off = 0;
-    else
-        pmemBuf.cbcr_off = PAD_TO_WORD(frame_size * 2 / 3);
-
-    pmemBuf.active   = vfe_can_write;
-
-    LOGV("register_buf: camfd = %d, reg = %d buffer = %p can_write = %d",
-         camfd, !register_buffer, buf, pmemBuf.active);
-    if (ioctl(camfd,
-              register_buffer ?
-              MSM_CAM_IOCTL_REGISTER_PMEM :
-              MSM_CAM_IOCTL_UNREGISTER_PMEM,
-              &pmemBuf) < 0) {
-        LOGE("register_buf: MSM_CAM_IOCTL_(UN)REGISTER_PMEM fd %d error %s",
-             camfd,
-             strerror(errno));
-        return false;
-    }
-    return true;
-}
-
-status_t QualcommCameraHardware::MemPool::dump(int fd, const Vector<String16>& args) const
-{
-    const size_t SIZE = 256;
-    char buffer[SIZE];
-    String8 result;
-    snprintf(buffer, 255, "QualcommCameraHardware::AshmemPool::dump\n");
-    result.append(buffer);
-    if (mName) {
-        snprintf(buffer, 255, "mem pool name (%s)\n", mName);
-        result.append(buffer);
-    }
-    if (mHeap != 0) {
-        snprintf(buffer, 255, "heap base(%p), size(%d), flags(%d), device(%s)\n",
-                 mHeap->getBase(), mHeap->getSize(),
-                 mHeap->getFlags(), mHeap->getDevice());
-        result.append(buffer);
-    }
-    snprintf(buffer, 255,
-             "buffer size (%d), number of buffers (%d), frame size(%d)",
-             mBufferSize, mNumBuffers, mFrameSize);
-    result.append(buffer);
-    write(fd, result.string(), result.size());
-    return NO_ERROR;
-}
-
-static void receive_camframe_callback(struct msm_frame *frame)
-{
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-        obj->receivePreviewFrame(frame);
-    }
-}
-
-static void receive_jpeg_fragment_callback(uint8_t *buff_ptr, uint32_t buff_size)
-{
-    LOGV("receive_jpeg_fragment_callback E");
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-        obj->receiveJpegPictureFragment(buff_ptr, buff_size);
-    }
-    LOGV("receive_jpeg_fragment_callback X");
-}
-
-static void receive_jpeg_callback(jpeg_event_t status)
-{
-    LOGV("receive_jpeg_callback E (completion status %d)", status);
-    if (status == JPEG_EVENT_DONE) {
-        sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-        if (obj != 0) {
-            obj->receiveJpegPicture();
-        }
-    }
-    LOGV("receive_jpeg_callback X");
-}
-// 720p : video frame calbback from camframe
-static void receive_camframe_video_callback(struct msm_frame *frame)
-{
-    LOGV("receive_camframe_video_callback E");
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-			obj->receiveRecordingFrame(frame);
-		 }
-    LOGV("receive_camframe_video_callback X");
-}
-
-void QualcommCameraHardware::setCallbacks(notify_callback notify_cb,
-                             data_callback data_cb,
-                             data_callback_timestamp data_cb_timestamp,
-                             void* user)
-{
-    Mutex::Autolock lock(mLock);
-    mNotifyCallback = notify_cb;
-    mDataCallback = data_cb;
-    mDataCallbackTimestamp = data_cb_timestamp;
-    mCallbackCookie = user;
-}
-
-void QualcommCameraHardware::enableMsgType(int32_t msgType)
-{
-    Mutex::Autolock lock(mLock);
-    mMsgEnabled |= msgType;
-}
-
-void QualcommCameraHardware::disableMsgType(int32_t msgType)
-{
-    Mutex::Autolock lock(mLock);
-    mMsgEnabled &= ~msgType;
-}
-
-bool QualcommCameraHardware::msgTypeEnabled(int32_t msgType)
-{
-    return (mMsgEnabled & msgType);
-}
-
-bool QualcommCameraHardware::useOverlay(void)
-{
-    if( mCurrentTarget == TARGET_MSM7630 ) {
-        /* Only 7x30 supports Overlay */
-        mUseOverlay = TRUE;
-    } else
-        mUseOverlay = FALSE;
-
-    LOGV(" Using Overlay : %s ", mUseOverlay ? "YES" : "NO" );
-    return mUseOverlay;
-}
-
-status_t QualcommCameraHardware::setOverlay(const sp<Overlay> &Overlay)
-{
-    if( Overlay != NULL) {
-        LOGV(" Valid overlay object ");
-        mOverlayLock.lock();
-        mOverlay = Overlay;
-        mOverlayLock.unlock();
-    } else {
-        LOGV(" Overlay object NULL. returning ");
-        mOverlay = NULL;
-        return UNKNOWN_ERROR;
-    }
-    return NO_ERROR;
-}
-
-void QualcommCameraHardware::receive_camframetimeout(void) {
-    LOGV("receive_camframetimeout: E");
-    Mutex::Autolock l(&mCamframeTimeoutLock);
-    LOGD(" Camframe timed out. Not receiving any frames from camera driver ");
-    camframe_timeout_flag = TRUE;
-    mNotifyCallback(CAMERA_MSG_ERROR, CAMERA_ERROR_UKNOWN, 0,
-                    mCallbackCookie);
-    LOGV("receive_camframetimeout: X");
-}
-
-static void receive_camframetimeout_callback(void) {
-    sp<QualcommCameraHardware> obj = QualcommCameraHardware::getInstance();
-    if (obj != 0) {
-        obj->receive_camframetimeout();
-    }
-}
-
-void QualcommCameraHardware::storePreviewFrameForPostview(void) {
-    LOGV(" storePreviewFrameForPostview : E ");
-
-    /* Since there is restriction on the maximum overlay dimensions
-     * that can be created, we use the last preview frame as postview
-     * for 7x30. */
-    LOGV(" Copying the preview buffer to postview buffer %d  ", 
-         mPreviewFrameSize);
-    if( mPostViewHeap != NULL && mLastQueuedFrame != NULL) {
-	memcpy(mPostViewHeap->mHeap->base(),
-		(uint8_t *)mLastQueuedFrame, mPreviewFrameSize );
-    } else
-        LOGE(" Failed to store Preview frame. No Postview ");
-
-    LOGV(" storePreviewFrameForPostview : X ");
-}
-
-bool QualcommCameraHardware::isValidDimension(int width, int height) {
-    bool retVal = FALSE;
-    /* This function checks if a given resolution is valid or not.
-     * A particular resolution is considered valid if it satisfies
-     * the following conditions:
-     * 1. width & height should be multiple of 16.
-     * 2. width & height should be less than/equal to the dimensions
-     *    supported by the camera sensor.
-     * 3. the aspect ratio is a valid aspect ratio and is among the
-     *    commonly used aspect ratio as determined by the thumbnail_sizes
-     *    data structure.
-     */
-
-    if( (width == CEILING16(width)) && (height == CEILING16(height))
-     && (width <= sensorType->max_supported_snapshot_width)
-     && (height <= sensorType->max_supported_snapshot_height) )
-    {
-        uint32_t pictureAspectRatio = (uint32_t)((width * Q12)/height);
-        for(int i = 0; i < THUMBNAIL_SIZE_COUNT; i++ ) {
-            if(thumbnail_sizes[i].aspect_ratio == pictureAspectRatio) {
-                retVal = TRUE;
-                break;
-            }
-        }
-    }
-    return retVal;
-}
-status_t QualcommCameraHardware::getBufferInfo(sp<IMemory>& Frame, size_t *alignedSize) {
-    status_t ret;
-    LOGV(" getBufferInfo : E ");
-    if( ( mCurrentTarget == TARGET_MSM7630 ) || (mCurrentTarget == TARGET_QSD8250) )
+    const char* const QualcommCameraHardware::getCameraStateStr(
+        QualcommCameraHardware::qualcomm_camera_state s)
     {
-	if( mRecordHeap != NULL){
-		LOGV(" Setting valid buffer information ");
-		Frame = mRecordHeap->mBuffers[0];
-		if( alignedSize != NULL) {
-			*alignedSize = mRecordHeap->mAlignedBufferSize;
-			LOGV(" HAL : alignedSize = %d ", *alignedSize);
-			ret = NO_ERROR;
-		} else {
-	        	LOGE(" HAL : alignedSize is NULL. Cannot update alignedSize ");
-	        	ret = UNKNOWN_ERROR;
-		}
-        } else {
-		LOGE(" RecordHeap is null. Buffer information wont be updated ");
-		Frame = NULL;
-		ret = UNKNOWN_ERROR;
-	}
-    } else {
-	if(mPreviewHeap != NULL) {
-		LOGV(" Setting valid buffer information ");
-		Frame = mPreviewHeap->mBuffers[0];
-		if( alignedSize != NULL) {
-			*alignedSize = mPreviewHeap->mAlignedBufferSize;
-		        LOGV(" HAL : alignedSize = %d ", *alignedSize);
-		        ret = NO_ERROR;
-	        } else {
-		        LOGE(" HAL : alignedSize is NULL. Cannot update alignedSize ");
-		        ret = UNKNOWN_ERROR;
-	        }
-	} else {
-	        LOGE(" PreviewHeap is null. Buffer information wont be updated ");
-	        Frame = NULL;
-	        ret = UNKNOWN_ERROR;
-	}
+        static const char* states[] = {
+#define STATE_STR(x) #x
+            STATE_STR(QCS_INIT),
+            STATE_STR(QCS_IDLE),
+            STATE_STR(QCS_ERROR),
+            STATE_STR(QCS_PREVIEW_IN_PROGRESS),
+            STATE_STR(QCS_WAITING_RAW),
+            STATE_STR(QCS_WAITING_JPEG),
+            STATE_STR(QCS_INTERNAL_PREVIEW_STOPPING),
+            STATE_STR(QCS_INTERNAL_PREVIEW_REQUESTED),
+            STATE_STR(QCS_INTERNAL_RAW_REQUESTED),
+            STATE_STR(QCS_INTERNAL_STOPPING),
+#undef STATE_STR
+        };
+        return states[s];
     }
-    LOGV(" getBufferInfo : X ");
-    return ret;
-}
 
 }; // namespace android
diff --git a/device/zte/blade/libcamera/QualcommCameraHardware.h b/device/zte/blade/libcamera/QualcommCameraHardware.h
index 82259c5..2cd417e 100644
--- a/device/zte/blade/libcamera/QualcommCameraHardware.h
+++ b/device/zte/blade/libcamera/QualcommCameraHardware.h
@@ -1,27 +1,17 @@
 /*
-** Copyright 2008, Google Inc.
-** Copyright (c) 2009, Code Aurora Forum. All rights reserved.
-** Copyright (c) 2010, Ricardo Cerqueira
+** Copyright 2008, The Android Open-Source Project
 **
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
+** Licensed under the Apache License, Version 2.0 (the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
 **
-**     http://www.apache.org/licenses/LICENSE-2.0
+**     http://www.apache.org/licenses/LICENSE-2.0 
 **
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
+** Unless required by applicable law or agreed to in writing, software 
+** distributed under the License is distributed on an "AS IS" BASIS, 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+** See the License for the specific language governing permissions and 
 ** limitations under the License.
-**
-** NOTICE - (RC)
-**
-** All alterations done to this file to add support for the Z71 terminal
-** are intended for use with CyanogenMod. This includes all the support
-** for ov5642, and the reverse engineered bits like ioctls and EXIF 
-** referred to below as "Values originally from proprietary headers")
-** Please do not change the EXIF header without asking me first.
 */
 
 #ifndef ANDROID_HARDWARE_QUALCOMM_CAMERA_HARDWARE_H
@@ -30,332 +20,11 @@
 #include <camera/CameraHardwareInterface.h>
 #include <binder/MemoryBase.h>
 #include <binder/MemoryHeapBase.h>
-#include <stdint.h>
-#include <ui/Overlay.h>
 
 extern "C" {
-#include <linux/android_pmem.h>
-#include <msm_camera.h>
-}
-
-struct str_map {
-    const char *const desc;
-    int val;
-};
-
-typedef enum {
-    TARGET_MSM7625,
-    TARGET_MSM7627,
-    TARGET_QSD8250,
-    TARGET_MSM7630,
-    TARGET_MAX
-}targetType;
-
-struct target_map {
-    const char *targetStr;
-    targetType targetEnum;
-};
-
-struct board_property{
-    targetType target;
-    unsigned int previewSizeMask;
-};
-
-/* Values originally in proprietary headers */
-
-#define MSM_CAMERA_CONTROL "/dev/msm_camera/control0"
-
-#define TRUE 1
-#define FALSE 0
-
-#define CAMERA_MIN_CONTRAST 0
-#define CAMERA_MAX_CONTRAST 4
-#define CAMERA_MIN_SHARPNESS 0
-#define CAMERA_MIN_EXPOSURE_COMPENSATION -2
-#define CAMERA_MAX_SHARPNESS 4
-#define CAMERA_MIN_SATURATION 0
-#define CAMERA_MAX_SATURATION 4
-#define CAMERA_MAX_EXPOSURE_COMPENSATION 2
-#define CAMERA_DEF_SHARPNESS 2
-#define CAMERA_DEF_CONTRAST 2
-#define CAMERA_DEF_SATURATION 2
-#define CAMERA_DEF_EXPOSURE_COMPENSATION "0"
-#define CAMERA_EXPOSURE_COMPENSATION_STEP 1
-
-#define CEILING16(x) (x&0xfffffff0)
-#define PAD_TO_WORD(x) ((x&1) ? x+1 : x)
-
-#define JPEG_EVENT_DONE 0
-#define CAM_CTRL_SUCCESS 1
-
-#define MINIMUM_FPS 10
-#define DEFAULT_FPS 15
-#define MAXIMUM_FPS 25
-
-typedef struct {
-	unsigned int in1_w;
-	unsigned int in1_h;
-	unsigned int out1_w;
-	unsigned int out1_h;
-	unsigned int in2_w;
-	unsigned int in2_h;
-	unsigned int out2_w;
-	unsigned int out2_h;
-	uint8_t update_flag; 
-} common_crop_t;
-
-typedef uint8_t cam_ctrl_type;
-
-typedef struct {
-	unsigned short video_width;
-	unsigned short video_height;
-	unsigned short picture_width;
-	unsigned short picture_height;
-	unsigned short display_width;
-	unsigned short display_height;
-	unsigned short orig_picture_dx;
-	unsigned short orig_picture_dy;
-	unsigned short ui_thumbnail_height;
-	unsigned short ui_thumbnail_width;
-	unsigned short thumbnail_width;
-	unsigned short thumbnail_height;
-	unsigned short raw_picture_height;
-	unsigned short raw_picture_width;
-	unsigned short filler7;
-	unsigned short filler8;
-} cam_ctrl_dimension_t;
-
-typedef struct {
-	uint32_t timestamp;  /* seconds since 1/6/1980          */
-	double   latitude;   /* degrees, WGS ellipsoid */
-	double   longitude;  /* degrees                */
-	int16_t  altitude;   /* meters                          */
-} camera_position_type;
-typedef uint8_t jpeg_event_t;
-
-typedef enum {
-	CAMERA_WB_MIN_MINUS_1,
-	CAMERA_WB_AUTO = 1,  /* This list must match aeecamera.h */
-	CAMERA_WB_CUSTOM,
-	CAMERA_WB_INCANDESCENT,
-	CAMERA_WB_FLUORESCENT,
-	CAMERA_WB_DAYLIGHT,
-	CAMERA_WB_CLOUDY_DAYLIGHT,
-	CAMERA_WB_TWILIGHT,
-	CAMERA_WB_SHADE,
-	CAMERA_WB_MAX_PLUS_1
-} camera_wb_type;
-
-typedef enum {
-    CAMERA_ANTIBANDING_OFF,
-    CAMERA_ANTIBANDING_60HZ,
-    CAMERA_ANTIBANDING_50HZ,
-    CAMERA_ANTIBANDING_AUTO,
-    CAMERA_MAX_ANTIBANDING,
-} camera_antibanding_type;
-
-typedef enum {
-	AF_MODE_NORMAL,
-	AF_MODE_MACRO,
-	AF_MODE_AUTO,
-} isp3a_af_mode_t;
-
-enum {
-	CAMERA_AEC_FRAME_AVERAGE,
-	CAMERA_AEC_CENTER_WEIGHTED,
-	CAMERA_AEC_SPOT_METERING,
-};
-
-enum {
-	LED_MODE_OFF,
-	LED_MODE_AUTO,
-	LED_MODE_ON,
-};
-
-typedef enum {
-	CAMERA_ISO_AUTO,
-	CAMERA_ISO_DEBLUR,
-	CAMERA_ISO_100,
-	CAMERA_ISO_200,
-	CAMERA_ISO_400,
-	CAMERA_ISO_800,
-	CAMERA_ISO_1600,
-} camera_iso_mode_type;
-
-struct fifo_queue {
-	int num_of_frames;
-	int front;
-	struct fifo_node *node;
-	pthread_mutex_t mut;
-	pthread_cond_t wait;
-};
-
-struct fifo_node {
-	struct msm_frame *f;
-	struct fifo_node *next;
-};
-
-void enqueue(struct fifo_queue *queue, struct fifo_node *node) {
-	struct fifo_node *cur_node=queue->node;
-	int i;
-	LOGE("enqueue:%p(%d)\n", node, queue->num_of_frames);
-	node->next=NULL;
-	if(queue->num_of_frames==0) {
-		queue->num_of_frames++;
-		queue->front=!!queue->num_of_frames;
-		queue->node=node;
-		return;
-	}
-	queue->num_of_frames++;
-	queue->front=!!queue->num_of_frames;
-	for(i=0;i<(queue->num_of_frames-2);++i) {
-		cur_node=cur_node->next;
-		assert(!!cur_node);
-	}
-	cur_node->next=node;
+    #include <linux/android_pmem.h>
 }
 
-struct fifo_node *dequeue(struct fifo_queue *queue) {
-	if(queue->num_of_frames==0)
-		return NULL;
-	struct fifo_node *node=queue->node;
-	LOGE("dequeue:%p(%d)\n", node, queue->num_of_frames);
-	queue->num_of_frames--;
-	queue->front=!!queue->num_of_frames;
-	queue->node=queue->node->next;
-	return node;
-}
-
-
-enum camera_ops {
-    CAMERA_SET_PARM_ENCODE_ROTATION,
-    CAMERA_SET_PARM_DIMENSION,
-    CAMERA_SET_PARM_ZOOM,
-    CAMERA_SET_PARM_SENSOR_POSITION,
-    CAMERA_SET_PARM_SHARPNESS,
-    CAMERA_SET_PARM_LUMA_ADAPTATION,
-    CAMERA_SET_PARM_CONTRAST,
-    CAMERA_SET_PARM_EXPOSURE_COMPENSATION,
-    CAMERA_SET_PARM_BRIGHTNESS,
-    CAMERA_SET_PARM_FOCUS_RECT,
-    CAMERA_SET_PARM_HUE,
-    CAMERA_SET_PARM_SATURATION,
-    CAMERA_SET_PARM_EXPOSURE,
-    CAMERA_SET_PARM_AUTO_FOCUS,
-    CAMERA_SET_PARM_WB,
-    CAMERA_SET_PARM_EFFECT,
-    CAMERA_SET_PARM_FPS,
-    CAMERA_SET_PARM_FLASH,
-    CAMERA_SET_PARM_NIGHTSHOT_MODE,
-    CAMERA_SET_PARM_REFLECT,
-    CAMERA_SET_PARM_PREVIEW_MODE,
-    CAMERA_SET_PARM_ANTIBANDING,
-    CAMERA_SET_PARM_RED_EYE_REDUCTION,
-    CAMERA_SET_PARM_FOCUS_STEP,
-    CAMERA_SET_PARM_EXPOSURE_METERING,
-    CAMERA_SET_PARM_AUTO_EXPOSURE_MODE,
-    CAMERA_SET_PARM_ISO,
-    CAMERA_SET_PARM_BESTSHOT_MODE,
-    CAMERA_SET_PARM_PREVIEW_FPS,
-    CAMERA_SET_PARM_AF_MODE,
-    CAMERA_SET_PARM_HISTOGRAM,
-    CAMERA_SET_PARM_FLASH_STATE,
-    CAMERA_SET_PARM_FRAME_TIMESTAMP,
-    CAMERA_SET_PARM_STROBE_FLASH,
-    CAMERA_SET_PARM_FPS_LIST,
-    CAMERA_SET_PARM_HJR,
-    CAMERA_SET_PARM_ROLLOFF=37,
-    CAMERA_STOP_PREVIEW=38,
-    CAMERA_START_PREVIEW,
-    CAMERA_START_SNAPSHOT,
-    CAMERA_START_VIDEO,
-    CAMERA_STOP_SNAPSHOT=42,
-    CAMERA_EXIT=43,
-    CAMERA_STOP_VIDEO,
-    CAMERA_START_RECORDING,
-    CAMERA_STOP_RECORDING,
-    CAMERA_GET_PARM_MAXZOOM,
-    CAMERA_START_RAW_SNAPSHOT,
-    CAMERA_SET_PARM_LED_MODE,
-    CAMERA_GET_PARM_AF_SHARPNESS,
-    CAMERA_SET_MOTION_ISO,
-    CAMERA_AUTO_FOCUS_CANCEL,
-    CAMERA_GET_PARM_FOCUS_STEP,
-    CAMERA_ENABLE_AFD,
-    CAMERA_PREPARE_SNAPSHOT,
-    CAMERA_SET_FPS_MODE,
-    CAMERA_SET_PARM_SCENE_MODE,
-};
-
-typedef enum {
-	CAMERA_RSP_CB_SUCCESS,
-	CAMERA_EXIT_CB_DONE,
-	CAMERA_EXIT_CB_FAILED,
-	CAMERA_EXIT_CB_DSP_IDLE,
-	CAMERA_EXIT_CB_DSP_ABORT,
-	CAMERA_EXIT_CB_ABORT,
-	CAMERA_EXIT_CB_ERROR,
-	CAMERA_EVT_CB_FRAME,
-	CAMERA_EVT_CB_PICTURE,
-	CAMERA_STATUS_CB,
-	CAMERA_EXIT_CB_FILE_SIZE_EXCEEDED,
-	CAMERA_EXIT_CB_BUFFER,
-	CAMERA_EVT_CB_SNAPSHOT_DONE,
-	CAMERA_CB_MAX,
-} camera_cb_type;
-
-struct cam_frame_start_parms {
-	unsigned int unknown;
-	struct msm_frame frame;
-	struct msm_frame video_frame;
-};
-
-typedef unsigned int exif_tag_id_t;
-
-#define EXIF_RATIONAL 5
-#define EXIF_ASCII 2
-#define EXIF_BYTE 1
-
-typedef struct {
-	int val;
-	int otherval;
-} rat_t;
-
-
-typedef union {
-        char * _ascii; /* At byte 16 relative to exif_tag_entry_t */
-        rat_t * _rats;
-        rat_t  _rat;
-        uint8_t _byte;
-} exif_tag_data_t;
-
-/* The entire exif_tag_entry_t struct must be 24 bytes in length */
-typedef unsigned int exif_tag_type_t;
-typedef struct {
-	exif_tag_type_t type;
-	uint32_t copy;
-	uint32_t count;
-	exif_tag_data_t data;
-} exif_tag_entry_t;
-
-typedef struct {
-	exif_tag_id_t tag_id;
-	exif_tag_entry_t tag_entry;
-} exif_tags_info_t;
-
-/* EXIF tag IDs */
-#define EXIFTAGID_GPS_LATITUDE 0x20002
-#define EXIFTAGID_GPS_LATITUDE_REF 0x10001
-#define EXIFTAGID_GPS_LONGITUDE 0x40004
-#define EXIFTAGID_GPS_LONGITUDE_REF 0x30003
-#define EXIFTAGID_GPS_ALTITUDE 0x60006
-#define EXIFTAGID_GPS_ALTITUDE_REF 0x50005
-#define EXIFTAGID_EXIF_CAMERA_MAKER 0x21010F
-#define EXIFTAGID_EXIF_CAMERA_MODEL 0x220110
-#define EXIFTAGID_EXIF_DATE_TIME_ORIGINAL 0x3A9003
-#define EXIFTAGID_EXIF_DATE_TIME 0x3B9004
-/* End of values originally in proprietary headers */
-
 namespace android {
 
 class QualcommCameraHardware : public CameraHardwareInterface {
@@ -364,76 +33,71 @@ public:
     virtual sp<IMemoryHeap> getPreviewHeap() const;
     virtual sp<IMemoryHeap> getRawHeap() const;
 
-    virtual void setCallbacks(notify_callback notify_cb,
-                              data_callback data_cb,
-                              data_callback_timestamp data_cb_timestamp,
-                              void* user);
-    virtual void enableMsgType(int32_t msgType);
-    virtual void disableMsgType(int32_t msgType);
-    virtual bool msgTypeEnabled(int32_t msgType);
-
-    virtual status_t dump(int fd, const Vector<String16>& args) const;
-    virtual status_t startPreview();
-    virtual void stopPreview();
-    virtual bool previewEnabled();
-    virtual status_t startRecording();
-    virtual void stopRecording();
-    virtual bool recordingEnabled();
-    virtual void releaseRecordingFrame(const sp<IMemory>& mem);
-    virtual status_t autoFocus();
-    virtual status_t cancelAutoFocus();
-    virtual status_t takePicture();
-    virtual status_t cancelPicture();
-    virtual status_t setParameters(const CameraParameters& params);
-    virtual CameraParameters getParameters() const;
-    virtual status_t sendCommand(int32_t command, int32_t arg1, int32_t arg2);
-    virtual status_t getBufferInfo( sp<IMemory>& Frame, size_t *alignedSize);
+    virtual status_t    dump(int fd, const Vector<String16>& args) const;
+    virtual status_t    startPreview(preview_callback cb, void* user);
+    virtual void        stopPreview();
+    virtual bool        previewEnabled();
+    virtual status_t    startRecording(recording_callback cb, void* user);
+    virtual void        stopRecording();
+    virtual bool        recordingEnabled();
+    virtual void        releaseRecordingFrame(const sp<IMemory>& mem);
+    virtual status_t    autoFocus(autofocus_callback, void *user);
+    virtual status_t    takePicture(shutter_callback,
+                                    raw_callback,
+                                    jpeg_callback,
+                                    void* user);
+    virtual status_t    cancelPicture(bool cancel_shutter,
+                                      bool cancel_raw, bool cancel_jpeg);
+    virtual status_t    setParameters(const CameraParameters& params);
+    virtual CameraParameters  getParameters() const;
 
     virtual void release();
-    virtual bool useOverlay();
-    virtual status_t setOverlay(const sp<Overlay> &overlay);
 
     static sp<CameraHardwareInterface> createInstance();
     static sp<QualcommCameraHardware> getInstance();
 
-    void receivePreviewFrame(struct msm_frame *frame);
-    void receiveRecordingFrame(struct msm_frame *frame);
-    void receiveJpegPicture(void);
-    void jpeg_set_location();
-    void receiveJpegPictureFragment(uint8_t *buf, uint32_t size);
-    void notifyShutter(common_crop_t *crop);
-    void receive_camframetimeout();
+    void* get_preview_mem(uint32_t size, uint32_t *phy_addr, uint32_t index);
+    void* get_raw_mem(uint32_t size, uint32_t *phy_addr, uint32_t index);
+    void free_preview_mem(uint32_t *phy_addr, uint32_t size, uint32_t index);
+    void free_raw_mem(uint32_t *phy_addr, uint32_t size, uint32_t index);
 
 private:
+
     QualcommCameraHardware();
     virtual ~QualcommCameraHardware();
-    status_t startPreviewInternal();
+    status_t startPreviewInternal(preview_callback pcb, void *puser,
+                                  recording_callback rcb, void *ruser);
     void stopPreviewInternal();
-    friend void *auto_focus_thread(void *user);
-    void runAutoFocus();
-    status_t cancelAutoFocusInternal();
-    bool native_set_dimension (int camfd);
-    bool native_jpeg_encode (void);
-    bool native_set_parm(cam_ctrl_type type, uint16_t length, void *value);
-    bool native_zoom_image(int fd, int srcOffset, int dstOffset, common_crop_t *crop);
 
     static wp<QualcommCameraHardware> singleton;
 
-    /* These constants reflect the number of buffers that libmmcamera requires
-       for preview and raw, and need to be updated when libmmcamera
+    /* These constants reflect the number of buffers that libqcamera requires
+       for preview and raw, and need to be updated when libqcamera
        changes.
     */
-    static const int kPreviewBufferCount = NUM_PREVIEW_BUFFERS;
+    static const int kPreviewBufferCount = 4;
     static const int kRawBufferCount = 1;
     static const int kJpegBufferCount = 1;
+    static const int kRawFrameHeaderSize = 0x48;
 
-    int jpegPadding;
-
+    //TODO: put the picture dimensions in the CameraParameters object;
     CameraParameters mParameters;
-    unsigned int frame_size;
-    bool mCameraRunning;
-    Mutex mCameraRunningLock;
-    bool mPreviewInitialized;
+    int mPreviewHeight;
+    int mPreviewWidth;
+    int mRawHeight;
+    int mRawWidth;
+
+    void receivePreviewFrame(camera_frame_type *frame);
+
+    static void stop_camera_cb(camera_cb_type cb,
+            const void *client_data,
+            camera_func_type func,
+            int32_t parm4);
+
+    static void camera_cb(camera_cb_type cb,
+            const void *client_data,
+            camera_func_type func,
+            int32_t parm4);
 
     // This class represents a heap which maintains several contiguous
     // buffers.  The heap may be backed by pmem (when pmem_pool contains
@@ -442,21 +106,22 @@ private:
     struct MemPool : public RefBase {
         MemPool(int buffer_size, int num_buffers,
                 int frame_size,
+                int frame_offset,
                 const char *name);
 
         virtual ~MemPool() = 0;
 
         void completeInitialization();
-        bool initialized() const {
+        bool initialized() const { 
             return mHeap != NULL && mHeap->base() != MAP_FAILED;
         }
 
         virtual status_t dump(int fd, const Vector<String16>& args) const;
 
         int mBufferSize;
-        int mAlignedBufferSize;
         int mNumBuffers;
         int mFrameSize;
+        int mFrameOffset;
         sp<MemoryHeapBase> mHeap;
         sp<MemoryBase> *mBuffers;
 
@@ -466,123 +131,95 @@ private:
     struct AshmemPool : public MemPool {
         AshmemPool(int buffer_size, int num_buffers,
                    int frame_size,
+                   int frame_offset,
                    const char *name);
     };
 
     struct PmemPool : public MemPool {
         PmemPool(const char *pmem_pool,
-                 int control_camera_fd, int flags, int pmem_type,
-                 int buffer_size, int num_buffers,
-                 int frame_size,
-                 const char *name);
-        virtual ~PmemPool();
+                int buffer_size, int num_buffers,
+                int frame_size,
+                int frame_offset,
+                const char *name);
+        virtual ~PmemPool() { }
         int mFd;
-        int mPmemType;
-        int mCameraControlFd;
         uint32_t mAlignedSize;
         struct pmem_region mSize;
     };
 
-    sp<PmemPool> mPreviewHeap;
-    sp<PmemPool> mRecordHeap;
-    sp<PmemPool> mThumbnailHeap;
-    sp<PmemPool> mRawHeap;
-    sp<PmemPool> mDisplayHeap;
-    sp<AshmemPool> mJpegHeap;
-    sp<PmemPool> mRawSnapShotPmemHeap;
-    sp<PmemPool> mPostViewHeap;
+    struct PreviewPmemPool : public PmemPool {
+        virtual ~PreviewPmemPool();
+        PreviewPmemPool(int buffer_size, int num_buffers,
+                        int frame_size,
+                        int frame_offset,
+                        const char *name);
+    };
 
+    struct RawPmemPool : public PmemPool {
+        virtual ~RawPmemPool();
+        RawPmemPool(const char *pmem_pool,
+                    int buffer_size, int num_buffers,
+                    int frame_size,
+                    int frame_offset,
+                    const char *name);
+    };
+
+    sp<PreviewPmemPool> mPreviewHeap;
+    sp<RawPmemPool> mRawHeap;
+    sp<AshmemPool> mJpegHeap;
 
-    bool startCamera();
+    void startCameraIfNecessary();
     bool initPreview();
-    bool initRecord();
     void deinitPreview();
     bool initRaw(bool initJpegHeap);
-    bool initRawSnapshot();
-    void deinitRaw();
-    void deinitRawSnapshot();
-
-    bool mFrameThreadRunning;
-    Mutex mFrameThreadWaitLock;
-    Condition mFrameThreadWait;
-    friend void *frame_thread(void *user);
-    void runFrameThread(void *data);
-
-    //720p recording video thread
-    bool mVideoThreadExit;
-    bool mVideoThreadRunning;
-    Mutex mVideoThreadWaitLock;
-    Condition mVideoThreadWait;
-    friend void *video_thread(void *user);
-    void runVideoThread(void *data);
-
-
-    bool mShutterPending;
-    Mutex mShutterLock;
-
-    bool mSnapshotThreadRunning;
-    Mutex mSnapshotThreadWaitLock;
-    Condition mSnapshotThreadWait;
-    friend void *snapshot_thread(void *user);
-    void runSnapshotThread(void *data);
-    Mutex mRawPictureHeapLock;
-    bool mJpegThreadRunning;
-    Mutex mJpegThreadWaitLock;
-    Condition mJpegThreadWait;
-    bool mInSnapshotMode;
-    Mutex mInSnapshotModeWaitLock;
-    Condition mInSnapshotModeWait;
-
-    void debugShowPreviewFPS() const;
-    void debugShowVideoFPS() const;
-
-    int mSnapshotFormat;
-    void filterPictureSizes();
-    void filterPreviewSizes();
-    void storeTargetType();
 
     void initDefaultParameters();
-    void findSensorType();
-
-    status_t setPreviewSize(const CameraParameters& params);
-    status_t setPreviewFrameRate(const CameraParameters& params);
-    status_t setPictureSize(const CameraParameters& params);
-    status_t setJpegQuality(const CameraParameters& params);
-    status_t setAntibanding(const CameraParameters& params);
-    status_t setEffect(const CameraParameters& params);
-    status_t setAutoExposure(const CameraParameters& params);
-    status_t setWhiteBalance(const CameraParameters& params);
-    status_t setFlash(const CameraParameters& params);
-    status_t setGpsLocation(const CameraParameters& params);
-    status_t setRotation(const CameraParameters& params);
-    status_t setZoom(const CameraParameters& params);
-    status_t setFocusMode(const CameraParameters& params);
-    status_t setBrightness(const CameraParameters& params);
-    status_t setExposureCompensation(const CameraParameters& params);
-    status_t setOrientation(const CameraParameters& params);
-    status_t setLensshadeValue(const CameraParameters& params);
-    status_t setISOValue(const CameraParameters& params);
-    status_t setPictureFormat(const CameraParameters& params);
-    status_t setSharpness(const CameraParameters& params);
-    status_t setContrast(const CameraParameters& params);
-    status_t setSaturation(const CameraParameters& params);
-    void setGpsParameters();
-    void storePreviewFrameForPostview();
-    bool isValidDimension(int w, int h);
-
-    Mutex mLock;
-    Mutex mCamframeTimeoutLock;
-    bool camframe_timeout_flag;
-    bool mReleasedRecordingFrame;
-
-    void receiveRawPicture(void);
-    void receiveRawSnapshot(void);
+    void initCameraParameters();
+    void setCameraDimensions();
+
+    // The states described by qualcomm_camera_state are very similar to the
+    // CAMERA_FUNC_xxx notifications reported by libqcamera.  The differences
+    // are that they reflect not only the response from libqcamera, but also
+    // the requests made by the clients of this object.  For example,
+    // QCS_PREVIEW_REQUESTED is a state that we enter when we call
+    // QualcommCameraHardware::startPreview(), and stay in until libqcamera
+    // confirms that it has received the start-preview command (but not
+    // actually initiated preview yet).
+    //
+    // NOTE: keep those values small; they are used internally as indices
+    //       into a array of strings.
+    // NOTE: if you add to this enumeration, make sure you update
+    //       getCameraStateStr().
+
+    enum qualcomm_camera_state {
+        QCS_INIT,
+        QCS_IDLE,
+        QCS_ERROR,
+        QCS_PREVIEW_IN_PROGRESS,
+        QCS_WAITING_RAW,
+        QCS_WAITING_JPEG,
+        /* internal states */
+        QCS_INTERNAL_PREVIEW_STOPPING,
+        QCS_INTERNAL_PREVIEW_REQUESTED,
+        QCS_INTERNAL_RAW_REQUESTED,
+        QCS_INTERNAL_STOPPING,
+    };
+
+    volatile qualcomm_camera_state mCameraState;
+    static const char* const getCameraStateStr(qualcomm_camera_state s);
+    qualcomm_camera_state change_state(qualcomm_camera_state new_state,
+                                       bool lock = true);
+
+    void notifyShutter();
+    void receiveJpegPictureFragment(JPEGENC_CBrtnType *encInfo);
 
+    void receivePostLpmRawPicture(camera_frame_type *frame);
+    void receiveRawPicture(camera_frame_type *frame);
+    void receiveJpegPicture(void);
+
+    Mutex mLock; // API lock -- all public methods
     Mutex mCallbackLock;
-    Mutex mOverlayLock;
-	Mutex mRecordLock;
-	Mutex mRecordFrameLock;
-	Condition mRecordWait;
+    Mutex mStateLock;
     Condition mStateWait;
 
     /* mJpegSize keeps track of the size of the accumulated JPEG.  We clear it
@@ -590,50 +227,39 @@ private:
        zero, or the size of the last JPEG picture taken.
     */
     uint32_t mJpegSize;
-    unsigned int        mPreviewFrameSize;
-    unsigned int        mRecordFrameSize;
+    camera_handle_type camera_handle;
+    camera_encode_properties_type encode_properties;
+    camera_position_type pt;
+
+    shutter_callback    mShutterCallback;
+    raw_callback        mRawPictureCallback;
+    jpeg_callback       mJpegPictureCallback;
+    void                *mPictureCallbackCookie;
+
+    autofocus_callback  mAutoFocusCallback;
+    void                *mAutoFocusCallbackCookie;
+
+    preview_callback    mPreviewCallback;
+    void                *mPreviewCallbackCookie;
+    recording_callback  mRecordingCallback;
+    void                *mRecordingCallbackCookie;
+    bool setCallbacks(preview_callback pcb, void *pu,
+                      recording_callback rcb, void *ru);
+
+    int                 mPreviewFrameSize;
     int                 mRawSize;
     int                 mJpegMaxSize;
 
-#if DLOPEN_LIBMMCAMERA
-    void *libmmcamera;
-#endif
+    // hack to prevent black frame on first preview
+    int                 mPreviewCount;
 
-    int mCameraControlFd;
-    struct msm_camsensor_info mSensorInfo;
-    cam_ctrl_dimension_t mDimension;
-    bool mAutoFocusThreadRunning;
-    Mutex mAutoFocusThreadLock;
-    int mAutoFocusFd;
-
-    Mutex mAfLock;
-
-    pthread_t mFrameThread;
-    pthread_t mVideoThread;
-    pthread_t mSnapshotThread;
-
-    common_crop_t mCrop;
-
-    bool mInitialized;
-
-    int mBrightness;
-    int mHJR;
-    struct msm_frame frames[kPreviewBufferCount];
-    struct msm_frame *recordframes;
-    bool mInPreviewCallback;
-    bool mUseOverlay;
-    sp<Overlay>  mOverlay;
-
-    int32_t mMsgEnabled;    // camera msg to be handled
-    notify_callback mNotifyCallback;
-    data_callback mDataCallback;
-    data_callback_timestamp mDataCallbackTimestamp;
-    void *mCallbackCookie;  // same for all callbacks
-    int mDebugFps;
-    int kPreviewBufferCountActual;
-    int previewWidth, previewHeight;
+#if DLOPEN_LIBQCAMERA == 1
+    void *libqcamera;
+#endif
 };
 
 }; // namespace android
 
 #endif
+
+
diff --git a/device/zte/blade/recovery/recovery.rc b/device/zte/blade/recovery/recovery.rc
deleted file mode 100644
index c4aeb60..0000000
--- a/device/zte/blade/recovery/recovery.rc
+++ /dev/null
@@ -1,46 +0,0 @@
-on early-init
-    start ueventd
-
-# Setup android gadget
-   write /sys/module/g_android/parameters/serial_number CWM-Blade
-   write /sys/module/g_android/parameters/product_id 0x1354
-
-on init
-    export PATH /sbin
-    export ANDROID_ROOT /system
-    export ANDROID_DATA /data
-    export EXTERNAL_STORAGE /sdcard
-
-    symlink /system/etc /etc
-
-    mkdir /boot
-    mkdir /sdcard
-    mkdir /sd-ext
-    mkdir /datadata
-    mkdir /emmc
-    mkdir /system
-    mkdir /data
-    mkdir /cache
-    mount /tmp /tmp tmpfs
-
-on boot
-
-    ifup lo
-    hostname localhost
-    domainname localdomain
-
-    class_start default
-
-service ueventd /sbin/ueventd
-    critical
-
-service recovery /sbin/recovery
-
-service adbd /sbin/adbd recovery
-    disabled
-
-on property:persist.service.adb.enable=1
-    start adbd
-
-on property:persist.service.adb.enable=0
-    stop adbd
diff --git a/device/zte/blade/recovery/recovery_ui.c b/device/zte/blade/recovery/recovery_ui.c
deleted file mode 100644
index e80806d..0000000
--- a/device/zte/blade/recovery/recovery_ui.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <linux/input.h>
-
-#include "recovery_ui.h"
-#include "common.h"
-#include "extendedcommands.h"
-
-char* MENU_HEADERS[] = { "Use vol keys to highlight and home to select.",
-                         "",
-                         NULL };
-
-char* MENU_ITEMS[] = { "reboot system now",
-                       "apply update from sdcard",
-                       "wipe data/factory reset",
-                       "wipe cache partition",
-                       "install zip from sdcard",
-                       "backup and restore",
-                       "mounts and storage",
-                       "advanced",
-                       "power off",
-                       NULL };
-
-int device_recovery_start() {
-    return 0;
-}
-
-int device_toggle_display(volatile char* key_pressed, int key_code) {
-    int alt = key_pressed[KEY_LEFTALT] || key_pressed[KEY_RIGHTALT];
-    if (alt && key_code == KEY_L)
-        return 1;
-    // allow toggling of the display if the correct key is pressed, and the display toggle is allowed or the display is currently off
-    if (ui_get_showing_back_button()) {
-        return get_allow_toggle_display() && (key_code == KEY_MENU || key_code == KEY_END);
-    }
-    return get_allow_toggle_display() && (key_code == KEY_MENU || key_code == KEY_POWER || key_code == KEY_END);
-}
-
-int device_reboot_now(volatile char* key_pressed, int key_code) {
-    return 0;
-}
-
-int device_handle_key(int key_code, int visible) {
-    if (visible) {
-        switch (key_code) {
-            case KEY_CAPSLOCK:
-            case KEY_DOWN:
-            case KEY_VOLUMEUP:
-                return HIGHLIGHT_UP;
-
-            case KEY_LEFTSHIFT:
-            case KEY_UP:
-            case KEY_VOLUMEDOWN:
-                return HIGHLIGHT_DOWN;
-
-            case 62:
-		return SELECT_ITEM;
-
-            case KEY_POWER:
-                if (ui_get_showing_back_button()) {
-                    return SELECT_ITEM;
-                }
-                if (!get_allow_toggle_display())
-                    return GO_BACK;
-                break;
-            case KEY_LEFTBRACE:
-            case KEY_ENTER:
-            case BTN_MOUSE:
-            case KEY_CENTER:
-            case KEY_CAMERA:
-            case KEY_F21:
-            case KEY_SEND:
-	    case KEY_HOME:
-                return SELECT_ITEM;
-            
-            case KEY_END:
-            case KEY_BACKSPACE:
-            case KEY_BACK:
-                if (!get_allow_toggle_display())
-                    return GO_BACK;
-        }
-    }
-
-    return NO_ACTION;
-}
-
-int device_perform_action(int which) {
-    return which;
-}
-
-int device_wipe_data() {
-    return 0;
-}
diff --git a/frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp
index 410d664..684d438 100644
--- a/frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp
@@ -2692,6 +2692,11 @@ void GraphicPlane::setDisplayHardware(DisplayHardware *hw)
         case 90:
             displayOrientation = ISurfaceComposer::eOrientation90;
             break;
+    #ifdef HAS_FLIPPED_SCREEN
+        case 180:
+            displayOrientation = ISurfaceComposer::eOrientation180;
+            break;
+    #endif
         case 180:
             displayOrientation = ISurfaceComposer::eOrientation180;
             break;
diff --git a/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java b/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java
index dcc1dec..276543b 100644
--- a/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java
+++ b/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java
@@ -250,7 +250,10 @@ public final class MccTable
             Log.d(LOG_TAG, "WIFI_COUNTRY_CODE set to " + country);
             WifiManager wM = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
             //persist
-            wM.setCountryCode(country, true);
+	    if (wM != null){
+            	//wM.setCountryCode(country, true);
+		//He's climbin through yo wifi and snatchin yo channels up tryna rape em. Hideja kids, hidja wife, hidja ya husband AND tha dog! They rapin errbody out hur! Fuck this shit!
+	    }
         }else Log.d(LOG_TAG, "WIFI_COUNTRY_CODE is null!");
     }
 
